<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>React Hooks</title>
      <link href="/2023/07/19/React%20Hooks/"/>
      <url>/2023/07/19/React%20Hooks/</url>
      
        <content type="html"><![CDATA[<h3 id="useState"><a href="#useState" class="headerlink" title="useState()"></a>useState()</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(initialState);</span><br></pre></td></tr></table></figure><p>useState 返回两个值，一个是带有初始值的变量，一个是更新这个变量的函数<br>在第一次渲染的时候，返回的状态 state 与传入的第一个参数值相同。<br>setState 函数用于更新 state, 当它接收一个新的 state 值的时候，会将组件的一次重新渲染加入队列，<br><strong>setState 执行渲染，如果是对象，里面的值必须是一个新对象</strong></p><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect();"></a>useEffect();</h3><p>两个参数，第一个参数是一个回调函数。在组件 DOM 加载完毕之后执行的函数，<br><code>可以rerurn 一个函数，这个函数是组件被重新渲染或者卸载时候执行</code></p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//.....执行一些操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//这个函数是组件被重新渲染或者卸载时候执行</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>一个函数式组件中可以存在多个 useEffect，按照顺序依次执行</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;修改title&quot;</span>);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>useEffect 还有第二个参数，作用是 useEffect 回调函数的执行受到那个状态 state 的影响，如果为空数组【】，<br>则只在组件载入时执行一次。 组件卸载时执行内部的回调函数<br>数组中是回调函数依赖的数据，若数据发生变化则在 DOM 渲染完后执行回调函数。</p><h3 id="特殊场景-Hooks"><a href="#特殊场景-Hooks" class="headerlink" title="特殊场景 Hooks"></a>特殊场景 Hooks</h3><h4 id="useContext"><a href="#useContext" class="headerlink" title="useContext()"></a>useContext()</h4><p>首先创建 Context</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> userContext = <span class="title function_">createContext</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">ID</span>: <span class="number">0</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> &#123; userContext &#125;;</span><br></pre></td></tr></table></figure><p>在根组件外面包裹 userContext</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;react-dom/client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; userContext &#125; <span class="keyword">from</span> <span class="string">&quot;./context/index&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>) <span class="keyword">as</span> <span class="title class_">HTMLElement</span></span><br><span class="line">);</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">userContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;</span> <span class="attr">name:</span> &quot;<span class="attr">赵子豪</span>&quot;, <span class="attr">ID:</span> <span class="attr">20211544112</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  &lt;/user</span></span><br></pre></td></tr></table></figure><p>在子组件中使用，直接读取外层传入的信息</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; userContext &#125; <span class="keyword">from</span> <span class="string">&quot;./context&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="title function_">useContext</span>(userContext);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span>user:&#123;user.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p><code>当组件上层最近的&lt;MyContext.Provider&gt; 更新时 该Hooks 会触发重新渲染，并使用最新传递给&lt;MyContext.Provider&gt;的context 的value值</code><br>举一个例子：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">StudentContext</span>, userContext &#125; <span class="keyword">from</span> <span class="string">&quot;./context&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Student</span> <span class="keyword">from</span> <span class="string">&quot;./components/Student&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [age, setage] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> user = <span class="title function_">useContext</span>(userContext);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">addage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">setage</span>(age + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">StudentContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;</span> <span class="attr">name:</span> &quot;<span class="attr">李四</span>&quot;, <span class="attr">age:</span> <span class="attr">age</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span>user:&#123;user.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          addage();</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">        增加年龄</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Student</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">StudentContext.Provider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; memo, useContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">FC</span>, <span class="title class_">ReactNode</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">StudentContext</span> &#125; <span class="keyword">from</span> <span class="string">&quot;../../context&quot;</span>;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">  children?: <span class="title class_">ReactNode</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Student</span>: <span class="variable constant_">FC</span>&lt;<span class="title class_">Props</span>&gt; = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> student = <span class="title function_">useContext</span>(<span class="title class_">StudentContext</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>学生信息是：&#123;student.age&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">memo</span>(<span class="title class_">Student</span>);</span><br></pre></td></tr></table></figure><p>在父组件 App.tsx 中向内通过 Context 传递了一个 Student 信息，并且 age 属性是受 App.tsx 中 addage() 操控的，<br>当在 App.tsx 中改变 age 的值，子组件也重新渲染，更新 age</p><h4 id="useReduce-（了解就行，不咋用）"><a href="#useReduce-（了解就行，不咋用）" class="headerlink" title="useReduce() （了解就行，不咋用）"></a>useReduce() （了解就行，不咋用）</h4><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; counterRducer &#125; <span class="keyword">from</span> <span class="string">&quot;./Reducer&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(counterRducer, &#123; <span class="attr">counter</span>: <span class="number">100</span> &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;state.counter&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &quot;add&quot; &#125;)&#125;&gt;+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &quot;decrement&quot; &#125;)&#125;&gt;-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">counterRducer</span>(<span class="params">state: <span class="built_in">any</span>, action: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">counter</span>: state.<span class="property">counter</span> + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;decrement&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">counter</span>: state.<span class="property">counter</span> - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useState 的替代品，<strong>useState</strong>保存的数据处理逻辑比较复杂时可以使用 useReducer 来将其进行拆分<br>或者这次修改的 state 需要依赖之前的 state 时，也可以使用</p><h4 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback()"></a>useCallback()</h4><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [sum, setnum] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">addsum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">setnum</span>(sum + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>求和：&#123;sum&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;addsum&#125;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>这个组件每次被加载 addsum 都会被定义一次，每次更新 addsum 也会重新定义一次，就造成了内存空间中有许多个 addsum，虽然函数会因为未被使用而被销毁，但是仍会有一下性能问题.</p><ul><li>useCallback 会返回一个函数的 memoized 的值</li><li>在依赖不变的情况下，多次定义的时候，返回的值时相同的，</li></ul><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addsum = <span class="title function_">useCallback</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">setnum</span>(sum + <span class="number">1</span>);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>使用 useCallback 将函数包裹住，第二个参数是依赖项，<br>当点击按钮 触发 addsum 时，组件重新渲染，sum 变为 1，但是由于依赖项为【】空，useCallback 是由记忆的，addsum 不会发生变化，useCallback 返回的函数还是之前的那个函数，因为闭包的原因，返回的函数内部 sum 还是等于 0，所以在此点击按钮 触发 addsum（） sum 的还是 1， 这就是 被称为 <strong>闭包陷阱</strong><br>这就造成 sum 只能加一次；<br>接下来就是正确 ✔ 写法</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addsum = <span class="title function_">useCallback</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">setnum</span>(sum + <span class="number">1</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  [sum]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>到目前为止，使用 useCallback 似乎并没有什么太大的价值，接下来看下面这段代码</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useCallback, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Student</span> <span class="keyword">from</span> <span class="string">&quot;./components/Student/index&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [sum, setnum] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [message, setmessage] = <span class="title function_">useState</span>(<span class="string">&quot;基础信息&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> addsum = <span class="title function_">useCallback</span>(</span><br><span class="line">    <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">setnum</span>(sum + <span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    [sum]</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">/*   function addsum() &#123;</span></span><br><span class="line"><span class="comment">    setnum(sum + 1);</span></span><br><span class="line"><span class="comment">  &#125; */</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">changetext</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">setmessage</span>(<span class="string">&quot;更改之后的信息&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>求和：&#123;sum&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;message&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Student</span> <span class="attr">addsum</span>=<span class="string">&#123;addsum&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;changetext&#125;</span>&gt;</span>更改信息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;addsum&#125;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; memo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">FC</span>, <span class="title class_">ReactNode</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">  children?: <span class="title class_">ReactNode</span>;</span><br><span class="line">  <span class="attr">addsum</span>: <span class="title class_">Function</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Student</span>: <span class="variable constant_">FC</span>&lt;<span class="title class_">Props</span>&gt; = <span class="function">(<span class="params">&#123; addsum &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;子组件被渲染&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          addsum();</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">        加数</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">memo</span>(<span class="title class_">Student</span>);</span><br></pre></td></tr></table></figure><p>如果使用</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addsum</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">setnum</span>(sum + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个没有被 useCallback,处理的函数，则更新 message 时，会重新定义 addsum（） 函数，<br>因为子组件 Student 传入了 addsum 函数，子组件会重新渲染，控制台打印”子组件被渲染” ；</p><p>若使用经过 useCallback 包裹的 addsum 函数，依赖项是 sum ， 则更新 message 时，由于 useCallback 的记忆功能。不会再重新定义 addsum 函数，子组件不会被重新渲染。<br>所以就防止了子组件的无效渲染，提高了性能</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addsum = <span class="title function_">useCallback</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">setnum</span>(sum + <span class="number">1</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  [sum]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>使用 useCallback 和不使用 useCallback 定义一个函数是不会带来性能优化的；<br>使用 useCallback 定义的函数，传递给子组件，防止造成没必要的渲染<br><code>通常使用useCallback 的目的是不希望组组件进行多次渲染，并不是为了函数及进行缓存</code><br>闭包陷阱解决方案：</p><ol><li>正确填写依赖</li><li>使用 useRef，在组建多次渲染时返回的是同一个值</li></ol><h4 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo();"></a>useMemo();</h4><p>先看一个案例</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addsum</span>(<span class="params">n: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;12312&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [counter, setCounter] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">counteradd</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">setCounter</span>(counter + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>1+到5：&#123;addsum(50)&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;counter&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;counteradd&#125;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>当点击按钮时，counter 增加，会造成页面重新渲染，addsum（） 会再次执行，这样就造成了一定的性能开销<br>useMemo 登场：useMemo 有两个参数，第一个参数是一个函数，第二个参数是一个数组，内部填入依赖项，<br>useMemo 和 useCallback 很相似，useMemo 是对函数返回值做记忆，</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useMemo, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addsum</span>(<span class="params">n: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;12312&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [counter, setCounter] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">addsum</span>(<span class="number">50</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">counteradd</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">setCounter</span>(counter + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>1+到5：&#123;result&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;counter&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;counteradd&#125;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>这样写，当 counter 变化时，addsum 不会再次执行，因为，没有发生变化，不再重复执行</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useCallback</span>(fn,[])  等价于  <span class="title function_">useMemo</span>(<span class="function">()=&gt;</span> fn,[]);</span><br></pre></td></tr></table></figure><p>用法：</p><ol><li>对于大量进行计算的操作，是否有必要每次渲染都重新计算；</li><li>对于组件传递相同内容的对象时，使用 useMemo 进行性能优化</li></ol><h4 id="useRef"><a href="#useRef" class="headerlink" title="useRef()"></a>useRef()</h4><p>useRef() 返回一个 ref 对象，返回的 ref 对象在组件的整个生命周期保持不变；<br>最常用的 ref 时两种用法：<br>用法一：引入 DOM 元素；</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dom = useRef&lt;<span class="title class_">HTMLDivElement</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> input = useRef&lt;<span class="title class_">HTMLInputElement</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">showitem</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(dom.<span class="property">current</span>);</span><br><span class="line">    input.<span class="property">current</span>?.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;dom&#125;</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;input&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;showitem&#125;</span>&gt;</span>展示DOM<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>用法二：保存一个数据，这个对象在整个生命周期中可以保持不变，可以用来解决 useCallback 中无依赖状态下，造成的闭包陷阱问题</p><h4 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h4><p>不是很好理解 ,用于子组件向外暴露 ref，使用 useImperativeHandle 可以指定向外暴露的属性和方法</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef, <span class="title class_">ElementRef</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&quot;./components/Student&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> <span class="title class_">ImyComentprops</span> <span class="keyword">from</span> <span class="string">&quot;./components/Student&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> myRef = useRef&lt;<span class="title class_">ElementRef</span>&lt;<span class="keyword">typeof</span> <span class="title class_">ImyComentprops</span>&gt;&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">ref</span>=<span class="string">&#123;myRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> myRef.current?.focus()&#125;&gt;Focus Input<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> myRef.current!.setValue(&quot;我更改值了&quot;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        改值</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; forwardRef, useRef, useImperativeHandle &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="comment">//props接口定义</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyComponentProps</span> &#123;</span><br><span class="line">  label?: <span class="built_in">string</span>;</span><br><span class="line">  onClick?: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义向外暴露的ref接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">ImyComentprops</span> &#123;</span><br><span class="line">  <span class="attr">focus</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">setValue</span>: <span class="function">(<span class="params">str: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponent</span> = forwardRef&lt;<span class="built_in">any</span>, <span class="title class_">MyComponentProps</span>&gt;(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> inputref = useRef&lt;<span class="title class_">HTMLInputElement</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">//向外父组件暴露 展示的ref属性值</span></span><br><span class="line">  <span class="title function_">useImperativeHandle</span>(ref, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">focus</span>(<span class="params"></span>) &#123;</span><br><span class="line">        inputref.<span class="property">current</span>?.<span class="title function_">focus</span>();</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">setValue</span>(<span class="params">str: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        inputref.<span class="property">current</span>!.<span class="property">value</span> = str;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputref&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span>&gt;</span>Focus Input<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyComponent</span>;</span><br></pre></td></tr></table></figure><p>此 Hooks 不常用，感觉主要用封装组件库，不让用户随意动里面的东西</p><h4 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect()"></a>useLayoutEffect()</h4><ul><li>useLayoutEffect（） 会在渲染的内同更新到 DOM 之前执行，<strong>会阻塞 DOM 的更新</strong>；</li><li>useEffect（） 会在渲染的内容更新到 DOM 上之前执行，<strong>不会阻塞 DOM 的更新</strong></li></ul><p>接下来一个例子：判断值是否符合预设值，不合符则更新值；</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect, useLayoutEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [sum, setsum] = <span class="title function_">useState</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="comment">/*  useEffect(() =&gt; &#123; //使用useEffect 去更新值，会出现短暂白屏的效果 </span></span><br><span class="line"><span class="comment">    console.log(&quot;useEffect&quot;);</span></span><br><span class="line"><span class="comment">    if (sum === 0) &#123;</span></span><br><span class="line"><span class="comment">      setsum(Math.random() * 10);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;); */</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">changesum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">setsum</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">useLayoutEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//使用useLayoutEffect（）  因为是在DOM渲染之前更改的值，不会出现</span></span><br><span class="line">    <span class="comment">//白屏现象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;useLayoutEffect&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="title function_">setsum</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>随机数：&#123;sum&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;changesum&#125;</span>&gt;</span>改变数字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>useLayoutEffect（） 官方不建议使用，<br><img src="https://cdn.nlark.com/yuque/0/2023/png/26302696/1689758427564-67dc6d57-a56b-41ef-8e6b-f00dae97a651.png#averageHue=%23fdf7ee&clientId=u5e12156c-1aef-4&from=paste&height=253&id=u12f7b957&originHeight=253&originWidth=937&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18643&status=done&style=none&taskId=ubd2be9c0-1922-4a36-9146-d45b3166660&title=&width=937" alt="image.png"><br>会阻塞 DOM 的更新</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字电子技术——数据选择器</title>
      <link href="/2023/06/11/%E6%95%B0%E6%8D%AE%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2023/06/11/%E6%95%B0%E6%8D%AE%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="数据选择器的地址输入和数据输入怎么理解"><a href="#数据选择器的地址输入和数据输入怎么理解" class="headerlink" title="数据选择器的地址输入和数据输入怎么理解"></a>数据选择器的地址输入和数据输入怎么理解</h3><p>以一个 4-1 数据选择器为例，它有 4 个数据输入线（D0, D1, D2, D3）、2 个选择输入线（S0, S1）和 1 个输出线（Y）。S0 和 S1 是地址输入，它们可以选择其中一个数据输入线作为输出线的数据。<br />例如，当 S0=0, S1=0 时，选择器会选择 D0 作为输出数据，因为 S0 和 S1 的二进制值为 00，对应的是选择器的第 1 个数据输入线 D0，而 D0 的数据输入则是指在 D0 输入线上输入的具体数字。<br />因此，地址输入和数据输入是数据选择器的两个重要的输入，用于选择和输出特定的数据。</p><h3 id="二选一数据选择器"><a href="#二选一数据选择器" class="headerlink" title="二选一数据选择器"></a>二选一数据选择器</h3><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090259.png"><br />案例一，电视频道选择解答<br /><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090331.png"></p><h3 id="四选一数据选择器"><a href="#四选一数据选择器" class="headerlink" title="四选一数据选择器"></a>四选一数据选择器</h3><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090442.png"></p><h4 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h4><table><thead><tr><th>A0 （遥控器输入信号第一位）</th><th>A1（遥控器输入信号第二位）</th><th>Y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>A0 ， A1，</td></tr><tr><td>0</td><td>1</td><td>A0 ， A1</td></tr><tr><td>1</td><td>0</td><td>A0 A1，</td></tr><tr><td>1</td><td>1</td><td>A0 A1</td></tr></tbody></table><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090502.png"></p><h3 id="双四选一数据选择器-74HC153"><a href="#双四选一数据选择器-74HC153" class="headerlink" title="双四选一数据选择器 74HC153"></a>双四选一数据选择器 74HC153</h3><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090531.png"></p><h3 id="数据选择器的逻辑函数"><a href="#数据选择器的逻辑函数" class="headerlink" title="数据选择器的逻辑函数"></a>数据选择器的逻辑函数</h3><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090549.png"></p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090604.png"></p><h3 id="数据选择器设计组合逻辑电路"><a href="#数据选择器设计组合逻辑电路" class="headerlink" title="数据选择器设计组合逻辑电路"></a>数据选择器设计组合逻辑电路</h3><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/yuque_mind.jpeg"></p><h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题 2"></a>例题 2</h4><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090700.png"></p><h4 id="解答：-1"><a href="#解答：-1" class="headerlink" title="解答："></a>解答：</h4><p>看题目时三个变量，<br />数据选择器地址输入端个数是： n-1 = 3-1 = 2;<br />题目给的 74H153 是两个地址输入端，够用<br />然后对逻辑函数式进行化简。<br />与 74H153 的逻辑函数式进行比较，得到器件端口对应的输入<br /><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090713.png"></p><h4 id="例题-3"><a href="#例题-3" class="headerlink" title="例题 3"></a>例题 3</h4><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090729.png"><br /><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090752.png"></p><h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090805.png"><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/20230611090830.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数字电子技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数电 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写一些函数</title>
      <link href="/2023/06/06/%E6%89%8B%E5%86%99%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0/"/>
      <url>/2023/06/06/%E6%89%8B%E5%86%99%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<ol><li><code>二维数组斜向打印</code></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">printMaxit</span>(<span class="params">arr: number[][]</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> row = arr.<span class="property">length</span>; <span class="comment">//行 x</span></span><br><span class="line">    <span class="keyword">let</span> conlum = arr[<span class="number">0</span>].<span class="property">length</span>; <span class="comment">//列 y</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">res</span>: any = [];</span><br><span class="line">    <span class="comment">//左上角  从0开始打印到conlum-1；</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; conlum; k++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = k; i &lt; row &amp;&amp; j &gt;= <span class="number">0</span>; i++, j--) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(arr[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右下角</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">1</span>; k &lt; row; k++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = k, j = row; i &lt; row &amp;&amp; j &gt;= <span class="number">0</span>; i++, j--) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(arr[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> matrix2 = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">    [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line">  ];</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">printMaxit</span>(matrix2));</span><br><span class="line">  <span class="comment">// 输出: [1, 5, 2, 9, 6, 3, 10, 7, 4, 11, 8, 12]</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>给定的代码定义了一个名为<code>printMatrix</code>的函数，它接受一个二维数组(<code>arr</code>)作为输入，并返回一个数组(<code>res</code>)，其中包含按特定模式打印矩阵的元素。</p><h3 id="代码的工作原理如下："><a href="#代码的工作原理如下：" class="headerlink" title="代码的工作原理如下："></a>代码的工作原理如下：</h3><ol><li><p>函数首先初始化变量<code>m</code>和<code>n</code>，用于存储矩阵的行数和列数。</p></li><li><p>然后，创建一个空数组<code>res</code>，用于存储打印出的矩阵元素。</p></li><li><p>接下来，通过两个嵌套的循环来按特定模式打印矩阵的元素。</p><ul><li><p>第一个循环从左上角开始，从 0 到 n-1 列进行迭代。其中，变量<code>k</code>表示当前列数。</p><ul><li><p>内部循环使用变量<code>i</code>和<code>j</code>分别表示当前元素的行和列。</p></li><li><p>循环条件是<code>i</code>小于行数<code>m</code>且<code>j</code>大于等于 0。</p></li><li><p>在每次迭代中，将<code>arr[i][j]</code>添加到结果数组<code>res</code>中，并将<code>i</code>递增，<code>j</code>递减。</p></li></ul></li><li><p>第二个循环从右下角开始，从 1 到 m-1 行进行迭代。其中，变量<code>k</code>表示当前行数。</p><ul><li><p>内部循环使用变量<code>i</code>和<code>j</code>分别表示当前元素的行和列。</p></li><li><p>循环条件是<code>i</code>小于行数<code>m</code>且<code>j</code>大于等于 0。</p></li><li><p>在每次迭代中，将<code>arr[i][j]</code>添加到结果数组<code>res</code>中，并将<code>i</code>递增，<code>j</code>递减。</p></li></ul></li></ul></li><li><p>循环结束后，将结果数组<code>res</code>返回作为函数的输出。</p></li></ol><p>总体而言，该函数按照一种特定的模式遍历二维数组，并将遍历到的元素按顺序存储在一个新的数组中。</p><p>2.解析 URL 的 params 参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> url =</span><br><span class="line">    <span class="string">&quot;http://www.baidu.com?user=anoymous&amp;id=12&amp;&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&quot;</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">ParseParams</span>(<span class="params">url: string</span>): <span class="title class_">Record</span>&lt;string, any&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> paramsstr = url.<span class="title function_">split</span>(<span class="string">&quot;?&quot;</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> paramsArr = paramsstr.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">paramsobj</span>: <span class="title class_">Record</span>&lt;string, any&gt; = &#123;&#125;;</span><br><span class="line">    paramsArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/=/</span>.<span class="title function_">test</span>(item)) &#123;</span><br><span class="line">        <span class="comment">//处理有值的参数</span></span><br><span class="line">        <span class="keyword">let</span> [key, val]: [string, any] = item.<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>) <span class="keyword">as</span> [string, any]; <span class="comment">//分割key和value;</span></span><br><span class="line">        val = <span class="built_in">decodeURIComponent</span>(val); <span class="comment">//中文解码;</span></span><br><span class="line">        val = <span class="regexp">/^\d+$/</span>.<span class="title function_">test</span>(val) ? <span class="built_in">parseInt</span>(val) : val; <span class="comment">//是否需要转化成数字</span></span><br><span class="line">        <span class="keyword">if</span> (paramsobj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">          <span class="comment">//看看是否有这个，如果已经有了，则创建一个数组，添加进去</span></span><br><span class="line">          paramsobj[key] = [].<span class="title function_">concat</span>(paramsobj[key], val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          paramsobj[key] = val;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        paramsobj[item] = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> paramsobj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ParseParams</span>(url));</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码是一个 JavaScript IIFE(Immediately Invoked Function Expression)，它包含一个函数 <code>ParseParams</code> 和一个立即执行该函数的语句。</p><p><code>ParseParams</code> 函数用于解析给定 URL 的查询参数，并将其转换为一个对象 <code>paramsobj</code>，其中查询参数的名称作为对象的键名，查询参数的值作为对象的键值。函数的实现过程如下：</p><ol><li>从 URL 中获取查询参数字符串 <code>paramsstr</code>，通过 <code>split</code> 方法将 URL 字符串以 <code>?</code> 分割，取得索引为 1 的字符串作为查询参数字符串。</li><li>将查询参数字符串 <code>paramsstr</code> 以 <code>&amp;</code> 符号分割成数组 <code>paramsArr</code>，使用 <code>forEach</code> 方法遍历数组中的每个查询参数。</li><li>对于每个查询参数，首先判断其是否包含 <code>=</code> 符号，如果包含则表示该查询参数有值，将其分割成 <code>key</code> 和 <code>value</code> 两部分，并对 <code>value</code> 进行解码和类型转换，然后将其存储到 <code>paramsobj</code> 对象中。</li><li>如果某个查询参数的 <code>key</code> 已经在 <code>paramsobj</code> 对象中存在，那么将其值转换为数组，并将新的值添加到数组中，否则直接将新的值赋值给 <code>paramsobj</code> 对象的 <code>key</code> 属性。</li><li>如果某个查询参数不包含 <code>=</code> 符号，那么表示该查询参数没有值，直接将其存储到 <code>paramsobj</code> 对象中，并将其值设置为 <code>true</code>。</li><li>最后，将解析后的 <code>paramsobj</code> 对象作为函数返回值。</li></ol><p>在这个例子中，通过传递一个 URL 字符串 <code>url</code> 给 <code>ParseParams</code> 函数，可以获取该 URL 的查询参数，并将其转换为一个对象。函数的执行结果会被输出到控制台中，因为在这个例子中，函数是立即执行的，并且输出结果是通过 <code>console.log</code> 方法输出到控制台的。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>electron入门</title>
      <link href="/2023/05/21/electron/"/>
      <url>/2023/05/21/electron/</url>
      
        <content type="html"><![CDATA[<p>#1. 简介</p><ul><li><a href="https://www.electronjs.org/">官网</a></li><li>Electron 是由 GitHub 众多开发者开发的一个开源项目，能够使用 JavaScript，HTML 和 CSS 构建跨平台的桌面应用程序</li></ul><h1 id="2-五分钟快速上手"><a href="#2-五分钟快速上手" class="headerlink" title="2. 五分钟快速上手"></a>2. 五分钟快速上手</h1><h2 id="2-1-安装-electron"><a href="#2-1-安装-electron" class="headerlink" title="2.1 安装 electron"></a>2.1 安装 electron</h2><p>初始化 package.json 文件</p><ul><li>npm init</li></ul><p>安装 electron</p><ul><li>cnpm I electron –S</li></ul><h2 id="2-2-配置为入口文件"><a href="#2-2-配置为入口文件" class="headerlink" title="2.2 配置为入口文件"></a>2.2 配置为入口文件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;electron-demo&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;main.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;electron .&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;electron&quot;</span>: <span class="string">&quot;^8.3.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-创建-main-js-文件"><a href="#2-3-创建-main-js-文件" class="headerlink" title="2.3 创建 main.js 文件"></a>2.3 创建 main.js 文件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> electron = <span class="built_in">require</span>(<span class="string">&quot;electron&quot;</span>);</span><br><span class="line"><span class="comment">// 控制应用程序的事件生命周期。</span></span><br><span class="line"><span class="keyword">const</span> app = electron.<span class="property">app</span>;</span><br><span class="line"><span class="comment">// 当 Electron 完成初始化时，触发一次</span></span><br><span class="line">app.<span class="title function_">on</span>(<span class="string">&quot;ready&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> electron.<span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">800</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">300</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-4-创建窗口"><a href="#2-4-创建窗口" class="headerlink" title="2.4 创建窗口"></a>2.4 创建窗口</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">on</span>(<span class="string">&quot;ready&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> mainWindow = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">800</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">500</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  mainWindow.<span class="title function_">loadFile</span>(<span class="string">&quot;./index.html&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="3-自动刷新页面"><a href="#3-自动刷新页面" class="headerlink" title="3. 自动刷新页面"></a>3. 自动刷新页面</h1><ul><li><p>安装插件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cnpm install --save-dev electron-reloader</span><br></pre></td></tr></table></figure></li><li><p>在入口引入插件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reloader = <span class="built_in">require</span>(<span class="string">&quot;electron-reloader&quot;</span>);</span><br><span class="line"><span class="title function_">reloader</span>(<span class="variable language_">module</span>);</span><br></pre></td></tr></table></figure></li></ul><h1 id="4-主进程和渲染进程"><a href="#4-主进程和渲染进程" class="headerlink" title="4. 主进程和渲染进程"></a>4. 主进程和渲染进程</h1><p>Electron 运行 <code>package.json</code> 的 <code>main</code> 脚本的进程被称为<strong>主进程</strong>。 在主进程中运行的脚本通过创建 web 页面来展示用户界面。 一个 Electron 应用总是有且只有一个主进程。</p><p>由于 Electron 使用了 Chromium 来展示 web 页面，所以 Chromium 的多进程架构也被使用到。 每个 Electron 中的 web 页面运行在它的叫<strong>渲染进程</strong>的进程中。</p><p>在普通的浏览器中，web 页面无法访问操作系统的原生资源。 然而 Electron 的用户在 Node.js 的 API 支持下可以在页面中和操作系统进行一些底层交互。</p><p>ctrl+shift+i 打开渲染进程调试</p><p>默认打开调试</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">on</span>(<span class="string">&quot;ready&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> mainWindow = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">800</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">500</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  mainWindow.<span class="title function_">loadFile</span>(<span class="string">&quot;./index.html&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> mainWindow2 = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">800</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">500</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  mainWindow.<span class="property">webContents</span>.<span class="title function_">openDevTools</span>();</span><br><span class="line"></span><br><span class="line">  mainWindow2.<span class="title function_">loadFile</span>(<span class="string">&quot;./index2.html&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="5-自定义原生菜单"><a href="#5-自定义原生菜单" class="headerlink" title="5. 自定义原生菜单"></a>5. 自定义原生菜单</h1><h2 id="5-1-自定义菜单"><a href="#5-1-自定义菜单" class="headerlink" title="5.1 自定义菜单"></a>5.1 自定义菜单</h2><p>详细文档：<a href="https://www.electronjs.org/docs/api/menu">https://www.electronjs.org/docs/api/menu</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> electron = <span class="built_in">require</span>(<span class="string">&quot;electron&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; app, <span class="title class_">Menu</span> &#125; = electron;</span><br><span class="line"><span class="keyword">const</span> template = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">label</span>: <span class="string">&quot;文件&quot;</span>,</span><br><span class="line">    <span class="attr">submenu</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">label</span>: <span class="string">&quot;新建窗口&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">label</span>: <span class="string">&quot;编辑&quot;</span>,</span><br><span class="line">    <span class="attr">submenu</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">label</span>: <span class="string">&quot;新建窗口&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> menu = <span class="title class_">Menu</span>.<span class="title function_">buildFromTemplate</span>(template);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Menu</span>.<span class="title function_">setApplicationMenu</span>(menu);</span><br></pre></td></tr></table></figure><h2 id="5-2-给菜单定义点击事件"><a href="#5-2-给菜单定义点击事件" class="headerlink" title="5.2 给菜单定义点击事件"></a>5.2 给菜单定义点击事件</h2><p>1、点击打开新窗口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">submenu</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">label</span>: <span class="string">&quot;新建窗口&quot;</span>,</span><br><span class="line">    <span class="attr">click</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newMainWindow = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">        <span class="attr">width</span>: <span class="number">300</span>,</span><br><span class="line">        <span class="attr">height</span>: <span class="number">300</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      newMainWindow.<span class="title function_">loadFile</span>(<span class="string">&quot;./new.html&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>2、点击打开浏览器</p><p><code>shell</code> 模块提供了集成其他桌面客户端的关联功能.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">BrowserWindow</span>, <span class="title class_">Menu</span>, shell &#125; = <span class="built_in">require</span>(<span class="string">&quot;electron&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> template = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">label</span>: <span class="string">&quot;文件&quot;</span>,</span><br><span class="line">    <span class="attr">submenu</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">label</span>: <span class="string">&quot;文件1&quot;</span>,</span><br><span class="line">        <span class="title function_">click</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="comment">// 点击打开新窗口</span></span><br><span class="line">          <span class="keyword">const</span> mainWindow2 = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">            <span class="attr">width</span>: <span class="number">600</span>,</span><br><span class="line">            <span class="attr">height</span>: <span class="number">600</span>,</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          mainWindow2.<span class="title function_">loadFile</span>(<span class="string">&quot;./index.html&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">label</span>: <span class="string">&quot;csdn&quot;</span>,</span><br><span class="line">    <span class="title function_">click</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 点击打开浏览器</span></span><br><span class="line">      shell.<span class="title function_">openExternal</span>(<span class="string">&quot;https://www.csdn.net/&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="5-3-抽离菜单定义"><a href="#5-3-抽离菜单定义" class="headerlink" title="5.3 抽离菜单定义"></a>5.3 抽离菜单定义</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">BrowserWindow</span>, <span class="title class_">Menu</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;electron&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> template = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">label</span>: <span class="string">&quot;文件&quot;</span>,</span><br><span class="line">    <span class="attr">submenu</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">label</span>: <span class="string">&quot;新建窗口&quot;</span>,</span><br><span class="line">        <span class="attr">click</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> newMainWindow = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">            <span class="attr">width</span>: <span class="number">300</span>,</span><br><span class="line">            <span class="attr">height</span>: <span class="number">300</span>,</span><br><span class="line">          &#125;);</span><br><span class="line">          newMainWindow.<span class="title function_">loadFile</span>(<span class="string">&quot;./new.html&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">label</span>: <span class="string">&quot;编辑&quot;</span>,</span><br><span class="line">    <span class="attr">submenu</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">label</span>: <span class="string">&quot;新建窗口&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> menu = <span class="title class_">Menu</span>.<span class="title function_">buildFromTemplate</span>(template);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Menu</span>.<span class="title function_">setApplicationMenu</span>(menu);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;./menu&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="打开调式"><a href="#打开调式" class="headerlink" title="打开调式"></a>打开调式</h4><p>mainWindow.webContents.openDevTools()</p><h2 id="5-4-自定义顶部菜单"><a href="#5-4-自定义顶部菜单" class="headerlink" title="5.4 自定义顶部菜单"></a>5.4 自定义顶部菜单</h2><ul><li><p>通过 frame 创建无边框窗口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mainWindow = <span class="keyword">new</span> electron.<span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">  <span class="attr">frame</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>自定义窗口</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;custom-menu&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>新建窗口<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>关于我们<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.custom-menu</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-menu</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-menu</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加-webkit-app-region: drag;实现拖拽</p></li></ul><h2 id="5-5-点击创建新窗口"><a href="#5-5-点击创建新窗口" class="headerlink" title="5.5 点击创建新窗口"></a>5.5 点击创建新窗口</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// html</span></span><br><span class="line">&lt;li <span class="keyword">class</span>=<span class="string">&quot;new-window&quot;</span>&gt;新建窗口&lt;/li&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="comment">// remote 通过remote使用主进程的方法</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="attr">remote</span>: &#123; <span class="title class_">BrowserWindow</span> &#125;,</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">&quot;electron&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> newWindow = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.new-window&quot;</span>);</span><br><span class="line">newWindow.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">300</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>能够在 html 中使用 node 方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mainWindow = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">  <span class="attr">width</span>: <span class="number">800</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">500</span>,</span><br><span class="line">  <span class="attr">webPreferences</span>: &#123;</span><br><span class="line">    <span class="comment">// 开启node模块</span></span><br><span class="line">    <span class="attr">nodeIntegration</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 开启remote模块</span></span><br><span class="line">    <span class="attr">enableRemoteModule</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="5-6-点页面打开浏览器"><a href="#5-6-点页面打开浏览器" class="headerlink" title="5.6 点页面打开浏览器"></a>5.6 点页面打开浏览器</h2><ul><li><p>html</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;a1&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://www.itheima.com&quot;</span>&gt;</span>打开浏览器<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; shell &#125; = <span class="built_in">require</span>(<span class="string">&quot;electron&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> allA = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">allA.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  item.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">    shell.<span class="title function_">openExternal</span>(item.<span class="property">href</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h1 id="6-打开对话框读取文件"><a href="#6-打开对话框读取文件" class="headerlink" title="6. 打开对话框读取文件"></a>6. 打开对话框读取文件</h1><h2 id="6-1-读取文件"><a href="#6-1-读取文件" class="headerlink" title="6.1 读取文件"></a>6.1 读取文件</h2><ul><li><p>定义点击事件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;openFile()&quot;</span>&gt;打开&lt;/button&gt;</span><br></pre></td></tr></table></figure></li><li><p>定义事件函数</p><p>打开对话框文档：<a href="https://www.electronjs.org/docs/api/dialog">https://www.electronjs.org/docs/api/dialog</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开对话框</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">openFile</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = dialog.<span class="title function_">showOpenDialogSync</span>(&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;选择文件&quot;</span>,</span><br><span class="line">    <span class="attr">buttonLabel</span>: <span class="string">&quot;哈哈&quot;</span>,</span><br><span class="line">    <span class="attr">filters</span>: [&#123; <span class="attr">name</span>: <span class="string">&quot;Custom File Type&quot;</span>, <span class="attr">extensions</span>: [<span class="string">&quot;js&quot;</span>] &#125;],</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fileContent = fs.<span class="title function_">readFileSync</span>(res[<span class="number">0</span>]);</span><br><span class="line">  dropEl.<span class="property">innerText</span> = fileContent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-2-保存文件"><a href="#6-2-保存文件" class="headerlink" title="6.2 保存文件"></a>6.2 保存文件</h2><ul><li><p>定义点击事件</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;saveFile()&quot;</span>&gt;</span>保存<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>事件函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存对话框</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">saveFile</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = remote.<span class="property">dialog</span>.<span class="title function_">showSaveDialogSync</span>(&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;保存文件&quot;</span>,</span><br><span class="line">    <span class="attr">buttonLabel</span>: <span class="string">&quot;保存文件&quot;</span>,</span><br><span class="line">    <span class="attr">filters</span>: [&#123; <span class="attr">name</span>: <span class="string">&quot;index&quot;</span>, <span class="attr">extensions</span>: [<span class="string">&quot;js&quot;</span>] &#125;],</span><br><span class="line">  &#125;);</span><br><span class="line">  fs.<span class="title function_">writeFileSync</span>(res, dropEl.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="7-定义快捷键"><a href="#7-定义快捷键" class="headerlink" title="7. 定义快捷键"></a>7. 定义快捷键</h1><h2 id="7-1-主线程定义"><a href="#7-1-主线程定义" class="headerlink" title="7.1 主线程定义"></a>7.1 主线程定义</h2><ul><li><p>引入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; app, <span class="title class_">BrowserWindow</span>, globalShortcut &#125; = <span class="built_in">require</span>(<span class="string">&quot;electron&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>在 ready 中注册快捷键</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ret = globalShortcut.<span class="title function_">register</span>(<span class="string">&quot;CommandOrControl+X&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;CommandOrControl+X is pressed + 打印结果在命令行&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>定义快捷键最大、最小、关闭窗口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">globalShortcut.<span class="title function_">register</span>(<span class="string">&quot;CommandOrControl+T&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  mainWindow.<span class="title function_">unmaximize</span>();</span><br><span class="line">&#125;);</span><br><span class="line">globalShortcut.<span class="title function_">register</span>(<span class="string">&quot;CommandOrControl+H&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  mainWindow.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br><span class="line">globalShortcut.<span class="title function_">register</span>(<span class="string">&quot;CommandOrControl+M&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  mainWindow.<span class="title function_">maximize</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-2-渲染进程定义"><a href="#7-2-渲染进程定义" class="headerlink" title="7.2 渲染进程定义"></a>7.2 渲染进程定义</h2><ul><li><p>通过 remote 注册</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义快捷键</span></span><br><span class="line">remote.<span class="property">globalShortcut</span>.<span class="title function_">register</span>(<span class="string">&quot;Ctrl+O&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ctrl+o&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h1 id="8-渲染进程和主线程通讯"><a href="#8-渲染进程和主线程通讯" class="headerlink" title="8. 渲染进程和主线程通讯"></a>8. 渲染进程和主线程通讯</h1><ul><li><p>定义按钮</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;maxWindow no-drag&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;maxWindow()&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>事件函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxWindow</span>(<span class="params"></span>) &#123;</span><br><span class="line">  ipcRenderer.<span class="title function_">send</span>(<span class="string">&quot;max-window&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主线程定义事件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ipcMain.<span class="title function_">on</span>(<span class="string">&quot;max-window&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  mainWindow.<span class="title function_">maximize</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>传参</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> windowSize = <span class="string">&quot;unmax-window&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">maxWindow</span>(<span class="params"></span>) &#123;</span><br><span class="line">  windowSize = windowSize === <span class="string">&quot;max-window&quot;</span> ? <span class="string">&quot;unmax-window&quot;</span> : <span class="string">&quot;max-window&quot;</span>;</span><br><span class="line">  ipcRenderer.<span class="title function_">send</span>(<span class="string">&quot;max-window&quot;</span>, windowSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接收参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ipcMain.<span class="title function_">on</span>(<span class="string">&quot;max-window&quot;</span>, <span class="function">(<span class="params">event, arg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg);</span><br><span class="line">  <span class="keyword">if</span> (arg === <span class="string">&quot;unmax-window&quot;</span>) <span class="keyword">return</span> mainWindow.<span class="title function_">maximize</span>();</span><br><span class="line">  mainWindow.<span class="title function_">unmaximize</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h1 id="09-electron-打包"><a href="#09-electron-打包" class="headerlink" title="09. electron 打包"></a>09. electron 打包</h1><ul><li><p>安装 electron-packager</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cnpm i electron-packager -D</span><br></pre></td></tr></table></figure></li><li><p>添加打包任务</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;build&quot;</span>: <span class="string">&quot;electron-packager ./ HelloWorld --platform=win32 --arch=x64 --out ./outApp --overwrite --icon=./favicon.ico&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="10-electron-结合框架开发"><a href="#10-electron-结合框架开发" class="headerlink" title="10 .electron 结合框架开发"></a>10 .electron 结合框架开发</h1><ul><li><p>利用 vue 脚手架初始化项目</p></li><li><p>在项目中安装 electron</p><p>cnpm i electron</p></li><li><p>添加 electron 启动配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;main&quot;</span>: <span class="string">&quot;main.js&quot;</span>,</span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">   <span class="string">&quot;start&quot;</span>: <span class="string">&quot;react-scripts start&quot;</span>,</span><br><span class="line">   <span class="string">&quot;build&quot;</span>: <span class="string">&quot;react-scripts build&quot;</span>,</span><br><span class="line">   <span class="string">&quot;test&quot;</span>: <span class="string">&quot;react-scripts test&quot;</span>,</span><br><span class="line">   <span class="string">&quot;eject&quot;</span>: <span class="string">&quot;react-scripts eject&quot;</span>,</span><br><span class="line">   <span class="string">&quot;electron&quot;</span>: <span class="string">&quot;electron .&quot;</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li><li><p>配置 main.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; app, <span class="title class_">BrowserWindow</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;electron&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createWindow</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Create the browser window.</span></span><br><span class="line">  <span class="keyword">const</span> mainWindow = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">800</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">600</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// Open the DevTools.</span></span><br><span class="line">  <span class="comment">// mainWindow.webContents.openDevTools()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">on</span>(<span class="string">&quot;ready&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">createWindow</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>加载 vue 项目</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mainWindow.<span class="title function_">loadURL</span>(<span class="string">&quot;http://localhost:3000/&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React生命周期</title>
      <link href="/2023/05/14/%E6%96%B0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2023/05/14/%E6%96%B0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="生命周期（新）♥"><a href="#生命周期（新）♥" class="headerlink" title="生命周期（新）♥"></a>生命周期（新）♥</h3><p>新版本可以使用旧的生命周期钩子</p><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F(%E6%96%B0).png" alt="react生命周期(新)"></p><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F(%E6%97%A7).png"></p><p>新的生命周期钩子中，有三个钩子出现了警告，</p><ul><li><p>componentWillMount</p></li><li><p>componentWillUpdate</p></li><li><p>componentWillReceiveProps</p><p>需要在前方加上 UNSAFE_ React 官方说将在未来会上线异步渲染，这些钩子可能会出现问题</p></li></ul><p>新的钩子：</p><ul><li><p>getDerivedStateFromPorps</p></li><li><p>getSnapshotBeforeUpdate</p><h3 id="getDerivedStateFromPorps"><a href="#getDerivedStateFromPorps" class="headerlink" title="getDerivedStateFromPorps()"></a>getDerivedStateFromPorps()</h3><blockquote><p>派生状态</p></blockquote><p>需要加上 static，变为静态方法，这个钩子用途很罕见，这个钩子的原则就是，state 的值在任何时候都取决于 props。</p><h3 id="getSnapshotBeforeUpdate（）"><a href="#getSnapshotBeforeUpdate（）" class="headerlink" title="getSnapshotBeforeUpdate（）"></a>getSnapshotBeforeUpdate（）</h3><p>这个钩子 是 更新 DOM 之前，渲染之后，</p><ul><li>此钩子的返回值将作为参数，传递给 componentDidUpdate（）；</li><li>此方法不常用，滚动条固定可以使用这个，</li></ul></li></ul><h3 id="新生命周期"><a href="#新生命周期" class="headerlink" title="新生命周期"></a>新生命周期</h3><ul><li>挂载过程</li></ul><ol><li>constructor</li><li>getSnapshotBeforeUpdate()</li><li><strong>render</strong></li><li><strong>componentDidmount() //发请求，订阅消息，定时器开启</strong></li></ol><ul><li><p>更新过程 由 setState 触发，或者父组件传入 Props 触发</p><ol><li>getSnapshotBeforeUpdate()</li><li>shouldComponentUpdate()</li><li><strong>render</strong></li><li>getSnapshotBeforeUpdate()</li><li>componentDidUpdate()</li></ol></li><li><p>卸载过程</p><ol><li><strong>componentWillUnmount()</strong></li></ol></li></ul><p>即将废弃的钩子</p><ul><li><p>componentWillUpdate();</p></li><li><p>componentWillMount();</p></li><li><p>componentReviceProps();</p><p>必须加上 UNSAFE 才能使用，未来可能废弃了，这三个钩子也不常用</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ts配置文件and泛型</title>
      <link href="/2023/05/06/TS%E5%85%A5%E9%97%A8/"/>
      <url>/2023/05/06/TS%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="tsconfig-json配置"><a href="#tsconfig-json配置" class="headerlink" title="tsconfig.json配置"></a>tsconfig.json配置</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="comment">/* 编译路径</span></span><br><span class="line"><span class="comment">    **表示文件夹下的所有文件夹，</span></span><br><span class="line"><span class="comment">    *表示文件夹下的所有文件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;./src/**/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">/* 排除路径 不参加编译的文件路径</span></span><br><span class="line"><span class="comment">    默认值[”node_modules“,&quot;bower_components&quot;,&quot;jspm_packages&quot;]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="attr">&quot;exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;./hellow/**/*&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="compilerOptions配置选项"><a href="#compilerOptions配置选项" class="headerlink" title="compilerOptions配置选项"></a>compilerOptions配置选项</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">compilerOptions编译器选项</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="comment">//target 用来指定TS被编译的ES的版本</span></span><br><span class="line"><span class="comment">//&#x27;es3&#x27;, &#x27;es5&#x27;, &#x27;es6&#x27;, &#x27;es2015&#x27;, &#x27;es2016&#x27;, &#x27;es2017&#x27;, &#x27;es2018&#x27;, &#x27;es2019&#x27;, &#x27;es2020&#x27;, &#x27;es2021&#x27;, &#x27;es2022&#x27;, &#x27;esnext&#x27;.</span></span><br><span class="line"><span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ES2015&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">//module </span></span><br><span class="line"><span class="comment">//&#x27;none&#x27;, &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27;, &#x27;es6&#x27;, &#x27;es2015&#x27;, &#x27;es2020&#x27;, &#x27;es2022&#x27;, &#x27;esnext&#x27;, &#x27;node16&#x27;, &#x27;nodenext&#x27;.</span></span><br><span class="line"><span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ES2015&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">//lib用来指定使用的库</span></span><br><span class="line"><span class="comment">//option must be: </span></span><br><span class="line"><span class="comment">//&#x27;es5&#x27;, &#x27;es6&#x27;, &#x27;es2015&#x27;, &#x27;es7&#x27;, &#x27;es2016&#x27;, &#x27;es2017&#x27;, &#x27;es2018&#x27;, &#x27;es2019&#x27;, </span></span><br><span class="line"><span class="comment">//&#x27;es2020&#x27;, &#x27;es2021&#x27;, &#x27;es2022&#x27;, &#x27;es2023&#x27;, &#x27;esnext&#x27;, &#x27;dom&#x27;, &#x27;dom.iterable&#x27;, </span></span><br><span class="line"><span class="comment">//&#x27;webworker&#x27;, &#x27;webworker.importscripts&#x27;, &#x27;webworker.iterable&#x27;, &#x27;scripthost&#x27;, </span></span><br><span class="line"><span class="comment">//&#x27;es2015.core&#x27;, &#x27;es2015.collection&#x27;, &#x27;es2015.generator&#x27;, &#x27;es2015.iterable&#x27;, </span></span><br><span class="line"><span class="comment">//&#x27;es2015.promise&#x27;, &#x27;es2015.proxy&#x27;, &#x27;es2015.reflect&#x27;, &#x27;es2015.symbol&#x27;, </span></span><br><span class="line"><span class="comment">//&#x27;es2015.symbol.wellknown&#x27;, &#x27;es2016.array.include&#x27;, &#x27;es2017.object&#x27;, </span></span><br><span class="line"><span class="comment">//&#x27;es2017.sharedmemory&#x27;, &#x27;es2017.string&#x27;, &#x27;es2017.intl&#x27;, &#x27;es2017.typedarrays&#x27;,</span></span><br><span class="line"><span class="comment">// &#x27;es2018.asyncgenerator&#x27;, &#x27;es2018.asynciterable&#x27;, &#x27;es2018.intl&#x27;, &#x27;es2018.promise&#x27;, &#x27;es2018.regexp&#x27;, &#x27;es2019.array&#x27;, &#x27;es2019.object&#x27;, &#x27;es2019.string&#x27;, &#x27;es2019.symbol&#x27;, &#x27;es2019.intl&#x27;, &#x27;es2020.bigint&#x27;, &#x27;es2020.date&#x27;, &#x27;es2020.promise&#x27;, &#x27;es2020.sharedmemory&#x27;, &#x27;es2020.string&#x27;, &#x27;es2020.symbol.wellknown&#x27;, &#x27;es2020.intl&#x27;, &#x27;es2020.number&#x27;, &#x27;es2021.promise&#x27;, &#x27;es2021.string&#x27;, &#x27;es2021.weakref&#x27;, &#x27;es2021.intl&#x27;, &#x27;es2022.array&#x27;, &#x27;es2022.error&#x27;, &#x27;es2022.intl&#x27;, </span></span><br><span class="line"><span class="comment">//&#x27;es2022.object&#x27;, &#x27;es2022.sharedmemory&#x27;, &#x27;es2022.string&#x27;, &#x27;es2022.regexp&#x27;,</span></span><br><span class="line"><span class="comment">// &#x27;es2023.array&#x27;, &#x27;esnext.array&#x27;, &#x27;esnext.symbol&#x27;, &#x27;esnext.asynciterable&#x27;,</span></span><br><span class="line"><span class="comment">// &#x27;esnext.intl&#x27;, &#x27;esnext.bigint&#x27;, &#x27;esnext.string&#x27;, &#x27;esnext.promise&#x27;, &#x27;esnext.weakref&#x27;,</span></span><br><span class="line"><span class="comment">// &#x27;decorators&#x27;, &#x27;decorators.legacy&#x27;.</span></span><br><span class="line"><span class="comment">/* &quot;lib&quot;: [&quot;12&quot;] */</span></span><br><span class="line"><span class="comment">//outDir 用来指定编译后文件所在目录</span></span><br><span class="line"><span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">//outFile 将代码合并为一个文件</span></span><br><span class="line"><span class="comment">//设置outfile后，所有的全局代码合并到一个文件中</span></span><br><span class="line"><span class="comment">//但是只支持system,amd </span></span><br><span class="line"><span class="comment">/* &quot;outFile&quot;: &quot;./dist/app.js&quot; */</span></span><br><span class="line"><span class="comment">//allowJs 是否对JS文件进行编译</span></span><br><span class="line"><span class="attr">&quot;allowJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">//checkJs  是否检查JS代码符合语法规范</span></span><br><span class="line"><span class="attr">&quot;checkJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">//removeComments 是否移除注释</span></span><br><span class="line"><span class="attr">&quot;removeComments&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 不生成编译后产生的JS文件</span></span><br><span class="line"><span class="attr">&quot;noEmit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">//noEmitOnError 当有错误时不生成编译后文件</span></span><br><span class="line"><span class="attr">&quot;noEmitOnError&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">//alwaysStrict 用来设置编译后的文件是否使用严格模式</span></span><br><span class="line"><span class="attr">&quot;alwaysStrict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">//noImplicitAny 不允许隐式的any类型</span></span><br><span class="line"><span class="attr">&quot;noImplicitAny&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">//noImplicitThis 不允许指向不明的this</span></span><br><span class="line"><span class="attr">&quot;noImplicitThis&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// strictNullChecks严格检查空值</span></span><br><span class="line"><span class="attr">&quot;strictNullChecks&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">//strict 严格检查的总开关</span></span><br><span class="line"><span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="泛型（Generic）"><a href="#泛型（Generic）" class="headerlink" title="泛型（Generic）"></a>泛型（Generic）</h2><p>定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定）；</p><p>此时泛型便能够发挥作用；</p><p>举个例子：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="built_in">any</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的；</p><p>由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的：</p><p>首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型；</p><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><h4 id="创建泛型函数"><a href="#创建泛型函数" class="headerlink" title="创建泛型函数"></a>创建泛型函数</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> test&lt;T&gt;(<span class="attr">arg</span>: T): T&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>&lt;T&gt;</code>就是泛型；</p><p>T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型；</p><p>所以泛型其实很好理解，就表示某个类型；</p><p>那么如何使用上边的函数呢？</p><h4 id="使用泛型函数"><a href="#使用泛型函数" class="headerlink" title="使用泛型函数"></a>使用泛型函数</h4><h5 id="方式一（直接使用）："><a href="#方式一（直接使用）：" class="headerlink" title="方式一（直接使用）："></a>方式一（直接使用）：</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">test</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式</p><h5 id="方式二（指定类型）："><a href="#方式二（指定类型）：" class="headerlink" title="方式二（指定类型）："></a>方式二（指定类型）：</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">test&lt;<span class="built_in">number</span>&gt;(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>也可以在函数后手动指定泛型；</p><h4 id="函数中声明多个泛型"><a href="#函数中声明多个泛型" class="headerlink" title="函数中声明多个泛型"></a>函数中声明多个泛型</h4><p>可以同时指定多个泛型，泛型间使用逗号隔开：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> test&lt;T, K&gt;(<span class="attr">a</span>: T, <span class="attr">b</span>: K): K&#123;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test&lt;<span class="built_in">number</span>, <span class="built_in">string</span>&gt;(<span class="number">10</span>, <span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用泛型时，完全可以将泛型当成是一个普通的类去使用；</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>类中同样可以使用泛型：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T&gt;&#123;</span><br><span class="line">  <span class="attr">prop</span>: T;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">prop: T</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">prop</span> = prop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h3><p>除此之外，也可以对泛型的范围进行约束</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInter</span>&#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> test&lt;T <span class="keyword">extends</span> <span class="title class_">MyInter</span>&gt;(<span class="attr">arg</span>: T): <span class="built_in">number</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用；</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 TS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React脚手架配置代理</title>
      <link href="/2023/04/23/React%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
      <url>/2023/04/23/React%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="react脚手架配置代理总结"><a href="#react脚手架配置代理总结" class="headerlink" title="react脚手架配置代理总结"></a>react脚手架配置代理总结</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><blockquote><p>在package.json中追加如下配置</p></blockquote><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;proxy&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://localhost:5000&quot;</span></span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>优点：配置简单，前端请求资源时可以不加任何前缀。</li><li>缺点：不能配置多个代理。</li><li>工作方式：上述方式配置代理，当请求了3000不存在的资源时，那么该请求会转发给5000 （优先匹配前端资源）</li></ol><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><ol><li><p>第一步：创建代理配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在src下创建配置文件：src/setupProxy.js</span><br></pre></td></tr></table></figure></li><li><p>编写setupProxy.js配置具体代理规则：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">app</span>) &#123;</span><br><span class="line">  app.<span class="title function_">use</span>(</span><br><span class="line">    <span class="title function_">proxy</span>(<span class="string">&#x27;/api1&#x27;</span>, &#123;  <span class="comment">//api1是需要转发的请求(所有带有/api1前缀的请求都会转发给5000)</span></span><br><span class="line">      <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>, <span class="comment">//配置转发目标地址(能返回数据的服务器地址)</span></span><br><span class="line">      <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">//控制服务器接收到的请求头中host字段的值</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class="line"><span class="comment">      changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:3000</span></span><br><span class="line"><span class="comment">      changeOrigin默认值为false，但我们一般将changeOrigin值设为true</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api1&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125; <span class="comment">//去除请求前缀，保证交给后台服务器的是正常请求地址(必须配置)</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="title function_">proxy</span>(<span class="string">&#x27;/api2&#x27;</span>, &#123; </span><br><span class="line">      <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5001&#x27;</span>,</span><br><span class="line">      <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api2&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>说明：</p><ol><li>优点：可以配置多个代理，可以灵活的控制请求是否走代理。</li><li>缺点：配置繁琐，前端请求资源时必须加前缀。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随时切换node版本不是梦</title>
      <link href="/2023/04/13/nvm%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/04/13/nvm%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="nvm介绍"><a href="#nvm介绍" class="headerlink" title="nvm介绍"></a>nvm介绍</h3><p>在工作中，我们可能同时在进行2个或者多个不同的项目开发，每个项目的需求不同，进而不同项目必须依赖不同版本的NodeJS运行环境，这种情况下，对于维护多个版本的node将会是一件非常麻烦的事情，nvm就是为解决这个问题而产生的，他可以方便的在同一台设备上进行多个node版本之间切换。</p><h3 id="nvm的下载和使用"><a href="#nvm的下载和使用" class="headerlink" title="nvm的下载和使用"></a>nvm的下载和使用</h3><p>安装包地址：<a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a><br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20230413154837.png"></p><p>下载windows版本</p><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20230413155112.png"></p><p>点击下载好的压缩包  运行里面的exe文件进行安装</p><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20230413155223.png"></p><p>第一个路径选择的是安装目录<br>第二个路径选择的是node的安装目录；<br><code>如果本身装有node，则选择node所在位置</code></p><h3 id="选择淘宝镜像加速下载"><a href="#选择淘宝镜像加速下载" class="headerlink" title="选择淘宝镜像加速下载"></a>选择淘宝镜像加速下载</h3><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20230413155504.png"></p><p>编辑settings.txt;不改变原来的内容在下方加上以下两行内容<br><code>node_mirror: https://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/</code></p><h3 id="nvm的操作"><a href="#nvm的操作" class="headerlink" title="nvm的操作"></a>nvm的操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvm off                     // 禁用node.js版本管理(不卸载任何东西)</span><br><span class="line">nvm on                      // 启用node.js版本管理</span><br><span class="line">nvm install &lt;version&gt;       // 安装node.js的命名 version是版本号 例如：nvm install 8.12.0</span><br><span class="line">nvm uninstall &lt;version&gt;     // 卸载node.js是的命令，卸载指定版本的nodejs，当安装失败时卸载使用</span><br><span class="line">nvm ls                      // 显示所有安装的node.js版本</span><br><span class="line">nvm list available          // 显示可以安装的所有node.js的版本</span><br><span class="line">nvm use &lt;version&gt;           // 切换到使用指定的nodejs版本</span><br><span class="line">nvm v                       // 显示nvm版本</span><br><span class="line">nvm install stable          // 安装最新稳定版</span><br></pre></td></tr></table></figure><p>以上就是全部内容,不得不说感觉真的好用</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写Promise🧐简单版🚩</title>
      <link href="/2023/04/09/%E6%89%8B%E5%86%99Promise/"/>
      <url>/2023/04/09/%E6%89%8B%E5%86%99Promise/</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span>&#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">executor</span>)&#123;</span><br><span class="line">  <span class="comment">// 初始化state为等待态</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="comment">// 成功的值</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 失败的原因</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">resolve</span> = value =&gt; &#123;</span><br><span class="line"><span class="comment">// state改变,resolve调用就会失败</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// resolve调用后，state转化为成功态</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">  <span class="comment">// 储存成功的值</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">reject</span> = reason =&gt; &#123;</span><br><span class="line"><span class="comment">// state改变,reject调用就会失败</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// reject调用后，state转化为失败态</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">  <span class="comment">// 储存失败的原因</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 如果executor执行报错，直接执行reject</span></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line"><span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="title function_">reject</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">then</span>(<span class="params">onFulfilled,onRejected</span>) &#123;</span><br><span class="line"><span class="comment">// 状态为fulfilled，执行onFulfilled，传入成功的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">  <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 状态为rejected，执行onRejected，传入失败的原因</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">  <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生活篇❤🥰</title>
      <link href="/2023/04/05/%E7%94%9F%E6%B4%BB%E7%AF%873/"/>
      <url>/2023/04/05/%E7%94%9F%E6%B4%BB%E7%AF%873/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="7c0959f42f3e494088a61535c14ff7054402ffcbbff5d675d09ff186bcb17af4">000782237589767ffba159e10d20f5ff0846d4487e9e3f8ea5baab5ff0786a1adf19b95feb8aea423a6ce83ba0ef07f57b31b244d742c7f5d2bac344cb73bec26a02a505fdc1bfb95f959984ee49eb9a6b1fa55057e5244e8af21896333abeb972821b56389bb28bef60f2af414cc7042aebee954dfb2038c8d2e08e8cb38b1fa9489f7de3af57a3b0cbb2e14275c6a0796723522aa160e7c58b0913f23f220f1cf10b9762ba3ae9da7c1de65b90cad1fec69ded737c6b244e231da07936d184eaf849e4669d4a74ab0d485ef47b1ac7b652f51d844523263120fd8bbf45dedee8ab83260d8a213903f5da21759aa58a0c9a39cf28089f6b4328053c5eec4f5c6df215126eb252eda6fb15bde115efdcd5c54d0715bb38bcd6f2bdf2d251ec3123853f0e0890dd4bb1d9c03a7cf036bcd8739e576c1f4e01e8c1aff9fc47230b6d6ae9f0ce795d5e183bf781adf07f6d85d89b0a4625a0ad343170c5ecc814600495b5e0ee7414ee29b1fdb36e42120cb9129ff1fb88e7b2223192adb0085451f9e6d414a338aa7294df2365646b4495</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-surge">      <input class="hbe hbe-input-field hbe-input-field-surge" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-surge" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-surge" data-content="密码很简单 可以试一下，我女朋友肯定知道">密码很简单 可以试一下，我女朋友肯定知道</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-surge" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M1200,9c0,0-305.005,0-401.001,0C733,9,675.327,4.969,598,4.969C514.994,4.969,449.336,9,400.333,9C299.666,9,0,9,0,9v43c0,0,299.666,0,400.333,0c49.002,0,114.66,3.484,197.667,3.484c77.327,0,135-3.484,200.999-3.484C894.995,52,1200,52,1200,52V9z"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器如何渲染的</title>
      <link href="/2023/04/02/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/04/02/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="浏览器是如何渲染页面的？"><a href="#浏览器是如何渲染页面的？" class="headerlink" title="浏览器是如何渲染页面的？"></a>浏览器是如何渲染页面的？</h2><p>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。</p><p>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</p><hr><p>整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p><p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p><p>这样，整个渲染流程就形成了一套组织严密的生产流水线。</p><hr><p>渲染的第一步是<strong>解析 HTML</strong>。</p><p>解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。</p><p>如果主线程解析到<code>link</code>位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。</p><p>如果主线程解析到<code>script</code>位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。</p><p>第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p><hr><p>渲染的下一步是<strong>样式计算</strong>。</p><p>主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。</p><p>在这一过程中，很多预设值会变成绝对值，比如<code>red</code>会变成<code>rgb(255,0,0)</code>；相对单位会变成绝对单位，比如<code>em</code>会变成<code>px</code></p><p>这一步完成后，会得到一棵带有样式的 DOM 树。</p><hr><p>接下来是<strong>布局</strong>，布局完成后会得到布局树。</p><p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p><p>大部分时候，DOM 树和布局树并非一一对应。</p><p>比如<code>display:none</code>的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</p><hr><p>下一步是<strong>分层</strong></p><p>主线程会使用一套复杂的策略对整个布局树中进行分层。</p><p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p><p>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过<code>will-change</code>属性更大程度的影响分层结果。</p><hr><p>再下一步是<strong>绘制</strong></p><p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p><hr><p>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p><p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。</p><p>它会从线程池中拿取多个线程来完成分块工作。</p><hr><p>分块完成后，进入<strong>光栅化</strong>阶段。</p><p>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。</p><p>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</p><p>光栅化的结果，就是一块一块的位图</p><hr><p>最后一个阶段就是<strong>画</strong>了</p><p>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。</p><p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p><p>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的本质原因。</p><p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p><h2 id="什么是-reflow？"><a href="#什么是-reflow？" class="headerlink" title="什么是 reflow？"></a>什么是 reflow？</h2><p>reflow 的本质就是重新计算 layout 树。</p><p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p><p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p><p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p><p>浏览器在反复权衡下，最终决定获取属性立即 reflow。</p><h2 id="什么是-repaint？"><a href="#什么是-repaint？" class="headerlink" title="什么是 repaint？"></a>什么是 repaint？</h2><p>repaint 的本质就是重新根据分层信息计算了绘制指令。</p><p>当改动了可见样式后，就需要重新计算，会引发 repaint。</p><p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p><h2 id="为什么-transform-的效率高？"><a href="#为什么-transform-的效率高？" class="headerlink" title="为什么 transform 的效率高？"></a>为什么 transform 的效率高？</h2><p>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段</p><p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS事件循环</title>
      <link href="/2023/03/25/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEvenLoop/"/>
      <url>/2023/03/25/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEvenLoop/</url>
      
        <content type="html"><![CDATA[<h3 id="用简单的流程解释事件循环"><a href="#用简单的流程解释事件循环" class="headerlink" title="用简单的流程解释事件循环"></a>用简单的流程解释事件循环</h3><p>在了解什么是事件循环之前我们应该需要先行了解<code>javascript是一个单线程语言</code>和<code>JavaScript的事件分类</code>;</p><h3 id="JavaScript是一个单线程语言"><a href="#JavaScript是一个单线程语言" class="headerlink" title="JavaScript是一个单线程语言"></a>JavaScript是一个单线程语言</h3><p>什么是单线程。举个例子：这就好像食堂打饭，需要排队，如果只有一个窗口可以进行打饭，那么就可以看作是单线程，如果有好多个窗口可以进行打饭，这就是多线程<br><code>同理，javascript中的所有任务都只有一条线程在处理。</code></p><p>显然这种机制会造成很多问题，如果一个任务卡死，那么整个都不能运行了，<br>或者其中有一个任务执行的很慢，那么后面所有的任务都会延迟执行，所以JS有了两个任务分类[同步任务]和[异步任务]</p><h3 id="JavaScript的任务分类"><a href="#JavaScript的任务分类" class="headerlink" title="JavaScript的任务分类"></a>JavaScript的任务分类</h3><p>接上文，javascript中饿所有任务被分为同步任务和异步任务两大类<br>同步任务介绍：就是只要扫描到，就会马上执行的任务（优先于所有异步任务）<br>异步任务介绍：即使被扫描到，也不会立即执行，而是会被压入异步任务队列，等待主线程中的任务被执行完毕，再被召唤执行</p><p>常见的异步任务有如下几种</p><ol><li>Promise.then() –微任务</li><li>async/await —Promise的语法糖 —微任务</li><li>setTimeOut() —宏任务</li><li>setInterval() —宏任务</li><li>…..<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>结果是2 1  虽然定时器是0秒，但是setTimeout是一个异步任务，会等到所有同步任务执行完毕再去执行</li></ol><h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><p>JavaScript的异步任务分为宏任务和微任务，</p><p>在异步任务中，有些异步任务的执行周期较长，被列入宏任务队列，有些执行周期较短被列入为任务队列</p><p>两种任务在执行顺序上是不一样的，当有异步任务被压入任务队列时，JavaScript会将这两种任务放入两个新的任务队列，会优先执行已经存在的微任务，在所有微任务执行完毕之后会执行一个宏任务，注意是一个宏任务，之后再去微任务队列检查是否有未执行的微任务，如果有则全部执行，再回到宏任务队列再执行一个宏任务，依次循环，这套流程被称作事件循环（event loop）</p><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20230325160939.png"></p><h3 id="来一个例题"><a href="#来一个例题" class="headerlink" title="来一个例题"></a>来一个例题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>) &#125;, <span class="number">0</span>);  <span class="comment">//异步任务 - 宏任务</span></span><br><span class="line"></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);   <span class="comment">//同步任务</span></span><br><span class="line"></span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>) &#125;) <span class="comment">//异步任务 - 微任务</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);   <span class="comment">//同步任务</span></span><br></pre></td></tr></table></figure><p>结果为 2 6 3 1</p><p>解析参考：</p><p>首先，同步任务必定优先于所有所有异步任务并按顺序执行。所以输出 2 6。</p><p>同步任务执行完毕后，还剩下一个宏任务和一个微任务。</p><p>微任务优先于宏任务执行，所以先输出 3 再输出 1</p><p>得答案：2 6 3 1</p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/1090548F591933667F0D8C8224F6DBF2.png"></p><p>来一道难一点的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//第一个宏任务</span></span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>); <span class="comment">//宏任务中的同步任务</span></span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>) &#125;) <span class="comment">//宏任务中的微任务</span></span><br><span class="line"> &#125;, <span class="number">0</span>);  <span class="comment">//异步任务 - 宏任务</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);   <span class="comment">//同步任务</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>) &#125;) <span class="comment">//异步任务 - 微任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个宏任务</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">8</span>); <span class="comment">//宏任务中的同步任务</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>) &#125;, <span class="number">0</span>)      <span class="comment">//宏任务中的宏任务 第四个宏任务</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三个宏任务</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>) &#125;)  <span class="comment">//宏任务中的微任务</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);   <span class="comment">//同步任务</span></span><br></pre></td></tr></table></figure><p>结果为 2 6 3 1 7 8 4 5</p><p>解析参考：<br>首先，同步任务必定优先于所有所有异步任务并按顺序执行。所以输出 2 6。<br>然后同一批次中剩下一个微任务和一个三个宏任务。<br>因为宏任务必定会在同一批次环境中的微任务全部执行完毕后再执行，所以场上当前批次中唯一一个微任务先执行。输出3<br>还剩下三个宏任务。执行第一个宏任务，宏任务中有一个同步任务和一个异步任务。这里要注意两点。</p><p>统一批次宏任务中按顺序执行<br>一次只执行一个宏任务，然后同步任务当场执行。微任务压入队列。然后就要去检查有没有微任务，有则执行</p><p>所以，第一个宏任务执行的时候，产生了一个同步任务和一个微任务。需要注意,宏任务一次只执行一个。执行完之后发现同步任务当场执行（输出1），然后查看微任务队列中有没有微任务可以执行。发现有，则执行微任务（输出7）<br>然后,才开始执行第二个宏任务。执行第二个宏任务产生了一个同步任务，同步任务当场执行（输出8），产生一个宏任务（宏任务压入红任务执行队列，也就是所有宏任务之后），按事件循环，再次检查是否存在未执行的微任务，发现没有，不执行。<br>然后执行第三个宏任务，第三个宏任务中产生一个微任务，按事件循环，再去寻找是否存在未执行的微任务，发现有，则执行（输出4）<br>最后执行第四个宏任务（第二个宏任务产生的）。走一遍事件循环的流程，输出5</p><p><code>事件循环每一次只执行一个宏任务</code>  这个是非常重要的一点</p><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/2871389CC6253FDBDB3DD1B711CA6575.png"></p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue面试题-第一弹</title>
      <link href="/2023/03/19/vue%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/03/19/vue%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="组件间通信的方式"><a href="#组件间通信的方式" class="headerlink" title="组件间通信的方式"></a>组件间通信的方式</h3><p>根据组件之间的关系讨论组件通信最为有效</p><ol><li>父子组件</li></ol><ul><li>props/$emit/$parent/ref/$attrs</li></ul><ol start="2"><li>兄弟组件</li></ol><ul><li>$root/$parent/vuex/eventbus</li></ul><ol start="3"><li>跨层级关系</li></ol><ul><li>eventbus / vuex / prpvate + inject</li></ul><h3 id="v-for-和-v-if-那个优先级更高"><a href="#v-for-和-v-if-那个优先级更高" class="headerlink" title="v-for 和 v-if 那个优先级更高"></a>v-for 和 v-if 那个优先级更高</h3><ol><li>实践中 不应该把v-for和v-if 放在一起</li><li>在vue2中，v-for的优先级高于v-if 把他们放在一起。输出的渲染函数中已可看出会限制性循环再判断条件，哪怕我们只渲染列表中的一小部分，也得在每次重新渲染的时候遍历整个列表，这会比较浪费，另外需要注意的是在vue3中则完全相反，v-if的优先级大于v-for，所以在执行v-if的时候，它调用的变量还不存在，就会导致异常</li><li>通常有两种情况会导致我们这样做</li></ol><ul><li>为了过滤列表中的项目，此时定义一个计算属性，让其返回过滤后的列表即可</li><li>为了避免渲染本应该隐藏的列表，</li></ul><ol start="4"><li>文档中明确指出，永远不要把v-if和v-for同时用在同一个元素上面，显示这是不可行的</li><li>源码里面关于代码生成的部分，能够清晰得分看到是先出来v-if还是v-for 顺序上vue2 和vue3是相反的，但是不管怎么样，不能讲两个放在一起使用</li></ol><h3 id="简述vue生命周期"><a href="#简述vue生命周期" class="headerlink" title="简述vue生命周期"></a>简述vue生命周期</h3><ol><li>每个vue组件实例被创建后都会经过一系列初始化步骤，比如，它需要数据观测，模板编译，挂载实例到dom上，以及数据变化时的更新dom，这个过程中会运行叫做生命周期的钩子函数，以便用户在特定时期添加自己的代码，</li><li>vue生命周期总共可以分为8个阶段，创建前后，挂在前后，更新前后，卸载（销毁）前后，以及特殊场景的生命周期，vue3中新增了三个用于调试和服务端渲染场景<br>生命周期 activated activated  keep-alive缓存的组件激活时，<br>deactivated deactivated keep-alive缓存的组件停用时调用的<br>errorCaptured errorCaptured 捕获一个来自子孙组件的错误时被调用</li></ol><p> ———–   renderTracked 调试钩子，响应式依赖被收集时调用的<br> ———–   renderTriggered 调试钩子，响应式依赖被触发时调用的<br> ———–  serverPrefetch ssr only 组件实例在服务器上被渲染前调用<br> beforeCreate :通常用于插件开发中执行一些初始化任务，<br> created：组件初始化完毕，可以访问各种数据，获取接口数据等，<br> mounted：dom已创建，可以进行获取访问数据和dom元素，访问子组件，<br> beforeUpdate：此时view层还未更新，更新后，所有状态已是最新，<br> beforeunmounted:实例被销毁前调用，可用于一些定时器或者订阅的取消，<br> unmounted:销毁一个实例，可清理它与其他实例的连接，解绑它的全部指令及事件，<br> 追问：setup和creatd 谁先执行;</p><ul><li> setup先执行，setup中已经创建了组件实例,creatd是创建之后，</li><li>setup中为什么没有beforeCreate和created，因为<br>  setup中已经完成了组件实例的创建，所以没有这两个钩子，这两个钩子是专门为options API服务的</li></ul><h3 id="双向绑定使用和原理"><a href="#双向绑定使用和原理" class="headerlink" title="双向绑定使用和原理"></a>双向绑定使用和原理</h3><ol><li>vue中双向绑定是一个指令v-model，可以绑定一个响应式数据到视图，同时视图中的变化能改变该值，</li><li>v-model 是语法糖，默认情况下相当于：value 和 @input 。使用v-model可以减少大量的繁琐的代码，提高开发效率</li></ol><h3 id="了解DIFF算法"><a href="#了解DIFF算法" class="headerlink" title="了解DIFF算法"></a>了解DIFF算法</h3><ol><li>在新老虚拟DOM对比时： ● 首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换 ● 如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除) ● 比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。 ● 匹配时，找到相同的子节点，递归比较子节点 在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</li></ol><h3 id="Vue-中key-的作用"><a href="#Vue-中key-的作用" class="headerlink" title="Vue 中key 的作用"></a>Vue 中key 的作用</h3><p>vue 中 key 值的作用可以分为两种情况来考虑： </p><ul><li>  第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。 </li><li>  第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</li><li>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速 <ul><li> 更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key === b.key对比中可以避免就地复用的情况。所以会更加准确。 </li><li> 更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖与节流</title>
      <link href="/2023/03/14/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
      <url>/2023/03/14/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h3 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h3><p>复习一下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn,delay</span>)&#123;</span><br><span class="line"><span class="keyword">let</span> timerID=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">const</span> context =<span class="variable language_">this</span>;</span><br><span class="line"><span class="keyword">if</span>(timeID)&#123;</span><br><span class="line"><span class="variable language_">window</span>.<span class="built_in">clearTimeout</span>(timerID);</span><br><span class="line">&#125;</span><br><span class="line">timerID = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">fn.<span class="title function_">apply</span>(context,<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;,delay)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">thottle</span>(<span class="params">fn</span>)&#123;<span class="comment">/* 节流 */</span></span><br><span class="line"><span class="keyword">let</span> cardu = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(cardu)&#123;</span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>,<span class="variable language_">arguments</span>);</span><br><span class="line">cardu=<span class="literal">false</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">cardu = <span class="literal">true</span>;</span><br><span class="line">&#125;,<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack5的vue配置</title>
      <link href="/2023/03/11/webpack/"/>
      <url>/2023/03/11/webpack/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-脚手架"><a href="#Vue-脚手架" class="headerlink" title="Vue 脚手架"></a>Vue 脚手架</h1><h2 id="开发模式配置"><a href="#开发模式配置" class="headerlink" title="开发模式配置"></a>开发模式配置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.dev.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ESLintWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;eslint-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">VueLoaderPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;vue-loader&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">DefinePlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CopyPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;copy-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getStyleLoaders</span> = (<span class="params">preProcessor</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    <span class="string">&quot;vue-style-loader&quot;</span>,</span><br><span class="line">    <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">postcssOptions</span>: &#123;</span><br><span class="line">          <span class="attr">plugins</span>: [</span><br><span class="line">            <span class="string">&quot;postcss-preset-env&quot;</span>, <span class="comment">// 能解决大多数样式兼容性问题</span></span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    preProcessor,</span><br><span class="line">  ].<span class="title function_">filter</span>(<span class="title class_">Boolean</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/[name].js&quot;</span>,</span><br><span class="line">    <span class="attr">chunkFilename</span>: <span class="string">&quot;static/js/[name].chunk.js&quot;</span>,</span><br><span class="line">    <span class="attr">assetModuleFilename</span>: <span class="string">&quot;static/js/[hash:10][ext][query]&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(<span class="string">&quot;less-loader&quot;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(<span class="string">&quot;sass-loader&quot;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(<span class="string">&quot;stylus-loader&quot;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jsx|js)$/</span>,</span><br><span class="line">        <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../src&quot;</span>),</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">cacheDirectory</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">cacheCompression</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">plugins</span>: [</span><br><span class="line">            <span class="comment">// &quot;@babel/plugin-transform-runtime&quot; // presets中包含了</span></span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// vue-loader不支持oneOf</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&quot;vue-loader&quot;</span>, <span class="comment">// 内部会给vue文件注入HMR功能代码</span></span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="comment">// 开启缓存</span></span><br><span class="line">          <span class="attr">cacheDirectory</span>: path.<span class="title function_">resolve</span>(</span><br><span class="line">            __dirname,</span><br><span class="line">            <span class="string">&quot;node_modules/.cache/vue-loader&quot;</span></span><br><span class="line">          ),</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ESLintWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">context</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../src&quot;</span>),</span><br><span class="line">      <span class="attr">exclude</span>: <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">      <span class="attr">cache</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">cacheLocation</span>: path.<span class="title function_">resolve</span>(</span><br><span class="line">        __dirname,</span><br><span class="line">        <span class="string">&quot;../node_modules/.cache/.eslintcache&quot;</span></span><br><span class="line">      ),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../public/index.html&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CopyPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">patterns</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">from</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../public&quot;</span>),</span><br><span class="line">          <span class="attr">to</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../dist&quot;</span>),</span><br><span class="line">          <span class="attr">toType</span>: <span class="string">&quot;dir&quot;</span>,</span><br><span class="line">          <span class="attr">noErrorOnMissing</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">globOptions</span>: &#123;</span><br><span class="line">            <span class="attr">ignore</span>: [<span class="string">&quot;**/index.html&quot;</span>],</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">info</span>: &#123;</span><br><span class="line">            <span class="attr">minimized</span>: <span class="literal">true</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">VueLoaderPlugin</span>(),</span><br><span class="line">    <span class="comment">// 解决页面警告</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">DefinePlugin</span>(&#123;</span><br><span class="line">      <span class="attr">__VUE_OPTIONS_API__</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">      <span class="attr">__VUE_PROD_DEVTOOLS__</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">runtimeChunk</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="function">(<span class="params">entrypoint</span>) =&gt;</span> <span class="string">`runtime~<span class="subst">$&#123;entrypoint.name&#125;</span>`</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&quot;.vue&quot;</span>, <span class="string">&quot;.js&quot;</span>, <span class="string">&quot;.json&quot;</span>], <span class="comment">// 自动补全文件扩展名，让vue可以使用</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">    <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">historyApiFallback</span>: <span class="literal">true</span>, <span class="comment">// 解决vue-router刷新404问题</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&quot;cheap-module-source-map&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="生产模式配置"><a href="#生产模式配置" class="headerlink" title="生产模式配置"></a>生产模式配置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ESLintWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;eslint-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CssMinimizerPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;css-minimizer-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TerserWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;terser-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ImageMinimizerPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;image-minimizer-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">VueLoaderPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;vue-loader&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">DefinePlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getStyleLoaders</span> = (<span class="params">preProcessor</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">    <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">postcssOptions</span>: &#123;</span><br><span class="line">          <span class="attr">plugins</span>: [</span><br><span class="line">            <span class="string">&quot;postcss-preset-env&quot;</span>, <span class="comment">// 能解决大多数样式兼容性问题</span></span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    preProcessor,</span><br><span class="line">  ].<span class="title function_">filter</span>(<span class="title class_">Boolean</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/[name].[contenthash:10].js&quot;</span>,</span><br><span class="line">    <span class="attr">chunkFilename</span>: <span class="string">&quot;static/js/[name].[contenthash:10].chunk.js&quot;</span>,</span><br><span class="line">    <span class="attr">assetModuleFilename</span>: <span class="string">&quot;static/js/[hash:10][ext][query]&quot;</span>,</span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(<span class="string">&quot;less-loader&quot;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(<span class="string">&quot;sass-loader&quot;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(<span class="string">&quot;stylus-loader&quot;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jsx|js)$/</span>,</span><br><span class="line">        <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../src&quot;</span>),</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">cacheDirectory</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">cacheCompression</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">plugins</span>: [</span><br><span class="line">            <span class="comment">// &quot;@babel/plugin-transform-runtime&quot; // presets中包含了</span></span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// vue-loader不支持oneOf</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&quot;vue-loader&quot;</span>, <span class="comment">// 内部会给vue文件注入HMR功能代码</span></span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="comment">// 开启缓存</span></span><br><span class="line">          <span class="attr">cacheDirectory</span>: path.<span class="title function_">resolve</span>(</span><br><span class="line">            __dirname,</span><br><span class="line">            <span class="string">&quot;node_modules/.cache/vue-loader&quot;</span></span><br><span class="line">          ),</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ESLintWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">context</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../src&quot;</span>),</span><br><span class="line">      <span class="attr">exclude</span>: <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">      <span class="attr">cache</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">cacheLocation</span>: path.<span class="title function_">resolve</span>(</span><br><span class="line">        __dirname,</span><br><span class="line">        <span class="string">&quot;../node_modules/.cache/.eslintcache&quot;</span></span><br><span class="line">      ),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../public/index.html&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CopyPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">patterns</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">from</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../public&quot;</span>),</span><br><span class="line">          <span class="attr">to</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../dist&quot;</span>),</span><br><span class="line">          <span class="attr">toType</span>: <span class="string">&quot;dir&quot;</span>,</span><br><span class="line">          <span class="attr">noErrorOnMissing</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">globOptions</span>: &#123;</span><br><span class="line">            <span class="attr">ignore</span>: [<span class="string">&quot;**/index.html&quot;</span>],</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">info</span>: &#123;</span><br><span class="line">            <span class="attr">minimized</span>: <span class="literal">true</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;static/css/[name].[contenthash:10].css&quot;</span>,</span><br><span class="line">      <span class="attr">chunkFilename</span>: <span class="string">&quot;static/css/[name].[contenthash:10].chunk.css&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">VueLoaderPlugin</span>(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">DefinePlugin</span>(&#123;</span><br><span class="line">      <span class="attr">__VUE_OPTIONS_API__</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">      <span class="attr">__VUE_PROD_DEVTOOLS__</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="comment">// 压缩的操作</span></span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">CssMinimizerPlugin</span>(),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">TerserWebpackPlugin</span>(),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ImageMinimizerPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">minimizer</span>: &#123;</span><br><span class="line">          <span class="attr">implementation</span>: <span class="title class_">ImageMinimizerPlugin</span>.<span class="property">imageminGenerate</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">plugins</span>: [</span><br><span class="line">              [<span class="string">&quot;gifsicle&quot;</span>, &#123; <span class="attr">interlaced</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">              [<span class="string">&quot;jpegtran&quot;</span>, &#123; <span class="attr">progressive</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">              [<span class="string">&quot;optipng&quot;</span>, &#123; <span class="attr">optimizationLevel</span>: <span class="number">5</span> &#125;],</span><br><span class="line">              [</span><br><span class="line">                <span class="string">&quot;svgo&quot;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">plugins</span>: [</span><br><span class="line">                    <span class="string">&quot;preset-default&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;prefixIds&quot;</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="attr">name</span>: <span class="string">&quot;sortAttrs&quot;</span>,</span><br><span class="line">                      <span class="attr">params</span>: &#123;</span><br><span class="line">                        <span class="attr">xmlnsOrder</span>: <span class="string">&quot;alphabetical&quot;</span>,</span><br><span class="line">                      &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                  ],</span><br><span class="line">                &#125;,</span><br><span class="line">              ],</span><br><span class="line">            ],</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">runtimeChunk</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="function">(<span class="params">entrypoint</span>) =&gt;</span> <span class="string">`runtime~<span class="subst">$&#123;entrypoint.name&#125;</span>`</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&quot;.vue&quot;</span>, <span class="string">&quot;.js&quot;</span>, <span class="string">&quot;.json&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&quot;source-map&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><ul><li>package.json</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-cli&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;main.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm run dev&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env NODE_ENV=development webpack serve --config ./config/webpack.dev.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env NODE_ENV=production webpack --config ./config/webpack.prod.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@babel/core&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.17.10&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@babel/eslint-parser&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.17.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@vue/cli-plugin-babel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.0.4&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;babel-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^8.2.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;copy-webpack-plugin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^10.2.4&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cross-env&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.0.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;css-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^6.7.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;css-minimizer-webpack-plugin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.4.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eslint-plugin-vue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^8.7.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eslint-webpack-plugin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.1.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;html-webpack-plugin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.5.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;image-minimizer-webpack-plugin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.2.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;imagemin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^8.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;imagemin-gifsicle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;imagemin-jpegtran&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;imagemin-optipng&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^8.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;imagemin-svgo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^10.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;less-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^10.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mini-css-extract-plugin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.6.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;postcss-preset-env&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.5.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sass-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^12.6.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;stylus-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^6.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vue-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^17.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vue-style-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.1.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vue-template-compiler&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.6.14&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;webpack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.72.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;webpack-cli&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.9.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;webpack-dev-server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.9.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;vue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.2.33&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vue-router&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.0.15&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;browserslist&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;last 2 version&quot;</span><span class="punctuation">,</span> <span class="string">&quot;&gt; 1%&quot;</span><span class="punctuation">,</span> <span class="string">&quot;not dead&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>.eslintrc.js</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">root</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">node</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&quot;plugin:vue/vue3-essential&quot;</span>, <span class="string">&quot;eslint:recommended&quot;</span>],</span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">parser</span>: <span class="string">&quot;@babel/eslint-parser&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>babel.config.js</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [<span class="string">&quot;@vue/cli-plugin-babel/preset&quot;</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="合并开发和生产配置"><a href="#合并开发和生产配置" class="headerlink" title="合并开发和生产配置"></a>合并开发和生产配置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ESLintWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;eslint-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CssMinimizerPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;css-minimizer-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TerserWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;terser-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ImageMinimizerPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;image-minimizer-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">VueLoaderPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;vue-loader&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">DefinePlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CopyPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;copy-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要通过 cross-env 定义环境变量</span></span><br><span class="line"><span class="keyword">const</span> isProduction = process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&quot;production&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getStyleLoaders</span> = (<span class="params">preProcessor</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    isProduction ? <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span> : <span class="string">&quot;vue-style-loader&quot;</span>,</span><br><span class="line">    <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">postcssOptions</span>: &#123;</span><br><span class="line">          <span class="attr">plugins</span>: [<span class="string">&quot;postcss-preset-env&quot;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    preProcessor,</span><br><span class="line">  ].<span class="title function_">filter</span>(<span class="title class_">Boolean</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: isProduction ? path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../dist&quot;</span>) : <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">filename</span>: isProduction</span><br><span class="line">      ? <span class="string">&quot;static/js/[name].[contenthash:10].js&quot;</span></span><br><span class="line">      : <span class="string">&quot;static/js/[name].js&quot;</span>,</span><br><span class="line">    <span class="attr">chunkFilename</span>: isProduction</span><br><span class="line">      ? <span class="string">&quot;static/js/[name].[contenthash:10].chunk.js&quot;</span></span><br><span class="line">      : <span class="string">&quot;static/js/[name].chunk.js&quot;</span>,</span><br><span class="line">    <span class="attr">assetModuleFilename</span>: <span class="string">&quot;static/js/[hash:10][ext][query]&quot;</span>,</span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(<span class="string">&quot;less-loader&quot;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(<span class="string">&quot;sass-loader&quot;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(<span class="string">&quot;stylus-loader&quot;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jsx|js)$/</span>,</span><br><span class="line">        <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../src&quot;</span>),</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">cacheDirectory</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">cacheCompression</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">plugins</span>: [</span><br><span class="line">            <span class="comment">// &quot;@babel/plugin-transform-runtime&quot; // presets中包含了</span></span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// vue-loader不支持oneOf</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&quot;vue-loader&quot;</span>, <span class="comment">// 内部会给vue文件注入HMR功能代码</span></span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="comment">// 开启缓存</span></span><br><span class="line">          <span class="attr">cacheDirectory</span>: path.<span class="title function_">resolve</span>(</span><br><span class="line">            __dirname,</span><br><span class="line">            <span class="string">&quot;node_modules/.cache/vue-loader&quot;</span></span><br><span class="line">          ),</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ESLintWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">context</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../src&quot;</span>),</span><br><span class="line">      <span class="attr">exclude</span>: <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">      <span class="attr">cache</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">cacheLocation</span>: path.<span class="title function_">resolve</span>(</span><br><span class="line">        __dirname,</span><br><span class="line">        <span class="string">&quot;../node_modules/.cache/.eslintcache&quot;</span></span><br><span class="line">      ),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../public/index.html&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CopyPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">patterns</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">from</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../public&quot;</span>),</span><br><span class="line">          <span class="attr">to</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../dist&quot;</span>),</span><br><span class="line">          <span class="attr">toType</span>: <span class="string">&quot;dir&quot;</span>,</span><br><span class="line">          <span class="attr">noErrorOnMissing</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">globOptions</span>: &#123;</span><br><span class="line">            <span class="attr">ignore</span>: [<span class="string">&quot;**/index.html&quot;</span>],</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">info</span>: &#123;</span><br><span class="line">            <span class="attr">minimized</span>: <span class="literal">true</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">    isProduction &amp;&amp;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;static/css/[name].[contenthash:10].css&quot;</span>,</span><br><span class="line">        <span class="attr">chunkFilename</span>: <span class="string">&quot;static/css/[name].[contenthash:10].chunk.css&quot;</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">VueLoaderPlugin</span>(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">DefinePlugin</span>(&#123;</span><br><span class="line">      <span class="attr">__VUE_OPTIONS_API__</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">      <span class="attr">__VUE_PROD_DEVTOOLS__</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ].<span class="title function_">filter</span>(<span class="title class_">Boolean</span>),</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimize</span>: isProduction,</span><br><span class="line">    <span class="comment">// 压缩的操作</span></span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">CssMinimizerPlugin</span>(),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">TerserWebpackPlugin</span>(),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ImageMinimizerPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">minimizer</span>: &#123;</span><br><span class="line">          <span class="attr">implementation</span>: <span class="title class_">ImageMinimizerPlugin</span>.<span class="property">imageminGenerate</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">plugins</span>: [</span><br><span class="line">              [<span class="string">&quot;gifsicle&quot;</span>, &#123; <span class="attr">interlaced</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">              [<span class="string">&quot;jpegtran&quot;</span>, &#123; <span class="attr">progressive</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">              [<span class="string">&quot;optipng&quot;</span>, &#123; <span class="attr">optimizationLevel</span>: <span class="number">5</span> &#125;],</span><br><span class="line">              [</span><br><span class="line">                <span class="string">&quot;svgo&quot;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">plugins</span>: [</span><br><span class="line">                    <span class="string">&quot;preset-default&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;prefixIds&quot;</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="attr">name</span>: <span class="string">&quot;sortAttrs&quot;</span>,</span><br><span class="line">                      <span class="attr">params</span>: &#123;</span><br><span class="line">                        <span class="attr">xmlnsOrder</span>: <span class="string">&quot;alphabetical&quot;</span>,</span><br><span class="line">                      &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                  ],</span><br><span class="line">                &#125;,</span><br><span class="line">              ],</span><br><span class="line">            ],</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">runtimeChunk</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="function">(<span class="params">entrypoint</span>) =&gt;</span> <span class="string">`runtime~<span class="subst">$&#123;entrypoint.name&#125;</span>`</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&quot;.vue&quot;</span>, <span class="string">&quot;.js&quot;</span>, <span class="string">&quot;.json&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">    <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">historyApiFallback</span>: <span class="literal">true</span>, <span class="comment">// 解决vue-router刷新404问题</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mode</span>: isProduction ? <span class="string">&quot;production&quot;</span> : <span class="string">&quot;development&quot;</span>,</span><br><span class="line">  <span class="attr">devtool</span>: isProduction ? <span class="string">&quot;source-map&quot;</span> : <span class="string">&quot;cheap-module-source-map&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="优化配置"><a href="#优化配置" class="headerlink" title="优化配置"></a>优化配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);</span><br><span class="line">const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);</span><br><span class="line">const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);</span><br><span class="line">const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);</span><br><span class="line">const ImageMinimizerPlugin = require(&quot;image-minimizer-webpack-plugin&quot;);</span><br><span class="line">const TerserWebpackPlugin = require(&quot;terser-webpack-plugin&quot;);</span><br><span class="line">const CopyPlugin = require(&quot;copy-webpack-plugin&quot;);</span><br><span class="line">const &#123; VueLoaderPlugin &#125; = require(&quot;vue-loader&quot;);</span><br><span class="line">const &#123; DefinePlugin &#125; = require(&quot;webpack&quot;);</span><br><span class="line">const AutoImport = require(&quot;unplugin-auto-import/webpack&quot;);</span><br><span class="line">const Components = require(&quot;unplugin-vue-components/webpack&quot;);</span><br><span class="line">const &#123; ElementPlusResolver &#125; = require(&quot;unplugin-vue-components/resolvers&quot;);</span><br><span class="line">// 需要通过 cross-env 定义环境变量</span><br><span class="line">const isProduction = process.env.NODE_ENV === &quot;production&quot;;</span><br><span class="line"></span><br><span class="line">const getStyleLoaders = (preProcessor) =&gt; &#123;</span><br><span class="line">  return [</span><br><span class="line">    isProduction ? MiniCssExtractPlugin.loader : &quot;vue-style-loader&quot;,</span><br><span class="line">    &quot;css-loader&quot;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: &quot;postcss-loader&quot;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        postcssOptions: &#123;</span><br><span class="line">          plugins: [&quot;postcss-preset-env&quot;],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    preProcessor &amp;&amp; &#123;</span><br><span class="line">      loader: preProcessor,</span><br><span class="line">      options:</span><br><span class="line">        preProcessor === &quot;sass-loader&quot;</span><br><span class="line">          ? &#123;</span><br><span class="line">              // 自定义主题：自动引入我们定义的scss文件</span><br><span class="line">              additionalData: `@use &quot;@/styles/element/index.scss&quot; as *;`,</span><br><span class="line">            &#125;</span><br><span class="line">          : &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ].filter(Boolean);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &quot;./src/main.js&quot;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: isProduction ? path.resolve(__dirname, &quot;../dist&quot;) : undefined,</span><br><span class="line">    filename: isProduction</span><br><span class="line">      ? &quot;static/js/[name].[contenthash:10].js&quot;</span><br><span class="line">      : &quot;static/js/[name].js&quot;,</span><br><span class="line">    chunkFilename: isProduction</span><br><span class="line">      ? &quot;static/js/[name].[contenthash:10].chunk.js&quot;</span><br><span class="line">      : &quot;static/js/[name].chunk.js&quot;,</span><br><span class="line">    assetModuleFilename: &quot;static/js/[hash:10][ext][query]&quot;,</span><br><span class="line">    clean: true,</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: getStyleLoaders(),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.less$/,</span><br><span class="line">        use: getStyleLoaders(&quot;less-loader&quot;),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.s[ac]ss$/,</span><br><span class="line">        use: getStyleLoaders(&quot;sass-loader&quot;),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.styl$/,</span><br><span class="line">        use: getStyleLoaders(&quot;stylus-loader&quot;),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(png|jpe?g|gif|svg)$/,</span><br><span class="line">        type: &quot;asset&quot;,</span><br><span class="line">        parser: &#123;</span><br><span class="line">          dataUrlCondition: &#123;</span><br><span class="line">            maxSize: 10 * 1024,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(ttf|woff2?)$/,</span><br><span class="line">        type: &quot;asset/resource&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(jsx|js)$/,</span><br><span class="line">        include: path.resolve(__dirname, &quot;../src&quot;),</span><br><span class="line">        loader: &quot;babel-loader&quot;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          cacheDirectory: true,</span><br><span class="line">          cacheCompression: false,</span><br><span class="line">          plugins: [</span><br><span class="line">            // &quot;@babel/plugin-transform-runtime&quot; // presets中包含了</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      // vue-loader不支持oneOf</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.vue$/,</span><br><span class="line">        loader: &quot;vue-loader&quot;, // 内部会给vue文件注入HMR功能代码</span><br><span class="line">        options: &#123;</span><br><span class="line">          // 开启缓存</span><br><span class="line">          cacheDirectory: path.resolve(</span><br><span class="line">            __dirname,</span><br><span class="line">            &quot;node_modules/.cache/vue-loader&quot;</span><br><span class="line">          ),</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new ESLintWebpackPlugin(&#123;</span><br><span class="line">      context: path.resolve(__dirname, &quot;../src&quot;),</span><br><span class="line">      exclude: &quot;node_modules&quot;,</span><br><span class="line">      cache: true,</span><br><span class="line">      cacheLocation: path.resolve(</span><br><span class="line">        __dirname,</span><br><span class="line">        &quot;../node_modules/.cache/.eslintcache&quot;</span><br><span class="line">      ),</span><br><span class="line">    &#125;),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.resolve(__dirname, &quot;../public/index.html&quot;),</span><br><span class="line">    &#125;),</span><br><span class="line">    new CopyPlugin(&#123;</span><br><span class="line">      patterns: [</span><br><span class="line">        &#123;</span><br><span class="line">          from: path.resolve(__dirname, &quot;../public&quot;),</span><br><span class="line">          to: path.resolve(__dirname, &quot;../dist&quot;),</span><br><span class="line">          toType: &quot;dir&quot;,</span><br><span class="line">          noErrorOnMissing: true,</span><br><span class="line">          globOptions: &#123;</span><br><span class="line">            ignore: [&quot;**/index.html&quot;],</span><br><span class="line">          &#125;,</span><br><span class="line">          info: &#123;</span><br><span class="line">            minimized: true,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">    isProduction &amp;&amp;</span><br><span class="line">      new MiniCssExtractPlugin(&#123;</span><br><span class="line">        filename: &quot;static/css/[name].[contenthash:10].css&quot;,</span><br><span class="line">        chunkFilename: &quot;static/css/[name].[contenthash:10].chunk.css&quot;,</span><br><span class="line">      &#125;),</span><br><span class="line">    new VueLoaderPlugin(),</span><br><span class="line">    new DefinePlugin(&#123;</span><br><span class="line">      __VUE_OPTIONS_API__: &quot;true&quot;,</span><br><span class="line">      __VUE_PROD_DEVTOOLS__: &quot;false&quot;,</span><br><span class="line">    &#125;),</span><br><span class="line">    // 按需加载element-plus组件样式</span><br><span class="line">    AutoImport(&#123;</span><br><span class="line">      resolvers: [ElementPlusResolver()],</span><br><span class="line">    &#125;),</span><br><span class="line">    Components(&#123;</span><br><span class="line">      resolvers: [</span><br><span class="line">        ElementPlusResolver(&#123;</span><br><span class="line">          importStyle: &quot;sass&quot;, // 自定义主题</span><br><span class="line">        &#125;),</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">  ].filter(Boolean),</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: isProduction,</span><br><span class="line">    // 压缩的操作</span><br><span class="line">    minimizer: [</span><br><span class="line">      new CssMinimizerPlugin(),</span><br><span class="line">      new TerserWebpackPlugin(),</span><br><span class="line">      new ImageMinimizerPlugin(&#123;</span><br><span class="line">        minimizer: &#123;</span><br><span class="line">          implementation: ImageMinimizerPlugin.imageminGenerate,</span><br><span class="line">          options: &#123;</span><br><span class="line">            plugins: [</span><br><span class="line">              [&quot;gifsicle&quot;, &#123; interlaced: true &#125;],</span><br><span class="line">              [&quot;jpegtran&quot;, &#123; progressive: true &#125;],</span><br><span class="line">              [&quot;optipng&quot;, &#123; optimizationLevel: 5 &#125;],</span><br><span class="line">              [</span><br><span class="line">                &quot;svgo&quot;,</span><br><span class="line">                &#123;</span><br><span class="line">                  plugins: [</span><br><span class="line">                    &quot;preset-default&quot;,</span><br><span class="line">                    &quot;prefixIds&quot;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      name: &quot;sortAttrs&quot;,</span><br><span class="line">                      params: &#123;</span><br><span class="line">                        xmlnsOrder: &quot;alphabetical&quot;,</span><br><span class="line">                      &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                  ],</span><br><span class="line">                &#125;,</span><br><span class="line">              ],</span><br><span class="line">            ],</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: &quot;all&quot;,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        // layouts通常是admin项目的主体布局组件，所有路由组件都要使用的</span><br><span class="line">        // 可以单独打包，从而复用</span><br><span class="line">        // 如果项目中没有，请删除</span><br><span class="line">        layouts: &#123;</span><br><span class="line">          name: &quot;layouts&quot;,</span><br><span class="line">          test: path.resolve(__dirname, &quot;../src/layouts&quot;),</span><br><span class="line">          priority: 40,</span><br><span class="line">        &#125;,</span><br><span class="line">        // 如果项目中使用element-plus，此时将所有node_modules打包在一起，那么打包输出文件会比较大。</span><br><span class="line">        // 所以我们将node_modules中比较大的模块单独打包，从而并行加载速度更好</span><br><span class="line">        // 如果项目中没有，请删除</span><br><span class="line">        elementUI: &#123;</span><br><span class="line">          name: &quot;chunk-elementPlus&quot;,</span><br><span class="line">          test: /[\\/]node_modules[\\/]_?element-plus(.*)/,</span><br><span class="line">          priority: 30,</span><br><span class="line">        &#125;,</span><br><span class="line">        // 将vue相关的库单独打包，减少node_modules的chunk体积。</span><br><span class="line">        vue: &#123;</span><br><span class="line">          name: &quot;vue&quot;,</span><br><span class="line">          test: /[\\/]node_modules[\\/]vue(.*)[\\/]/,</span><br><span class="line">          chunks: &quot;initial&quot;,</span><br><span class="line">          priority: 20,</span><br><span class="line">        &#125;,</span><br><span class="line">        libs: &#123;</span><br><span class="line">          name: &quot;chunk-libs&quot;,</span><br><span class="line">          test: /[\\/]node_modules[\\/]/,</span><br><span class="line">          priority: 10, // 权重最低，优先考虑前面内容</span><br><span class="line">          chunks: &quot;initial&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    runtimeChunk: &#123;</span><br><span class="line">      name: (entrypoint) =&gt; `runtime~$&#123;entrypoint.name&#125;`,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [&quot;.vue&quot;, &quot;.js&quot;, &quot;.json&quot;],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      // 路径别名</span><br><span class="line">      &quot;@&quot;: path.resolve(__dirname, &quot;../src&quot;),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    open: true,</span><br><span class="line">    host: &quot;localhost&quot;,</span><br><span class="line">    port: 3000,</span><br><span class="line">    hot: true,</span><br><span class="line">    compress: true,</span><br><span class="line">    historyApiFallback: true, // 解决vue-router刷新404问题</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: isProduction ? &quot;production&quot; : &quot;development&quot;,</span><br><span class="line">  devtool: isProduction ? &quot;source-map&quot; : &quot;cheap-module-source-map&quot;,</span><br><span class="line">  performance: false,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生活篇❤2（茜茜）</title>
      <link href="/2023/03/10/%E7%94%9F%E6%B4%BB%E7%AF%872/"/>
      <url>/2023/03/10/%E7%94%9F%E6%B4%BB%E7%AF%872/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="08e5f17f9e80b7fa23ac9e05d26e24b65009d0fa413a7b889950023c8634cf5f">000782237589767ffba159e10d20f5ff481af1c5a27b9b13a7a365c477cad6dd2f9acffe6a5247e1f43c3203638c87102afc371cbc0b91a476fcd5148174ed848ce98a603fc6200d055c4642fe57564db41137d3eb9cf2e96912a89aba795700e1ee2f6e83f281b514d9d6f6f75a2ecf0fc4d55373b5dcbed4c573432e53bab0f9c0dc4396c4fe0560209ec0044f46eaef65b1c5d94fb9c6c518501f8f5fe6e7def3dbd3c819ebcacdfb71e88cb5cc44b0435ed847a97266737502b41f10e1add096cca44453e9261081d925b0066156bd925b61c574779c03054019107346745e0c18195460cdcac9d0d80785aa825e75aea1fd5645c2e3790909fa4ffeaa8328899e22e9683f8e15eafce2fbe8920cc7f61757dbff0925cfb9625c793bbaa56218f6bbdcf6c2ee7e3e119b9750b59f462ac6526749bd00aee3ccdf2d8eda2d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-surge">      <input class="hbe hbe-input-field hbe-input-field-surge" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-surge" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-surge" data-content="密码很简单 可以试一下，我女朋友肯定知道">密码很简单 可以试一下，我女朋友肯定知道</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-surge" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M1200,9c0,0-305.005,0-401.001,0C733,9,675.327,4.969,598,4.969C514.994,4.969,449.336,9,400.333,9C299.666,9,0,9,0,9v43c0,0,299.666,0,400.333,0c49.002,0,114.66,3.484,197.667,3.484c77.327,0,135-3.484,200.999-3.484C894.995,52,1200,52,1200,52V9z"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 html 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生活篇❤</title>
      <link href="/2023/03/04/%E5%BF%83%E5%BE%97/"/>
      <url>/2023/03/04/%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="3f3d13c8eb262caebdd0b6502e79382a4991ad0cb2ed983c49d8e6770999a9e9">000782237589767ffba159e10d20f5ff481af1c5a27b9b13a7a365c477cad6dd731f5695b001484f54f8a2c9f1356c3b1a5f951385a1c57408f24d309a6099e16e7d7e19aac54d13b55e821337c3dc06c882af1a7a3d3b2c38182820e789d5f1ebea3926c90d90ee02bd0e58a6969a263d46503ef206cc212b92548fa5c974f5671ae08bd345585c15ffac78941357d3a90afc01b1cb8ae5ccff645666245610b7c03d5a3a51016dad5d4b49003466c37099f8ef262db01a016b495764e89cf2b50fdbc638a8010e9d8f4617b38acb5ede859d8d38e097ce35ff193aa79cf44152a5e7a5094285e7430397cb57ff319628e6b7377dc7e4faacc56fad04c124567f700e8fb603451e7ac6fca5b4b8ff1ac802f273c0c0e5a3c68ebce48a234551a3215cf945b76af6fd65c36e212a4e8c78843a9cbb63cda3ea4b8a5a5cc0ee3747f24a3b296b699dfcfae5daef5c0fec0b626264321b5b5ea33b252825b2f7853dbdc041fe4efed10a84d463d3ce8d51f38f094a5075d18faa2b14cfd3c6f83af30a260e770799f4f81e98874f42fd7177079eb215d48ba205c21f8e2dd3c8f6a486c2b3599cdb4e70bc068e565cba0cef8a0559566eb830312e37a207a56b479c3db60952e7be699fc1afe1dd70a4eb1ace3b067fa8abaa5f93a6397623771b122e5eb07866c76a49631cede651a7e714e955459e5f984cb4df85e36ff181e375348664cb3b9fec1379924a3078779c07492c4525d36e42ea9d0acb94c2cdc7825839995b472957601d34037504fe01eec9df6e9f082875a187bce63246f1a95cde3ea3b415c823cfb4a52a189ce50ba92c9f6e56012e849c21ff71499f07bb52fdeb76387080d59e3f89ef95b05af10b26033a2031ecec43ea65cbe16ce15ec60b508ef65540ca588bd0f48e9430ac6002c906158bc1214eb59c63335c82889cb6bdb93cd72fcca9efddbe1606a0b1cbac42673bf7a8077ec4ec2de50a420a8a4b02f698d5f61049a22aecbbf77260e1b6e8bd77b0164ac6a5ffb4f124fba8cb54da0f45f714a1669f23ef6253db5bf1b79309d2c9873a39bc9f750c9e6639da670d20bd3c940c548839266aa1ee161a8ea8bdbea87e7ea6046212a26cda6ace1cfad73da0f898d67fd7a3c9de1d1a890a00aaed9e51474ca0b82689500d46a7bc223106c0196a2d3f62c858a4126a0e1b043186eeab390446a6d12ec81b5bd3c6f20da95c7503c592d70399dce81687ca8860f8f6b670570fdee8579bb0bcedc871fe667de146f4abed2635f2a327e8d34f8002452674b03153a64c85ae52de9b59cac53fa77419ddc9e1ebada4c3ee7d140b937058fcbeb8bd72433fdeb3b5feb80f9f823a02edb10181fa17f2a6304842f129ec546aec9a8eae4082afc13d4b1d80942a3e499925e40c861d1a8ec10bd31bb203628d9a0b099232cb86bf2d02f717757cc1149d6c7686ffedac7eb3ae781987bb457e532dc8f68ad6ba48d81818457b4637433b4f449810e0d14551e38d22821b4d6f1aa724e91a1c63c660ef8ab51a5de6936cecce1f8a0b038c6d2200a51ea7e27e2f87e69f15bb4a53d0741f59a76c30f62d62fb236c358ba49bd7057b8faada5cfcd469b9d5552fe6e4cf62c5d61a9c40fd4159d0f912a6ad60c9cd59f6e28d56db96ab056df0c4198c8e43dd64b6fa0004808b2d6798a664ef01f2330b31be0cd1382b5eb657c6c639105189317c044eb810d5d4202f6157da7a0dff16604e221dd619d86c31739621272b8e074d063c1e4e1101bfe1c855293428e15dc9a5794df1431045c40ab6c24b81382e80389a928f2095c3db1e5ab34432b7cfef153984cd59ff18ab8f16a177c74b44a1ce45c968394446f5aa03fbff9ebd0bdebcd95269555203afdbce557e38bf05963262ff937632dacc75c9621a210fcce20d39462af3f17240737f7aebbbb6c5c9a65b662c86df7ccf2d7e514529c7f7aba291b9545ef2923a0cc7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-surge">      <input class="hbe hbe-input-field hbe-input-field-surge" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-surge" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-surge" data-content="密码很简单 可以试一下，我女朋友肯定知道">密码很简单 可以试一下，我女朋友肯定知道</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-surge" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M1200,9c0,0-305.005,0-401.001,0C733,9,675.327,4.969,598,4.969C514.994,4.969,449.336,9,400.333,9C299.666,9,0,9,0,9v43c0,0,299.666,0,400.333,0c49.002,0,114.66,3.484,197.667,3.484c77.327,0,135-3.484,200.999-3.484C894.995,52,1200,52,1200,52V9z"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 html 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3源码本码-render</title>
      <link href="/2023/03/04/render/"/>
      <url>/2023/03/04/render/</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ShapeFlags</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@mini-vue/shared&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createComponentInstance &#125; <span class="keyword">from</span> <span class="string">&quot;./component&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; queueJob &#125; <span class="keyword">from</span> <span class="string">&quot;./scheduler&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; effect &#125; <span class="keyword">from</span> <span class="string">&quot;@mini-vue/reactivity&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; setupComponent &#125; <span class="keyword">from</span> <span class="string">&quot;./component&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Fragment</span>, normalizeVNode, <span class="title class_">Text</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./vnode&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; shouldUpdateComponent &#125; <span class="keyword">from</span> <span class="string">&quot;./componentRenderUtils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createAppAPI &#125; <span class="keyword">from</span> <span class="string">&quot;./createApp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createRenderer</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="attr">createElement</span>: hostCreateElement,</span><br><span class="line">    <span class="attr">setElementText</span>: hostSetElementText,</span><br><span class="line">    <span class="attr">patchProp</span>: hostPatchProp,</span><br><span class="line">    <span class="attr">insert</span>: hostInsert,</span><br><span class="line">    <span class="attr">remove</span>: hostRemove,</span><br><span class="line">    <span class="attr">setText</span>: hostSetText,</span><br><span class="line">    <span class="attr">createText</span>: hostCreateText,</span><br><span class="line">  &#125; = options;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">render</span> = (<span class="params">vnode, container</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;调用 patch&quot;</span>)</span><br><span class="line">    <span class="title function_">patch</span>(<span class="literal">null</span>, vnode, container);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">patch</span>(<span class="params"></span></span><br><span class="line"><span class="params">    n1,</span></span><br><span class="line"><span class="params">    n2,</span></span><br><span class="line"><span class="params">    container = <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    anchor = <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    parentComponent = <span class="literal">null</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="comment">// 基于 n2 的类型来判断</span></span><br><span class="line">    <span class="comment">// 因为 n2 是新的 vnode</span></span><br><span class="line">    <span class="keyword">const</span> &#123; type, shapeFlag &#125; = n2;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">Text</span>:</span><br><span class="line">        <span class="title function_">processText</span>(n1, n2, container);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 其中还有几个类型比如： static fragment comment</span></span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">Fragment</span>:</span><br><span class="line">        <span class="title function_">processFragment</span>(n1, n2, container);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="comment">// 这里就基于 shapeFlag 来处理</span></span><br><span class="line">        <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ELEMENT</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;处理 element&quot;</span>);</span><br><span class="line">          <span class="title function_">processElement</span>(n1, n2, container, anchor, parentComponent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">STATEFUL_COMPONENT</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;处理 component&quot;</span>);</span><br><span class="line">          <span class="title function_">processComponent</span>(n1, n2, container, parentComponent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">processFragment</span>(<span class="params">n1: any, n2: any, container: any</span>) &#123;</span><br><span class="line">    <span class="comment">// 只需要渲染 children ，然后给添加到 container 内</span></span><br><span class="line">    <span class="keyword">if</span> (!n1) &#123;</span><br><span class="line">      <span class="comment">// 初始化 Fragment 逻辑点</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;初始化 Fragment 类型的节点&quot;</span>);</span><br><span class="line">      <span class="title function_">mountChildren</span>(n2.<span class="property">children</span>, container);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">processText</span>(<span class="params">n1, n2, container</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;处理 Text 节点&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (n1 === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// n1 是 null 说明是 init 的阶段</span></span><br><span class="line">      <span class="comment">// 基于 createText 创建出 text 节点，然后使用 insert 添加到 el 内</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;初始化 Text 类型的节点&quot;</span>);</span><br><span class="line">      <span class="title function_">hostInsert</span>((n2.<span class="property">el</span> = <span class="title function_">hostCreateText</span>(n2.<span class="property">children</span> <span class="keyword">as</span> string)), container);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// update</span></span><br><span class="line">      <span class="comment">// 先对比一下 updated 之后的内容是否和之前的不一样</span></span><br><span class="line">      <span class="comment">// 在不一样的时候才需要 update text</span></span><br><span class="line">      <span class="comment">// 这里抽离出来的接口是 setText</span></span><br><span class="line">      <span class="comment">// 注意，这里一定要记得把 n1.el 赋值给 n2.el, 不然后续是找不到值的</span></span><br><span class="line">      <span class="keyword">const</span> el = (n2.<span class="property">el</span> = n1.<span class="property">el</span>!);</span><br><span class="line">      <span class="keyword">if</span> (n2.<span class="property">children</span> !== n1.<span class="property">children</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;更新 Text 类型的节点&quot;</span>);</span><br><span class="line">        <span class="title function_">hostSetText</span>(el, n2.<span class="property">children</span> <span class="keyword">as</span> string);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">processElement</span>(<span class="params">n1, n2, container, anchor, parentComponent</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!n1) &#123;</span><br><span class="line">      <span class="title function_">mountElement</span>(n2, container, anchor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">      <span class="title function_">updateElement</span>(n1, n2, container, anchor, parentComponent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">updateElement</span>(<span class="params">n1, n2, container, anchor, parentComponent</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldProps = (n1 &amp;&amp; n1.<span class="property">props</span>) || &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> newProps = n2.<span class="property">props</span> || &#123;&#125;;</span><br><span class="line">    <span class="comment">// 应该更新 element</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;应该更新 element&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;旧的 vnode&quot;</span>, n1);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;新的 vnode&quot;</span>, n2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要把 el 挂载到新的 vnode</span></span><br><span class="line">    <span class="keyword">const</span> el = (n2.<span class="property">el</span> = n1.<span class="property">el</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比 props</span></span><br><span class="line">    <span class="title function_">patchProps</span>(el, oldProps, newProps);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比 children</span></span><br><span class="line">    <span class="title function_">patchChildren</span>(n1, n2, el, anchor, parentComponent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">patchProps</span>(<span class="params">el, oldProps, newProps</span>) &#123;</span><br><span class="line">    <span class="comment">// 对比 props 有以下几种情况</span></span><br><span class="line">    <span class="comment">// 1. oldProps 有，newProps 也有，但是 val 值变更了</span></span><br><span class="line">    <span class="comment">// 举个栗子</span></span><br><span class="line">    <span class="comment">// 之前: oldProps.id = 1 ，更新后：newProps.id = 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// key 存在 oldProps 里 也存在 newProps 内</span></span><br><span class="line">    <span class="comment">// 以 newProps 作为基准</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevProp = oldProps[key];</span><br><span class="line">      <span class="keyword">const</span> nextProp = newProps[key];</span><br><span class="line">      <span class="keyword">if</span> (prevProp !== nextProp) &#123;</span><br><span class="line">        <span class="comment">// 对比属性</span></span><br><span class="line">        <span class="comment">// 需要交给 host 来更新 key</span></span><br><span class="line">        <span class="title function_">hostPatchProp</span>(el, key, prevProp, nextProp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. oldProps 有，而 newProps 没有了</span></span><br><span class="line">    <span class="comment">// 之前： &#123;id:1,tId:2&#125;  更新后： &#123;id:1&#125;</span></span><br><span class="line">    <span class="comment">// 这种情况下我们就应该以 oldProps 作为基准，因为在 newProps 里面是没有的 tId 的</span></span><br><span class="line">    <span class="comment">// 还需要注意一点，如果这个 key 在 newProps 里面已经存在了，说明已经处理过了，就不要在处理了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevProp = oldProps[key];</span><br><span class="line">      <span class="keyword">const</span> nextProp = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (!(key <span class="keyword">in</span> newProps)) &#123;</span><br><span class="line">        <span class="comment">// 这里是以 oldProps 为基准来遍历，</span></span><br><span class="line">        <span class="comment">// 而且得到的值是 newProps 内没有的</span></span><br><span class="line">        <span class="comment">// 所以交给 host 更新的时候，把新的值设置为 null</span></span><br><span class="line">        <span class="title function_">hostPatchProp</span>(el, key, prevProp, nextProp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">patchChildren</span>(<span class="params">n1, n2, container, anchor, parentComponent</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">shapeFlag</span>: prevShapeFlag, <span class="attr">children</span>: c1 &#125; = n1;</span><br><span class="line">    <span class="keyword">const</span> &#123; shapeFlag, <span class="attr">children</span>: c2 &#125; = n2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 n2 的 children 是 text 类型的话</span></span><br><span class="line">    <span class="comment">// 就看看和之前的 n1 的 children 是不是一样的</span></span><br><span class="line">    <span class="comment">// 如果不一样的话直接重新设置一下 text 即可</span></span><br><span class="line">    <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">TEXT_CHILDREN</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c2 !== c1) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;类型为 text_children, 当前需要更新&quot;</span>);</span><br><span class="line">        <span class="title function_">hostSetElementText</span>(container, c2 <span class="keyword">as</span> string);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 看看之前的是不是 text</span></span><br><span class="line">      <span class="keyword">if</span> (prevShapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">TEXT_CHILDREN</span>) &#123;</span><br><span class="line">        <span class="comment">// 先清空</span></span><br><span class="line">        <span class="comment">// 然后在把新的 children 给 mount 生成 element</span></span><br><span class="line">        <span class="title function_">hostSetElementText</span>(container, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="title function_">mountChildren</span>(c2, container);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// array diff array</span></span><br><span class="line">      <span class="comment">// 如果之前是 array_children</span></span><br><span class="line">      <span class="comment">// 现在还是 array_children 的话</span></span><br><span class="line">      <span class="comment">// 那么我们就需要对比两个 children 啦</span></span><br><span class="line">        <span class="title function_">patchKeyedChildren</span>(c1, c2, container, parentComponent, anchor);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">patchKeyedChildren</span>(<span class="params"></span></span><br><span class="line"><span class="params">    c1: any[],</span></span><br><span class="line"><span class="params">    c2: any[],</span></span><br><span class="line"><span class="params">    container,</span></span><br><span class="line"><span class="params">    parentAnchor,</span></span><br><span class="line"><span class="params">    parentComponent</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">isSameVNodeType</span> = (<span class="params">n1, n2</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> n1.<span class="property">type</span> === n2.<span class="property">type</span> &amp;&amp; n1.<span class="property">key</span> === n2.<span class="property">key</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevChild = c1[i];</span><br><span class="line">      <span class="keyword">const</span> nextChild = c2[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isSameVNodeType</span>(prevChild, nextChild)) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;两个 child 不相等(从左往右比对)&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`prevChild:<span class="subst">$&#123;prevChild&#125;</span>`</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`nextChild:<span class="subst">$&#123;nextChild&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;两个 child 相等，接下来对比这两个 child 节点(从左往右比对)&quot;</span>);</span><br><span class="line">      <span class="title function_">patch</span>(prevChild, nextChild, container, parentAnchor, parentComponent);</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">      <span class="comment">// 从右向左取值</span></span><br><span class="line">      <span class="keyword">const</span> prevChild = c1[e1];</span><br><span class="line">      <span class="keyword">const</span> nextChild = c2[e2];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isSameVNodeType</span>(prevChild, nextChild)) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;两个 child 不相等(从右往左比对)&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`prevChild:<span class="subst">$&#123;prevChild&#125;</span>`</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`nextChild:<span class="subst">$&#123;nextChild&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;两个 child 相等，接下来对比这两个 child 节点(从右往左比对)&quot;</span>);</span><br><span class="line">      <span class="title function_">patch</span>(prevChild, nextChild, container, parentAnchor, parentComponent);</span><br><span class="line">      e1--;</span><br><span class="line">      e2--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt; e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">      <span class="comment">// 如果是这种情况的话就说明 e2 也就是新节点的数量大于旧节点的数量</span></span><br><span class="line">      <span class="comment">// 也就是说新增了 vnode</span></span><br><span class="line">      <span class="comment">// 应该循环 c2</span></span><br><span class="line">      <span class="comment">// 锚点的计算：新的节点有可能需要添加到尾部，也可能添加到头部，所以需要指定添加的问题</span></span><br><span class="line">      <span class="comment">// 要添加的位置是当前的位置(e2 开始)+1</span></span><br><span class="line">      <span class="comment">// 因为对于往左侧添加的话，应该获取到 c2 的第一个元素</span></span><br><span class="line">      <span class="comment">// 所以我们需要从 e2 + 1 取到锚点的位置</span></span><br><span class="line">      <span class="keyword">const</span> nextPos = e2 + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">const</span> anchor = nextPos &lt; l2 ? c2[nextPos].<span class="property">el</span> : parentAnchor;</span><br><span class="line">      <span class="keyword">while</span> (i &lt;= e2) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`需要新创建一个 vnode: <span class="subst">$&#123;c2[i].key&#125;</span>`</span>);</span><br><span class="line">        <span class="title function_">patch</span>(<span class="literal">null</span>, c2[i], container, anchor, parentComponent);</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2 &amp;&amp; i &lt;= e1) &#123;</span><br><span class="line">      <span class="comment">// 这种情况的话说明新节点的数量是小于旧节点的数量的</span></span><br><span class="line">      <span class="comment">// 那么我们就需要把多余的</span></span><br><span class="line">      <span class="keyword">while</span> (i &lt;= e1) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`需要删除当前的 vnode: <span class="subst">$&#123;c1[i].key&#125;</span>`</span>);</span><br><span class="line">        <span class="title function_">hostRemove</span>(c1[i].<span class="property">el</span>);</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 左右两边都比对完了，然后剩下的就是中间部位顺序变动的</span></span><br><span class="line">      <span class="comment">// 例如下面的情况</span></span><br><span class="line">      <span class="comment">// a,b,[c,d,e],f,g</span></span><br><span class="line">      <span class="comment">// a,b,[e,c,d],f,g</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> s1 = i;</span><br><span class="line">      <span class="keyword">let</span> s2 = i;</span><br><span class="line">      <span class="keyword">const</span> keyToNewIndexMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">      <span class="keyword">let</span> moved = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 先把 key 和 newIndex 绑定好，方便后续基于 key 找到 newIndex</span></span><br><span class="line">      <span class="comment">// 时间复杂度是 O(1)</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = s2; i &lt;= e2; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> nextChild = c2[i];</span><br><span class="line">        keyToNewIndexMap.<span class="title function_">set</span>(nextChild.<span class="property">key</span>, i);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 需要处理新节点的数量</span></span><br><span class="line">      <span class="keyword">const</span> toBePatched = e2 - s2 + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">let</span> patched = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 初始化 从新的index映射为老的index</span></span><br><span class="line">      <span class="comment">// 创建数组的时候给定数组的长度，这个是性能最快的写法</span></span><br><span class="line">      <span class="keyword">const</span> newIndexToOldIndexMap = <span class="keyword">new</span> <span class="title class_">Array</span>(toBePatched);</span><br><span class="line">      <span class="comment">// 初始化为 0 , 后面处理的时候 如果发现是 0 的话，那么就说明新值在老的里面不存在</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 遍历老节点</span></span><br><span class="line">      <span class="comment">// 1. 需要找出老节点有，而新节点没有的 -&gt; 需要把这个节点删除掉</span></span><br><span class="line">      <span class="comment">// 2. 新老节点都有的，—&gt; 需要 patch</span></span><br><span class="line">      <span class="keyword">for</span> (i = s1; i &lt;= e1; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> prevChild = c1[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化点</span></span><br><span class="line">        <span class="comment">// 如果老的节点大于新节点的数量的话，那么这里在处理老节点的时候就直接删除即可</span></span><br><span class="line">        <span class="keyword">if</span> (patched &gt;= toBePatched) &#123;</span><br><span class="line">          <span class="title function_">hostRemove</span>(prevChild.<span class="property">el</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> newIndex;</span><br><span class="line">        <span class="keyword">if</span> (prevChild.<span class="property">key</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 这里就可以通过key快速的查找了， 看看在新的里面这个节点存在不存在</span></span><br><span class="line">          <span class="comment">// 时间复杂度O(1)</span></span><br><span class="line">          newIndex = keyToNewIndexMap.<span class="title function_">get</span>(prevChild.<span class="property">key</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果没key 的话，那么只能是遍历所有的新节点来确定当前节点存在不存在了</span></span><br><span class="line">          <span class="comment">// 时间复杂度O(n)</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> j = s2; j &lt;= e2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(prevChild, c2[j])) &#123;</span><br><span class="line">              newIndex = j;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为有可能 nextIndex 的值为0（0也是正常值）</span></span><br><span class="line">        <span class="comment">// 所以需要通过值是不是 undefined 或者 null 来判断</span></span><br><span class="line">        <span class="keyword">if</span> (newIndex === <span class="literal">undefined</span>) &#123;</span><br><span class="line">          <span class="comment">// 当前节点的key 不存在于 newChildren 中，需要把当前节点给删除掉</span></span><br><span class="line">          <span class="title function_">hostRemove</span>(prevChild.<span class="property">el</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 新老节点都存在</span></span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;新老节点都存在&quot;</span>);</span><br><span class="line">          <span class="comment">// 把新节点的索引和老的节点的索引建立映射关系</span></span><br><span class="line">          <span class="comment">// i + 1 是因为 i 有可能是0 (0 的话会被认为新节点在老的节点中不存在)</span></span><br><span class="line">          newIndexToOldIndexMap[newIndex - s2] = i + <span class="number">1</span>;</span><br><span class="line">          <span class="comment">// 来确定中间的节点是不是需要移动</span></span><br><span class="line">          <span class="comment">// 新的 newIndex 如果一直是升序的话，那么就说明没有移动</span></span><br><span class="line">          <span class="comment">// 所以我们可以记录最后一个节点在新的里面的索引，然后看看是不是升序</span></span><br><span class="line">          <span class="comment">// 不是升序的话，我们就可以确定节点移动过了</span></span><br><span class="line">          <span class="keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class="line">            maxNewIndexSoFar = newIndex;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            moved = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="title function_">patch</span>(prevChild, c2[newIndex], container, <span class="literal">null</span>, parentComponent);</span><br><span class="line">          patched++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 利用最长递增子序列来优化移动逻辑</span></span><br><span class="line">      <span class="comment">// 因为元素是升序的话，那么这些元素就是不需要移动的</span></span><br><span class="line">      <span class="comment">// 而我们就可以通过最长递增子序列来获取到升序的列表</span></span><br><span class="line">      <span class="comment">// 在移动的时候我们去对比这个列表，如果对比上的话，就说明当前元素不需要移动</span></span><br><span class="line">      <span class="comment">// 通过 moved 来进行优化，如果没有移动过的话 那么就不需要执行算法</span></span><br><span class="line">      <span class="comment">// getSequence 返回的是 newIndexToOldIndexMap 的索引值</span></span><br><span class="line">      <span class="comment">// 所以后面我们可以直接遍历索引值来处理，也就是直接使用 toBePatched 即可</span></span><br><span class="line">      <span class="keyword">const</span> increasingNewIndexSequence = moved</span><br><span class="line">        ? <span class="title function_">getSequence</span>(newIndexToOldIndexMap)</span><br><span class="line">        : [];</span><br><span class="line">      <span class="keyword">let</span> j = increasingNewIndexSequence.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 遍历新节点</span></span><br><span class="line">      <span class="comment">// 1. 需要找出老节点没有，而新节点有的 -&gt; 需要把这个节点创建</span></span><br><span class="line">      <span class="comment">// 2. 最后需要移动一下位置，比如 [c,d,e] -&gt; [e,c,d]</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这里倒循环是因为在 insert 的时候，需要保证锚点是处理完的节点（也就是已经确定位置了）</span></span><br><span class="line">      <span class="comment">// 因为 insert 逻辑是使用的 insertBefore()</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = toBePatched - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 确定当前要处理的节点索引</span></span><br><span class="line">        <span class="keyword">const</span> nextIndex = s2 + i;</span><br><span class="line">        <span class="keyword">const</span> nextChild = c2[nextIndex];</span><br><span class="line">        <span class="comment">// 锚点等于当前节点索引+1</span></span><br><span class="line">        <span class="comment">// 也就是当前节点的后面一个节点(又因为是倒遍历，所以锚点是位置确定的节点)</span></span><br><span class="line">        <span class="keyword">const</span> anchor = nextIndex + <span class="number">1</span> &lt; l2 ? c2[nextIndex + <span class="number">1</span>].<span class="property">el</span> : parentAnchor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newIndexToOldIndexMap[i] === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 说明新节点在老的里面不存在</span></span><br><span class="line">          <span class="comment">// 需要创建</span></span><br><span class="line">          <span class="title function_">patch</span>(<span class="literal">null</span>, nextChild, container, anchor, parentComponent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (moved) &#123;</span><br><span class="line">          <span class="comment">// 需要移动</span></span><br><span class="line">          <span class="comment">// 1. j 已经没有了 说明剩下的都需要移动了</span></span><br><span class="line">          <span class="comment">// 2. 最长子序列里面的值和当前的值匹配不上， 说明当前元素需要移动</span></span><br><span class="line">          <span class="keyword">if</span> (j &lt; <span class="number">0</span> || increasingNewIndexSequence[j] !== i) &#123;</span><br><span class="line">            <span class="comment">// 移动的话使用 insert 即可</span></span><br><span class="line">            <span class="title function_">hostInsert</span>(nextChild.<span class="property">el</span>, container, anchor);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里就是命中了  index 和 最长递增子序列的值</span></span><br><span class="line">            <span class="comment">// 所以可以移动指针了</span></span><br><span class="line">            j--;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">mountElement</span>(<span class="params">vnode, container, anchor</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; shapeFlag, props &#125; = vnode;</span><br><span class="line">    <span class="comment">// 1. 先创建 element</span></span><br><span class="line">    <span class="comment">// 基于可扩展的渲染 api</span></span><br><span class="line">    <span class="keyword">const</span> el = (vnode.<span class="property">el</span> = <span class="title function_">hostCreateElement</span>(vnode.<span class="property">type</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持单子组件和多子组件的创建</span></span><br><span class="line">    <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">TEXT_CHILDREN</span>) &#123;</span><br><span class="line">      <span class="comment">// 举个栗子</span></span><br><span class="line">      <span class="comment">// render()&#123;</span></span><br><span class="line">      <span class="comment">//     return h(&quot;div&quot;,&#123;&#125;,&quot;test&quot;)</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="comment">// 这里 children 就是 test ，只需要渲染一下就完事了</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`处理文本:<span class="subst">$&#123;vnode.children&#125;</span>`</span>);</span><br><span class="line">      <span class="title function_">hostSetElementText</span>(el, vnode.<span class="property">children</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ARRAY_CHILDREN</span>) &#123;</span><br><span class="line">      <span class="comment">// 举个栗子</span></span><br><span class="line">      <span class="comment">// render()&#123;</span></span><br><span class="line">      <span class="comment">// Hello 是个 component</span></span><br><span class="line">      <span class="comment">//     return h(&quot;div&quot;,&#123;&#125;,[h(&quot;p&quot;),h(Hello)])</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="comment">// 这里 children 就是个数组了，就需要依次调用 patch 递归来处理</span></span><br><span class="line">      <span class="title function_">mountChildren</span>(vnode.<span class="property">children</span>, el);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 props</span></span><br><span class="line">    <span class="keyword">if</span> (props) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">        <span class="comment">// 需要过滤掉vue自身用的key</span></span><br><span class="line">        <span class="comment">// 比如生命周期相关的 key: beforeMount、mounted</span></span><br><span class="line">        <span class="keyword">const</span> nextVal = props[key];</span><br><span class="line">        <span class="title function_">hostPatchProp</span>(el, key, <span class="literal">null</span>, nextVal);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">    <span class="comment">// 触发 beforeMount() 钩子</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;vnodeHook  -&gt; onVnodeBeforeMount&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;DirectiveHook  -&gt; beforeMount&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;transition  -&gt; beforeEnter&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    <span class="title function_">hostInsert</span>(el, container, anchor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">    <span class="comment">// 触发 mounted() 钩子</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;vnodeHook  -&gt; onVnodeMounted&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;DirectiveHook  -&gt; mounted&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;transition  -&gt; enter&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">mountChildren</span>(<span class="params">children, container</span>) &#123;</span><br><span class="line">    children.<span class="title function_">forEach</span>(<span class="function">(<span class="params">VNodeChild</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">      <span class="comment">// 这里应该需要处理一下 vnodeChild</span></span><br><span class="line">      <span class="comment">// 因为有可能不是 vnode 类型</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;mountChildren:&quot;</span>, <span class="title class_">VNodeChild</span>);</span><br><span class="line">      <span class="title function_">patch</span>(<span class="literal">null</span>, <span class="title class_">VNodeChild</span>, container);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">processComponent</span>(<span class="params">n1, n2, container, parentComponent</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 n1 没有值的话，那么就是 mount</span></span><br><span class="line">    <span class="keyword">if</span> (!n1) &#123;</span><br><span class="line">      <span class="comment">// 初始化 component</span></span><br><span class="line">      <span class="title function_">mountComponent</span>(n2, container, parentComponent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">updateComponent</span>(n1, n2, container);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件的更新</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">updateComponent</span>(<span class="params">n1, n2, container</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;更新组件&quot;</span>, n1, n2);</span><br><span class="line">    <span class="comment">// 更新组件实例引用</span></span><br><span class="line">    <span class="keyword">const</span> instance = (n2.<span class="property">component</span> = n1.<span class="property">component</span>);</span><br><span class="line">    <span class="comment">// 先看看这个组件是否应该更新</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">shouldUpdateComponent</span>(n1, n2)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`组件需要更新: <span class="subst">$&#123;instance&#125;</span>`</span>);</span><br><span class="line">      <span class="comment">// 那么 next 就是新的 vnode 了（也就是 n2）</span></span><br><span class="line">      instance.<span class="property">next</span> = n2;</span><br><span class="line">      <span class="comment">// 这里的 update 是在 setupRenderEffect 里面初始化的，update 函数除了当内部的响应式对象发生改变的时候会调用</span></span><br><span class="line">      <span class="comment">// 还可以直接主动的调用(这是属于 effect 的特性)</span></span><br><span class="line">      <span class="comment">// 调用 update 再次更新调用 patch 逻辑</span></span><br><span class="line">      <span class="comment">// 在update 中调用的 next 就变成了 n2了</span></span><br><span class="line">      <span class="comment">// ps：可以详细的看看 update 中 next 的应用</span></span><br><span class="line">      <span class="comment">// TODO 需要在 update 中处理支持 next 的逻辑</span></span><br><span class="line">      instance.<span class="title function_">update</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`组件不需要更新: <span class="subst">$&#123;instance&#125;</span>`</span>);</span><br><span class="line">      <span class="comment">// 不需要更新的话，那么只需要覆盖下面的属性即可</span></span><br><span class="line">      n2.<span class="property">component</span> = n1.<span class="property">component</span>;</span><br><span class="line">      n2.<span class="property">el</span> = n1.<span class="property">el</span>;</span><br><span class="line">      instance.<span class="property">vnode</span> = n2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">mountComponent</span>(<span class="params">initialVNode, container, parentComponent</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 先创建一个 component instance</span></span><br><span class="line">    <span class="keyword">const</span> instance = (initialVNode.<span class="property">component</span> = <span class="title function_">createComponentInstance</span>(</span><br><span class="line">      initialVNode,</span><br><span class="line">      parentComponent</span><br><span class="line">    ));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`创建组件实例:<span class="subst">$&#123;instance.type.name&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// 2. 给 instance 加工加工</span></span><br><span class="line">    <span class="title function_">setupComponent</span>(instance);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">setupRenderEffect</span>(instance, initialVNode, container);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">setupRenderEffect</span>(<span class="params">instance, initialVNode, container</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 render</span></span><br><span class="line">    <span class="comment">// 应该传入 ctx 也就是 proxy</span></span><br><span class="line">    <span class="comment">// ctx 可以选择暴露给用户的 api</span></span><br><span class="line">    <span class="comment">// 源代码里面是调用的 renderComponentRoot 函数</span></span><br><span class="line">    <span class="comment">// 这里为了简化直接调用 render</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// obj.name  = &quot;111&quot;</span></span><br><span class="line">    <span class="comment">// obj.name = &quot;2222&quot;</span></span><br><span class="line">    <span class="comment">// 从哪里做一些事</span></span><br><span class="line">    <span class="comment">// 收集数据改变之后要做的事 (函数)</span></span><br><span class="line">    <span class="comment">// 依赖收集   effect 函数</span></span><br><span class="line">    <span class="comment">// 触发依赖</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">componentUpdateFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!instance.<span class="property">isMounted</span>) &#123;</span><br><span class="line">        <span class="comment">// 组件初始化的时候会执行这里</span></span><br><span class="line">        <span class="comment">// 为什么要在这里调用 render 函数呢</span></span><br><span class="line">        <span class="comment">// 是因为在 effect 内调用 render 才能触发依赖收集</span></span><br><span class="line">        <span class="comment">// 等到后面响应式的值变更后会再次触发这个函数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;instance.type.name&#125;</span>:调用 render,获取 subTree`</span>);</span><br><span class="line">        <span class="keyword">const</span> proxyToUse = instance.<span class="property">proxy</span>;</span><br><span class="line">        <span class="comment">// 可在 render 函数中通过 this 来使用 proxy</span></span><br><span class="line">        <span class="keyword">const</span> subTree = (instance.<span class="property">subTree</span> = <span class="title function_">normalizeVNode</span>(</span><br><span class="line">          instance.<span class="property">render</span>.<span class="title function_">call</span>(proxyToUse, proxyToUse)</span><br><span class="line">        ));</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;subTree&quot;</span>, subTree);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;instance.type.name&#125;</span>:触发 beforeMount hook`</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;instance.type.name&#125;</span>:触发 onVnodeBeforeMount hook`</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里基于 subTree 再次调用 patch</span></span><br><span class="line">        <span class="comment">// 基于 render 返回的 vnode ，再次进行渲染</span></span><br><span class="line">        <span class="comment">// 这里我把这个行为隐喻成开箱</span></span><br><span class="line">        <span class="comment">// 一个组件就是一个箱子</span></span><br><span class="line">        <span class="comment">// 里面有可能是 element （也就是可以直接渲染的）</span></span><br><span class="line">        <span class="comment">// 也有可能还是 component</span></span><br><span class="line">        <span class="comment">// 这里就是递归的开箱</span></span><br><span class="line">        <span class="comment">// 而 subTree 就是当前的这个箱子（组件）装的东西</span></span><br><span class="line">        <span class="comment">// 箱子（组件）只是个概念，它实际是不需要渲染的</span></span><br><span class="line">        <span class="comment">// 要渲染的是箱子里面的 subTree</span></span><br><span class="line">        <span class="title function_">patch</span>(<span class="literal">null</span>, subTree, container, <span class="literal">null</span>, instance);</span><br><span class="line">        <span class="comment">// 把 root element 赋值给 组件的vnode.el ，为后续调用 $el 的时候获取值</span></span><br><span class="line">        initialVNode.<span class="property">el</span> = subTree.<span class="property">el</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;instance.type.name&#125;</span>:触发 mounted hook`</span>);</span><br><span class="line">        instance.<span class="property">isMounted</span> = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 响应式的值变更后会从这里执行逻辑</span></span><br><span class="line">        <span class="comment">// 主要就是拿到新的 vnode ，然后和之前的 vnode 进行对比</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;instance.type.name&#125;</span>:调用更新逻辑`</span>);</span><br><span class="line">        <span class="comment">// 拿到最新的 subTree</span></span><br><span class="line">        <span class="keyword">const</span> &#123; next, vnode &#125; = instance;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有 next 的话， 说明需要更新组件的数据（props，slots 等）</span></span><br><span class="line">        <span class="comment">// 先更新组件的数据，然后更新完成后，在继续对比当前组件的子元素</span></span><br><span class="line">        <span class="keyword">if</span> (next) &#123;</span><br><span class="line">          <span class="comment">// 问题是 next 和 vnode 的区别是什么</span></span><br><span class="line">          next.<span class="property">el</span> = vnode.<span class="property">el</span>;</span><br><span class="line">          <span class="title function_">updateComponentPreRender</span>(instance, next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> proxyToUse = instance.<span class="property">proxy</span>;</span><br><span class="line">        <span class="keyword">const</span> nextTree = <span class="title function_">normalizeVNode</span>(</span><br><span class="line">          instance.<span class="property">render</span>.<span class="title function_">call</span>(proxyToUse, proxyToUse)</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 替换之前的 subTree</span></span><br><span class="line">        <span class="keyword">const</span> prevTree = instance.<span class="property">subTree</span>;</span><br><span class="line">        instance.<span class="property">subTree</span> = nextTree;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发 beforeUpdated hook</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;instance.type.name&#125;</span>:触发 beforeUpdated hook`</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;instance.type.name&#125;</span>:触发 onVnodeBeforeUpdate hook`</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用旧的 vnode 和新的 vnode 交给 patch 来处理</span></span><br><span class="line">        <span class="title function_">patch</span>(prevTree, nextTree, prevTree.<span class="property">el</span>, <span class="literal">null</span>, instance);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发 updated hook</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;instance.type.name&#125;</span>:触发 updated hook`</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;instance.type.name&#125;</span>:触发 onVnodeUpdated hook`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 vue3.2 版本里面是使用的 new ReactiveEffect</span></span><br><span class="line">    <span class="comment">// 至于为什么不直接用 effect ，是因为需要一个 scope  参数来收集所有的 effect</span></span><br><span class="line">    <span class="comment">// 而 effect 这个函数是对外的 api ，是不可以轻易改变参数的，所以会使用  new ReactiveEffect</span></span><br><span class="line">    <span class="comment">// 因为 ReactiveEffect 是内部对象，加一个参数是无所谓的</span></span><br><span class="line">    <span class="comment">// 后面如果要实现 scope 的逻辑的时候 需要改过来</span></span><br><span class="line">    <span class="comment">// 现在就先算了</span></span><br><span class="line">    instance.<span class="property">update</span> = <span class="title function_">effect</span>(componentUpdateFn, &#123;</span><br><span class="line">      <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 把 effect 推到微任务的时候在执行</span></span><br><span class="line">        <span class="comment">// queueJob(effect);</span></span><br><span class="line">        <span class="title function_">queueJob</span>(instance.<span class="property">update</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">updateComponentPreRender</span>(<span class="params">instance, nextVNode</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新 nextVNode 的组件实例</span></span><br><span class="line">    <span class="comment">// 现在 instance.vnode 是组件实例更新前的</span></span><br><span class="line">    <span class="comment">// 所以之前的 props 就是基于 instance.vnode.props 来获取</span></span><br><span class="line">    <span class="comment">// 接着需要更新 vnode ，方便下一次更新的时候获取到正确的值</span></span><br><span class="line">    nextVNode.<span class="property">component</span> = instance;</span><br><span class="line">    <span class="comment">// TODO 后面更新 props 的时候需要对比</span></span><br><span class="line">    <span class="comment">// const prevProps = instance.vnode.props;</span></span><br><span class="line">    instance.<span class="property">vnode</span> = nextVNode;</span><br><span class="line">    instance.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; props &#125; = nextVNode;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;更新组件的 props&quot;</span>, props);</span><br><span class="line">    instance.<span class="property">props</span> = props;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;更新组件的 slots&quot;</span>);</span><br><span class="line">    <span class="comment">// TODO 更新组件的 slots</span></span><br><span class="line">    <span class="comment">// 需要重置 vnode</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render,</span><br><span class="line">    <span class="attr">createApp</span>: <span class="title function_">createAppAPI</span>(render),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSequence</span>(<span class="params">arr: number[]</span>): number[] &#123;</span><br><span class="line">  <span class="keyword">const</span> p = arr.<span class="title function_">slice</span>();</span><br><span class="line">  <span class="keyword">const</span> result = [<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> i, j, u, v, c;</span><br><span class="line">  <span class="keyword">const</span> len = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> arrI = arr[i];</span><br><span class="line">    <span class="keyword">if</span> (arrI !== <span class="number">0</span>) &#123;</span><br><span class="line">      j = result[result.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arrI) &#123;</span><br><span class="line">        p[i] = j;</span><br><span class="line">        result.<span class="title function_">push</span>(i);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      u = <span class="number">0</span>;</span><br><span class="line">      v = result.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (u &lt; v) &#123;</span><br><span class="line">        c = (u + v) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[result[c]] &lt; arrI) &#123;</span><br><span class="line">          u = c + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          v = c;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (arrI &lt; arr[result[u]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          p[i] = result[u - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        result[u] = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  u = result.<span class="property">length</span>;</span><br><span class="line">  v = result[u - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span> (u-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    result[u] = v;</span><br><span class="line">    v = p[v];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript 前端 react.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3-reactive 浅谈</title>
      <link href="/2023/02/25/Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
      <url>/2023/02/25/Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue2-和-Vue3-响应式的区别"><a href="#Vue2-和-Vue3-响应式的区别" class="headerlink" title="Vue2 和 Vue3 响应式的区别"></a>Vue2 和 Vue3 响应式的区别</h3><p>Vue2 的响应式，利用了ES5的一个API，object.defineProperty,它的基本用法是这样的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;kw&#x27;</span>&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        obj[key] = val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样，就能拦截到对象属性的基本操作，比如访问属性和给属性设置新值。当拦截到访问属性时，可以做依赖收集；当监听到属性更改时，可以做派发更新，从而实现响应式。</p><p>它存在几个缺点：</p><ol><li><p>重写了对象的属性，性能较差；</p></li><li><p>只能拦截到对象属性的操作，不能处理数组。所以 Vue2 需要单独对数组数据进行处理。</p></li><li><p>对于属性的新增和删除，无法拦截到。所以额外提供了 $set 和 $delete 方法，整体不和谐。</p></li></ol><p><code>Vue3</code> 采用了 ES6 的API <code>Proxy</code> 来实现响应式。由于该 API 不兼容 IE 浏览器，所以在使用 Vue3 开发时要考虑项目是否需要兼容 IE系列。</p><h3 id="Proxy-和-Reflect"><a href="#Proxy-和-Reflect" class="headerlink" title="Proxy 和 Reflect"></a>Proxy 和 Reflect</h3><p>先来看看Proxy 的基本用法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target,handler);</span><br></pre></td></tr></table></figure><p><code>target</code>：用 <code>Proxy</code> 包装的被代理对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</p><p><code>handler</code>：是一个对象，其声明了代理 target 的一些操作，其属性是当执行一个操作时定义代理的行为的函数。</p><p>简单示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;未来软件工作室&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">      target[key] = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">​</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span>); <span class="comment">// &quot;未来软件工作室&quot;</span></span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">&#x27;未来大神&#x27;</span>  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span>); <span class="comment">// &quot;未来大神&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>Proxy</code> 的使用其实和 <code>Object.defineProperty</code>是差不多的，也是能拦截到对象属性的一些操作。但它的特点是：</p><ol><li><p>不仅可以代理普通的对象，还可以代理数组，函数</p></li><li><p>不仅能拦截到 <code>get</code> 和 <code>set</code> 操作，还支持 <code>apply、delete</code> 等一共13种操作</p></li><li><p>不需要重写 <code>target</code>，性能更高</p></li></ol><p>再来看一下 <code>Reflect</code> 对象<br><code>Proxy</code> 和 <code>Reflect</code> 是一对好兄弟，形影不离。</p><p>按照 MDN 文档的说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers的方法相同。</span><br><span class="line"></span><br><span class="line">Reflect不是一个函数对象，因此它是不可构造的。</span><br></pre></td></tr></table></figure><p>也就是说，我们在使用 <code>Proxy</code> 时传入的 <code>handler</code> 参数，它所有的属性，在 Reflect 中都有一一对应的。比如上面我们说了 <code>Proxy</code> 对象的 handler 可以支持 <code>get</code> ，<code>get</code> ，<code>apply</code>，<code>delete</code> 操作，那么 <code>Reflect</code> 对象就提供了对应的静态方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;未来软件工作室&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">sayHello</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello! 我是<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 返回 name 属性的值</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(person, <span class="string">&#x27;name&#x27;</span>); <span class="comment">// &#x27;未来软件工作室&#x27;</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">// 执行 sayHello 方法</span></span><br><span class="line"><span class="comment">// param1：要执行的函数</span></span><br><span class="line"><span class="comment">// param2：指定 this</span></span><br><span class="line"><span class="comment">// param3：函数执行需要的参数</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(person.<span class="property">sayHello</span>, person, []); <span class="comment">// Hello! 我是未来软件工作室</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">// 更新 age 属性。属性设置成功，返回 true</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(person, <span class="string">&#x27;age&#x27;</span>, <span class="number">20</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(person, <span class="string">&#x27;age&#x27;</span>); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>初看起来，Reflect 的使用很繁琐，远不如传统的点语法来的方便简洁。确实如此，但是在这些 API 的设计上，它和 Proxy 拥有一致的属性和方法，所以搭配起来更加合适。再者，有些场景下，比如需要用到 receiver 参数时，此时就只有 Reflect 能堪大任了。</p><h3 id="reactive的基本使用"><a href="#reactive的基本使用" class="headerlink" title="reactive的基本使用"></a>reactive的基本使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;kw&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">skill</span>: [<span class="string">&#x27;JS&#x27;</span>, <span class="string">&#x27;Vue&#x27;</span>]&#125;</span><br><span class="line"><span class="comment">// 返回对象的响应式代理对象，并且是深层次的代理，所有嵌套的属性包括数组，都能被代理到</span></span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(obj)</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 修改响应式对象，组件可以自动更新</span></span><br><span class="line">state.<span class="property">name</span> = <span class="string">&#x27;zk&#x27;</span></span><br><span class="line">state.<span class="property">age</span> = <span class="number">20</span></span><br><span class="line">state.<span class="property">skill</span>.<span class="title function_">push</span>(<span class="string">&#x27;Node&#x27;</span>)</span><br></pre></td></tr></table></figure><p>使用 <code>reactive</code> 时需要注意的地方：</p><ol><li>只能实现对象数据的响应式</li><li>同一个对象，只会被代理一次</li><li>被代理过的对象，不会被再次代理</li><li>支持嵌套属性的响应式</li></ol><h3 id="实现reactive"><a href="#实现reactive" class="headerlink" title="实现reactive"></a>实现reactive</h3><p>这是 Vue3 中一个最基础的响应式 API，它内部采用了 Proxy 来实现对象属性的拦截操作。</p><p>如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reactivity/src/reactive.ts</span></span><br><span class="line"><span class="comment">// reactivity/src/reactive.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; isObject &#125; <span class="keyword">from</span> <span class="string">&#x27;@my-vue/shared&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reactive</span> (target) &#123;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 只能代理对象</span></span><br><span class="line">  <span class="keyword">if</span>(!<span class="title function_">isObject</span>(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="comment">// 监听属性访问操作</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>属性被访问，依赖收集`</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key)</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 监听设置属性操作</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>属性变化了，派发更新`</span>)</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 当属性的新值和旧值不同时，再进行设置</span></span><br><span class="line">      <span class="keyword">if</span>(target[key] !== value) &#123;</span><br><span class="line">         <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);;</span><br><span class="line">         <span class="keyword">return</span> result</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 实例化代理对象</span></span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler)</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> proxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无需多次代理"><a href="#无需多次代理" class="headerlink" title="无需多次代理"></a>无需多次代理</h3><p>前面我们提到，如果一个对象被代理过了，就无需再被代理。实现的思路就是利用缓存，将代理过的对象进行缓存，每当调用 reactive 方法时，先判断缓存中是否存在 target ；每次 target 被代理后，都将 target 和 proxy 放到缓存中：  利用weakmap</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reactiveMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> readonlyMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"> <span class="keyword">if</span>(!<span class="title function_">isObject</span>(target))&#123;</span><br><span class="line">        <span class="keyword">return</span> target <span class="comment">//如果不是一个对象就直接返回出去</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//优化问题 如果已经代理过，则直接返回出去</span></span><br><span class="line">    <span class="keyword">const</span> proxymap= isReader ? <span class="attr">reactiveMap</span>:readonlyMap;</span><br><span class="line">    <span class="keyword">const</span> proxyes= proxymap.<span class="title function_">get</span>(target);</span><br><span class="line">    <span class="keyword">if</span>(proxyes)&#123;</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//核心如果是第一次添加 则添加代理，并且把target存进weakmap中,进行标记</span></span><br><span class="line">    <span class="keyword">const</span> proxy=<span class="keyword">new</span> <span class="title class_">Proxy</span>(target,baseHeader)</span><br><span class="line">    proxymap.<span class="title function_">set</span>(target,proxy);</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br></pre></td></tr></table></figure><h3 id="嵌套代理"><a href="#嵌套代理" class="headerlink" title="嵌套代理"></a>嵌套代理</h3><p>Vue3 实现响应式采用的原则是懒代理，并不像 Vue2 那样在初始化时，就递归所有的属性进行属性重写。<br>只有在访问到某个属性，且该属性是对象类型时，才会再进行一层响应式包装：<br>到此，我们实现的 reactive 方法，就能监听到对象属性的访问和设置操作，从而在此时机做一些处理，从而实现响应式系统。同时也做了一些优化处理。</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3笔记</title>
      <link href="/2023/02/14/Vue3%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/14/Vue3%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3快速上手"><a href="#Vue3快速上手" class="headerlink" title="Vue3快速上手"></a>Vue3快速上手</h1><img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px" />## 1.Vue3简介<ul><li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li><li>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a> </li><li>github上的tags地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li></ul><h2 id="2-Vue3带来了什么"><a href="#2-Vue3带来了什么" class="headerlink" title="2.Vue3带来了什么"></a>2.Vue3带来了什么</h2><h3 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h3><ul><li><p>打包大小减少41%</p></li><li><p>初次渲染快55%, 更新渲染快133%</p></li><li><p>内存减少54%</p><p>……</p></li></ul><h3 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h3><ul><li><p>使用Proxy代替defineProperty实现响应式</p></li><li><p>重写虚拟DOM的实现和Tree-Shaking</p><p>……</p></li></ul><h3 id="3-拥抱TypeScript"><a href="#3-拥抱TypeScript" class="headerlink" title="3.拥抱TypeScript"></a>3.拥抱TypeScript</h3><ul><li>Vue3可以更好的支持TypeScript</li></ul><h3 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h3><ol><li><p>Composition API（组合API）</p><ul><li>setup配置</li><li>ref与reactive</li><li>watch与watchEffect</li><li>provide与inject</li><li>……</li></ul></li><li><p>新的内置组件</p><ul><li>Fragment </li><li>Teleport</li><li>Suspense</li></ul></li><li><p>其他改变</p><ul><li>新的生命周期钩子</li><li>data 选项应始终被声明为一个函数</li><li>移除keyCode支持作为 v-on 的修饰符</li><li>……</li></ul></li></ol><h1 id="一、创建Vue3-0工程"><a href="#一、创建Vue3-0工程" class="headerlink" title="一、创建Vue3.0工程"></a>一、创建Vue3.0工程</h1><h2 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1.使用 vue-cli 创建"></a>1.使用 vue-cli 创建</h2><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span></span><br><span class="line">vue --version</span><br><span class="line"><span class="comment">## 安装或者升级你的@vue/cli</span></span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment">## 创建</span></span><br><span class="line">vue create vue_test</span><br><span class="line"><span class="comment">## 启动</span></span><br><span class="line"><span class="built_in">cd</span> vue_test</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><h2 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2.使用 vite 创建"></a>2.使用 vite 创建</h2><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p><p>vite官网：<a href="https://vitejs.cn/">https://vitejs.cn</a></p><ul><li>什么是vite？—— 新一代前端构建工具。</li><li>优势如下：<ul><li>开发环境中，无需打包操作，可快速的冷启动。</li><li>轻量快速的热重载（HMR）。</li><li>真正的按需编译，不再等待整个应用编译完成。</li></ul></li><li>传统构建 与 vite构建对比图</li></ul><p><img src="https://cn.vitejs.dev/assets/bundler.37740380.png" style="width:500px;height:280px;float:left" /><img src="https://cn.vitejs.dev/assets/esm.3070012d.png" style="width:480px;height:280px" /></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 创建工程</span></span><br><span class="line">npm init vite-app &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 进入工程目录</span></span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment">## 运行</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h1 id="二、常用-Composition-API"><a href="#二、常用-Composition-API" class="headerlink" title="二、常用 Composition API"></a>二、常用 Composition API</h1><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p><h2 id="1-拉开序幕的setup"><a href="#1-拉开序幕的setup" class="headerlink" title="1.拉开序幕的setup"></a>1.拉开序幕的setup</h2><ol><li>理解：Vue3.0中一个新的配置项，值为一个函数。</li><li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li><li>组件中所用到的：数据、方法等等，均要配置在setup中。</li><li>setup函数的两种返回值：<ol><li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li><li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li></ol></li><li>注意点：<ol><li>尽量不要与Vue2.x配置混用<ul><li>Vue2.x配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li><li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li><li>如果有重名, setup优先。</li></ul></li><li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li></ol></li></ol><h2 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2.ref函数"></a>2.ref函数</h2><ul><li>作用: 定义一个响应式的数据</li><li>语法: <code>const xxx = ref(initValue)</code> <ul><li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li><li>JS中操作数据： <code>xxx.value</code></li><li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li></ul></li><li>备注：<ul><li>接收的数据可以是：基本类型、也可以是对象类型。</li><li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li><li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li></ul></li></ul><h2 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3.reactive函数"></a>3.reactive函数</h2><ul><li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li><li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li><li>reactive定义的响应式数据是“深层次的”。</li><li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li></ul><h2 id="4-Vue3-0中的响应式原理"><a href="#4-Vue3-0中的响应式原理" class="headerlink" title="4.Vue3.0中的响应式原理"></a>4.Vue3.0中的响应式原理</h2><h3 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h3><ul><li><p>实现原理：</p><ul><li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p></li><li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">    get () &#123;&#125;, </span><br><span class="line">    set () &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>存在问题：</p><ul><li>新增属性、删除属性, 界面不会更新。</li><li>直接通过下标修改数组, 界面不会自动更新。</li></ul></li></ul><h3 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h3><ul><li>实现原理: <ul><li>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</li><li>通过Reflect（反射）:  对源对象的属性进行操作。</li><li>MDN文档中描述的Proxy与Reflect：<ul><li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p></li><li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line"><span class="comment">// 拦截读取属性值</span></span><br><span class="line">    get (target, prop) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截设置属性值或添加新属性</span></span><br><span class="line">    set (target, prop, value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截删除属性</span></span><br><span class="line">    deleteProperty (target, prop) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, prop)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">&#x27;tom&#x27;</span>   </span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h2><ul><li>从定义数据角度对比：<ul><li> ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li><li> reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li><li> 备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li></ul></li><li>从原理角度对比：<ul><li> ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li><li> reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li></ul></li><li>从使用角度对比：<ul><li> ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li><li> reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li></ul></li></ul><h2 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h2><ul><li>setup执行的时机<ul><li>在beforeCreate之前执行一次，this是undefined。</li></ul></li><li>setup的参数<ul><li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li><li>context：上下文对象<ul><li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li><li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li><li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li></ul></li></ul></li></ul><h2 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h2><h3 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h3><ul><li><p>与Vue2.x中computed配置功能一致</p></li><li><p>写法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;computed&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">//计算属性——简写</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//计算属性——完整</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(&#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> nameArr = value.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            person.<span class="property">firstName</span> = nameArr[<span class="number">0</span>]</span><br><span class="line">            person.<span class="property">lastName</span> = nameArr[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h3><ul><li><p>与Vue2.x中watch配置功能一致</p></li><li><p>两个小“坑”：</p><ul><li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li><li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情况一：监视ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>(sum,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：监视多个ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>([sum,msg],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum或msg变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 情况三：监视reactive定义的响应式数据</span></span><br><span class="line"><span class="comment">若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！</span></span><br><span class="line"><span class="comment">若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">watch</span>(person,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">false</span>&#125;) <span class="comment">//此处的deep配置不再奏效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况四：监视reactive定义的响应式数据中的某个属性</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">//情况五：监视reactive定义的响应式数据中的某些属性</span></span><br><span class="line"><span class="title function_">watch</span>([<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">()=&gt;</span>person.<span class="property">name</span>],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊情况</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;) <span class="comment">//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3.watchEffect函数"></a>3.watchEffect函数</h3><ul><li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p></li><li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p></li><li><p>watchEffect有点像computed：</p><ul><li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li><li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x1 = sum.<span class="property">value</span></span><br><span class="line">    <span class="keyword">const</span> x2 = person.<span class="property">age</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;watchEffect配置的回调执行了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h2><div style="border:1px solid black;width:380px;float:left;margin-right:20px;"><strong>vue2.x的生命周期</strong><img src="https://cn.vuejs.org/images/lifecycle.png" alt="lifecycle_2" style="zoom:33%;width:1200px" /></div><div style="border:1px solid black;width:510px;height:985px;float:left"><strong>vue3.0的生命周期</strong><img src="https://v3.cn.vuejs.org/images/lifecycle.svg" alt="lifecycle_2" style="zoom:33%;width:2500px" /></div><p>1</p><ul><li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul></li><li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul><li><code>beforeCreate</code>===&gt;<code>setup()</code></li><li><code>created</code>=======&gt;<code>setup()</code></li><li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li><li><code>mounted</code>=======&gt;<code>onMounted</code></li><li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li><li><code>updated</code> =======&gt;<code>onUpdated</code></li><li><code>beforeUnmount</code> ==&gt;<code>onBeforeUnmount</code></li><li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li></ul></li></ul><h2 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h2><ul><li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p></li><li><p>类似于vue2.x中的mixin。</p></li><li><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p></li></ul><h2 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h2><ul><li>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</li><li>语法：<code>const name = toRef(person,&#39;name&#39;)</code></li><li>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</li></ul><ul><li>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></li></ul><h1 id="三、其它-Composition-API"><a href="#三、其它-Composition-API" class="headerlink" title="三、其它 Composition API"></a>三、其它 Composition API</h1><h2 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h2><ul><li><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p></li><li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p></li><li><p>什么时候使用?</p><ul><li> 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li><li> 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li></ul></li></ul><h2 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h2><ul><li>readonly: 让一个响应式数据变为只读的（深只读）。</li><li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li><li>应用场景: 不希望数据被修改时。</li></ul><h2 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h2><ul><li>toRaw：<ul><li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li><li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li></ul></li><li>markRaw：<ul><li>作用：标记一个对象，使其永远不会再成为响应式对象。</li><li>应用场景:<ol><li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li><li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ol></li></ul></li></ul><h2 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h2><ul><li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p></li><li><p>实现防抖效果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;</span><br><span class="line">&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;ref,customRef&#125; from &#x27;vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;Demo&#x27;,</span><br><span class="line">setup()&#123;</span><br><span class="line">// let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref</span><br><span class="line">//自定义一个myRef</span><br><span class="line">function myRef(value,delay)&#123;</span><br><span class="line">let timer</span><br><span class="line">//通过customRef去实现自定义</span><br><span class="line">return customRef((track,trigger)=&gt;&#123;</span><br><span class="line">return&#123;</span><br><span class="line">get()&#123;</span><br><span class="line">track() //告诉Vue这个value值是需要被“追踪”的</span><br><span class="line">return value</span><br><span class="line">&#125;,</span><br><span class="line">set(newValue)&#123;</span><br><span class="line">clearTimeout(timer)</span><br><span class="line">timer = setTimeout(()=&gt;&#123;</span><br><span class="line">value = newValue</span><br><span class="line">trigger() //告诉Vue去更新界面</span><br><span class="line">&#125;,delay)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">let keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref</span><br><span class="line">return &#123;</span><br><span class="line">keyword</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h2><img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px" /><ul><li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p></li><li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p></li><li><p>具体写法：</p><ol><li><p>祖组件中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">let</span> car = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;奔驰&#x27;</span>,<span class="attr">price</span>:<span class="string">&#x27;40万&#x27;</span>&#125;)</span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;car&#x27;</span>,car)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后代组件中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params">props,context</span>)&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">const</span> car = <span class="title function_">inject</span>(<span class="string">&#x27;car&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;car&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h2><ul><li>isRef: 检查一个值是否为一个 ref 对象</li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h1 id="四、Composition-API-的优势"><a href="#四、Composition-API-的优势" class="headerlink" title="四、Composition API 的优势"></a>四、Composition API 的优势</h1><h2 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p><div style="width:600px;height:370px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left" /></div><div style="width:300px;height:370px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left" /> </div><h2 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><div style="width:500px;height:340px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><div style="width:430px;height:340px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><h1 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><ul><li>在Vue2中: 组件必须有一个根标签</li><li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li><li>好处: 减少标签层级, 减小内存占用</li></ul><h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><ul><li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;teleport to=&quot;移动位置&quot;&gt;</span><br><span class="line">&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;</span><br><span class="line">&lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">&lt;h3&gt;我是一个弹窗&lt;/h3&gt;</span><br><span class="line">&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><ul><li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p></li><li><p>使用步骤：</p><ul><li><p>异步引入组件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineAsyncComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span><span class="title function_">import</span>(<span class="string">&#x27;./components/Child.vue&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;app&quot;&gt;</span><br><span class="line">&lt;h3&gt;我是App组件&lt;/h3&gt;</span><br><span class="line">&lt;Suspense&gt;</span><br><span class="line">&lt;template v-slot:default&gt;</span><br><span class="line">&lt;Child/&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-slot:fallback&gt;</span><br><span class="line">&lt;h3&gt;加载中.....&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Suspense&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><ul><li><p>Vue 2.x 有许多全局 API 和配置。</p><ul><li><p>例如：注册全局组件、注册全局指令等。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册全局组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyButton&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册全局指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">inserted</span>: <span class="function"><span class="params">el</span> =&gt;</span> el.<span class="title function_">focus</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Vue3.0中对这些API做出了调整：</p><ul><li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><table><thead><tr><th>2.x 全局 API（<code>Vue</code>）</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong style="color:#DD5145">移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></li></ul></li></ul><h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><ul><li><p>data选项应始终被声明为一个函数。</p></li><li><p>过度类名的更改：</p><ul><li><p>Vue2.x写法</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.v-enter</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-leave</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Vue3.x写法</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.v-enter-from</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.v-leave-from</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p><ul><li><p>父组件中绑定事件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-on:close=&quot;handleComponentEvent&quot;</span><br><span class="line">  v-on:click=&quot;handleNativeClickEvent&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件中声明自定义事件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    emits: [&#x27;close&#x27;]</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote></li><li><p>……</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 javascript node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>错误日志1</title>
      <link href="/2023/02/13/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"/>
      <url>/2023/02/13/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="vue2中axios请求遇到的问题"><a href="#vue2中axios请求遇到的问题" class="headerlink" title="vue2中axios请求遇到的问题"></a>vue2中axios请求遇到的问题</h2><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20230213091759.png"><br>当请求是报出如图上错误时，有两种情况</p><ol><li>就是错误的把axios当作插件在全局注册</li><li>就是我范的错误，<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20230213170505.png"><br><code>把axios的配置项写错了也会造成这样的结果</code></li></ol><p>虽然是个小问题，但是耽误了我几个小时，写代码一定要规范起来</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 javascript node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本周学习笔记</title>
      <link href="/2023/02/13/%E5%81%87%E6%9C%9F%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2023/02/13/%E5%81%87%E6%9C%9F%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="假期总结"><a href="#假期总结" class="headerlink" title="假期总结"></a>假期总结</h2><ol><li>复习了Vue2的内容，然后做了一个半的项目，总得来说Vue2确实不错，相比Vue3还是差点意思，Vue3性能几乎翻倍，各种优化的非常好，但是Vue3毕竟出的时间不久，还是先从Vue2开始学习，弄懂vue2之后再进行vue3的学习，vue3在用法上与2做了少许改变， 学习周期短，</li><li>完成了小组招新，我是第九组，怎么说呢，真希望他们坚持久一点，小组真的是一个学习的好地方，机会只有一次，大一的学习热情非常浓厚，我应该向他们学习，我现在大二了，激情有点褪去了，加油，自己感兴趣的东西，努力不留遗憾</li></ol><h2 id="下阶段学习计划"><a href="#下阶段学习计划" class="headerlink" title="下阶段学习计划"></a>下阶段学习计划</h2><ol><li>还是以项目为主，多实践，然后使用vue3做点项目，提高自己的学习热情，加油</li></ol><h2 id="反思与总结，"><a href="#反思与总结，" class="headerlink" title="反思与总结，"></a>反思与总结，</h2><p>   多抓紧时间，</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 javascript node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git命令</title>
      <link href="/2023/02/05/git%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/02/05/git%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="导航-—-跳到之前的分支"><a href="#导航-—-跳到之前的分支" class="headerlink" title="导航 — 跳到之前的分支"></a>导航 — 跳到之前的分支</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git checkout -</span><br></pre></td></tr></table></figure><h2 id="查看历史"><a href="#查看历史" class="headerlink" title="查看历史"></a>查看历史</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 每个提交在一行内显示</span><br><span class="line">git log --oneline</span><br><span class="line"></span><br><span class="line"># 在所有提交日志中搜索包含「homepage」的提交</span><br><span class="line">git log --all --grep=<span class="string">&#x27;homepage&#x27;</span></span><br><span class="line"></span><br><span class="line"># 获取某人的提交日志</span><br><span class="line">git log --author=<span class="string">&quot;Maxence&quot;</span></span><br></pre></td></tr></table></figure><h3 id="回退操作"><a href="#回退操作" class="headerlink" title="回退操作"></a>回退操作</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 获取所有操作历史</span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line"># 重置到相应提交</span><br><span class="line">git reset <span class="variable constant_">HEAD</span>@&#123;<span class="number">4</span>&#125;</span><br><span class="line"># ……或者……</span><br><span class="line">git reset --hard &lt;提交的哈希值&gt;</span><br></pre></td></tr></table></figure><h3 id="清理仓库"><a href="#清理仓库" class="headerlink" title="清理仓库"></a>清理仓库</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git checkout master</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure><h3 id="查看我的分支与master的不同"><a href="#查看我的分支与master的不同" class="headerlink" title="查看我的分支与master的不同"></a>查看我的分支与master的不同</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git diff master..<span class="property">my</span>-branch</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写干净的JavaScript</title>
      <link href="/2023/01/16/%E7%BC%96%E5%86%99%E5%B9%B2%E5%87%80JavaScript/"/>
      <url>/2023/01/16/%E7%BC%96%E5%86%99%E5%B9%B2%E5%87%80JavaScript/</url>
      
        <content type="html"><![CDATA[<p>我们应该编写不言自明、易于理解、易于修改或易于扩展新功能的代码。因为代码常常需要被阅读，这就是为什么如此强调干净代码的原因。</p><p>我们的源代码可读性越强，则：</p><p>越容易维护<br>新开发人员理解代码所需的时间越少<br>越容易发现哪些代码可以重用<br>在这篇文章中，我将分享一些通用的干净编码原则以及一些特定于JavaScript的干净编码实践。</p><ol><li>命名<br>不要把命名变成猜谜游戏。变量和函数的名称最好能够揭示最初创建的意图。<br>如此一来，即使有新的开发人员加入团队，也不至于需要像看天书一样艰难地理解代码。<br>Bad 👎<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">30</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (y - x &gt;<span class="number">1990</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>Good 👍<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> userAge = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentYear = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (userAge &gt; <span class="number">30</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (currentYear - userAge &gt;<span class="number">1990</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>另外，不要在变量名或函数名中添加多余的不必要的字母。<br>Bad 👎</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nameValue;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">theProduct</span>(<span class="params"></span>);</span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">product</span>(<span class="params"></span>);</span><br></pre></td></tr></table></figure><ol><li>条件句<br>避免否定条件语句。否定语句通常比肯定语句更难理解。</li></ol><p>Bad 👎</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title function_">userExist</span>(user)) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">userExist</span>(user)) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>函数应该专注做单一一件事<br>函数的平均行数不应超过30行（不包括空格和注释）。函数越小，则越容易理解和重构。你可以用函数修改或查询某些内容，但不能同时修改或查询。</p></li><li><p>使用默认参数<br>使用默认参数而不是短路或条件语句。</p></li></ol><p>默认参数通常比短路更干净。请记住，在你使用默认参数的时候，函数将只为未定义的参数提供默认值。其他虚假值，例如 ‘’、””、false、null、0和NaN，不会被默认值替换。</p><p>Bad 👎</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getUserData</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> userName = userName || <span class="string">&quot;Patrick Collision&quot;</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getUserData</span>(<span class="params">name = <span class="string">&quot;Patrick Collision&quot;</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>单级抽象（SLA）<br>在编写函数时，如果你有多个抽象级别，那么函数通常会做不止一件事情。将一个大的函数分成多个函数会使其更具可重用性，并且测试起来更容易。</li></ol><p>Bad 👎</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkSomething</span>(<span class="params">statement</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">REGEXES</span> = [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> statements = statement.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> tokens = [];</span><br><span class="line">  <span class="variable constant_">REGEXES</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">REGEX</span> =&gt;</span> &#123;</span><br><span class="line">    statements.<span class="title function_">forEach</span>(<span class="function"><span class="params">statement</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> names= [];</span><br><span class="line">  tokens.<span class="title function_">forEach</span>(<span class="function"><span class="params">token</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// lex...</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  names.<span class="title function_">forEach</span>(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// parse...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkSomething</span>(<span class="params">statement</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> tokens = <span class="title function_">tokenize</span>(statement);</span><br><span class="line">  <span class="keyword">const</span> syntaxTree = <span class="title function_">parse</span>(tokens);</span><br><span class="line">  syntaxTree.<span class="title function_">forEach</span>(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// parse...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tokenize</span>(<span class="params">code</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">REGEXES</span> = [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> statements = code.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> tokens = [];</span><br><span class="line">  <span class="variable constant_">REGEXES</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">REGEX</span> =&gt;</span> &#123;</span><br><span class="line">    statements.<span class="title function_">forEach</span>(<span class="function"><span class="params">statement</span> =&gt;</span> &#123;</span><br><span class="line">      tokens.<span class="title function_">push</span>(<span class="comment">/* ... */</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">parse</span>(<span class="params">tokens</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> syntaxTree = [];</span><br><span class="line">  tokens.<span class="title function_">forEach</span>(<span class="function"><span class="params">token</span> =&gt;</span> &#123;</span><br><span class="line">    syntaxTree.<span class="title function_">push</span>(<span class="comment">/* ... */</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> syntaxTree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>不要忽略被捕获的异常<br>对捕获的异常错误不采取任何措施，即意味着不修复特定的错误也不对其做出反应。</li></ol><p>将错误记录到控制台(console.log)并没有好多少，因为记录经常会在控制台的其他内容中丢失。</p><p>如果你在try/catch中包装了哪怕一点点代码，也意味着你认为那里可能会发生错误，因此你应该对何时发生错误有一个计划。</p><p>Bad 👎</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">functionThatMightThrow</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">functionThatMightThrow</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="title function_">notifyUserOfError</span>(error);   </span><br><span class="line">  <span class="title function_">reportErrorToService</span>(error);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>尽量减少注释<br>仅注释具有业务逻辑复杂性的代码部分。</li></ol><p>注释不是必需的。好的代码大多数可以自我说明。</p><p>Bad 👎</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hashing</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// The hash</span></span><br><span class="line">  <span class="keyword">let</span> hash = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Length of string</span></span><br><span class="line">  <span class="keyword">const</span> length = data.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Loop through every character in data</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">// Get character code.</span></span><br><span class="line">    <span class="keyword">const</span> char = data.<span class="title function_">charCodeAt</span>(i);</span><br><span class="line">    <span class="comment">// Make the hash</span></span><br><span class="line">    hash = (hash &lt;&lt; <span class="number">5</span>) - hash + char;</span><br><span class="line">    <span class="comment">// Convert to 32-bit integer</span></span><br><span class="line">    hash &amp;= hash;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hashing</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> hash = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> length = data.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> char = data.<span class="title function_">charCodeAt</span>(i);</span><br><span class="line">    hash = (hash &lt;&lt; <span class="number">5</span>) - hash + char;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert to 32-bit integer</span></span><br><span class="line">    hash &amp;= hash;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>“多余的注释就是谎言和错误信息的垃圾桶。” ——Robert C. Martin</code><br>7. 移除注释掉的代码<br>不要在代码库中留下注释掉的代码，版本控制的存在是有原因的。将旧代码留在历史记录中。如果你需要的话，再从git历史记录中获取。</p><p>Bad 👎</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">doSomething</span>();</span><br><span class="line"><span class="comment">// doOtherStuff();</span></span><br><span class="line"><span class="comment">// doSomeMoreStuff();</span></span><br><span class="line"><span class="comment">// doSoMuchStuff();</span></span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">doSomething</span>();</span><br></pre></td></tr></table></figure><ol start="8"><li>只导入你需要的<br>ES6引入了解构。它可以将数组中的值或对象中的属性解包为不同的变量。你可以将其用于任何类型的对象或模块。</li></ol><p>例如，如果你只需要另一个模块中的add()和subtract()函数：<br>Bad 👎</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> calculate = <span class="built_in">require</span>(<span class="string">&#x27;./calculations&#x27;</span>)</span><br><span class="line"></span><br><span class="line">calculate.<span class="title function_">add</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line">calculate.<span class="title function_">subtract</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; add, subtract &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./calculations&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line"><span class="title function_">subtract</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>只导入需要在文件中使用的函数而不是整个模块，然后从中访问特定函数是有意义的。<br>9. 保持函数参数不超过3个（理想情况下）<br>限制函数参数的数量非常重要，因为这样可以更轻松地测试函数。参数超过3个会导致需要测试大量不同的情况。</p><p>1-3个参数是最理想的情况，正常情况下，参数数量应避免任何超出此范围。</p><p>通常，如果你有三个以上的参数，那么说明函数要做的事情太多了，违反SRP（单一职责原则）。<br>10. 使用数组展开来复制数组<br>Bad 👎</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> len = items.<span class="property">length</span>;</span><br><span class="line"><span class="keyword">const</span> itemsCopy = [];</span><br><span class="line"><span class="keyword">let</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i += <span class="number">1</span>) &#123;</span><br><span class="line">  itemsCopy[i] = items[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> itemsCopy = [...items];</span><br></pre></td></tr></table></figure><ol start="11"><li>写线性代码<br>嵌套的代码很难理解。所以我们应该尽可能地编写线性代码，这样的代码简单、干净、易于阅读和维护，使开发人员的工作更轻松。</li></ol><p>例如，在回调上使用promise可以大大提高可读性。<br>12. 使用ESLint和Prettier<br>始终使用ESLint和Prettier来强制跨团队和开发人员使用通用的编码风格。</p><p>还可以尝试使用JavaScript的最新功能来编写代码，例如解构、展开运算符、异步等待、模板字面量、可选链等等。<br>13. 适当使用括号<br>使用运算符时，请将它们括在括号中。唯一的例外是标准算术运算符：+、- 和 *<em>，因为它们的优先级被广泛理解。强烈建议将 /、</em> 和 % 括在括号中，因为当它们一起使用时，其优先级可能会引起困惑。</p><p>这不但提高了可读性，而且阐明了开发人员的意图。</p><p>Bad 👎</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = a &amp;&amp; b &lt; <span class="number">0</span> || c &gt; <span class="number">0</span> || d + <span class="number">1</span> === <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a || b &amp;&amp; c) &#123;</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = (a &amp;&amp; b &lt; <span class="number">0</span>) || c &gt; <span class="number">0</span> || (d + <span class="number">1</span> === <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a || (b &amp;&amp; c)) &#123;</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>14.早早地从函数中返回<br>为避免if语句的深层嵌套，始终尽可能早地返回函数的值。</p><p>Bad 👎</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPercentage</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (val &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; <span class="number">100</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPercentage</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (val &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个特殊的例子甚至可以进一步改进：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPercentage</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> isInRange = (val &gt;= <span class="number">0</span> &amp;&amp; val &lt;= <span class="number">100</span>);</span><br><span class="line">  <span class="keyword">return</span> isInRange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，同样的事情也可以应用于循环。</p><p>大的循环肯定会消耗大量时间。这就是为什么你应该尽可能早地跳出循环。</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域问题</title>
      <link href="/2022/12/11/CORS/"/>
      <url>/2022/12/11/CORS/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h3><p>浏览器有一个重要的安全策略，称之为[同源策略]<br>其中，源=协议+主机+端口源=协议+主机+端口源=协议+主机+端口，两个源相同，称之为同源，两个源不同，称之为跨源或跨域。</p><p>比如：<br>|  源 1   | 源 2  | 是否同源 |<br>|  —-  | —-  |—-|<br>| <a href="http://www.baidu.com/">www.baidu.com</a>  | <a href="http://www.baidu.com/news">www.baidu.com/news</a> | 是  |<br>| <a href="http://www.baidu.com/">http://www.baidu.com</a>  | <a href="https://www.baidu.com/">https://www.baidu.com</a> | 否   |<br>| <a href="http://localhost:5000/">http://localhost:5000</a>  | <a href="http://localhost:7000/">http://localhost:7000</a> | 否   |<br>| <a href="http://localhost:5000/">http://localhost:5000</a>  | <a href="http://127.0.0.1:5000/">http://127.0.0.1:5000</a> | 否   |<br>| <a href="http://www.baidu.com/">www.baidu.com</a>  | baidu.com | 否   |<br>同源策略是指，若页面的源和页面运行过程中加载的源不一致时，出于安全考虑，浏览器会对跨域的资源访问进行一些限制<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221211093517.jpg"><br>同源策略对 ajax 的跨域限制的最为_凶狠_，默认情况下，它不允许 ajax 访问跨域资源<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221211093619.jpg"><br>所以，我们通常所说的跨域问题，就是同源策略对 ajax 产生的影响<br>有多种方式解决跨域问题，常见的有：</p><ul><li>代理，常用</li><li>CORS，常用</li><li>JSONP<br>无论使用哪一种方式，都是要让浏览器知道，我这次跨域请求的是自己人，就不要拦截了。<h3 id="跨域解决办法1-代理"><a href="#跨域解决办法1-代理" class="headerlink" title="跨域解决办法1-代理"></a>跨域解决办法1-代理</h3>对于前端开发而言，大部分的跨域问题，都是通过代理解决的</li></ul><p>代理适用的场景是：生产环境不发生跨域，但开发环境发生跨域</p><p>因此，只需要在开发环境使用代理解决跨域即可，这种代理又称之为开发代理<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221211093737.jpg"></p><p>在实际开发中，只需要对开发服务器稍加配置即可完成</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue 的开发服务器代理配置</span></span><br><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123; <span class="comment">// 配置开发服务器</span></span><br><span class="line">    <span class="attr">proxy</span>: &#123; <span class="comment">// 配置代理</span></span><br><span class="line">      <span class="string">&quot;/api&quot;</span>: &#123; <span class="comment">// 若请求路径以 /api 开头</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&quot;http://dev.taobao.com&quot;</span>, <span class="comment">// 将其转发到 http://dev.taobao.com</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解决跨域问题方法2-JSONP"><a href="#解决跨域问题方法2-JSONP" class="headerlink" title="解决跨域问题方法2-JSONP"></a>解决跨域问题方法2-JSONP</h3><p>在CORS出现之前，人们想了一种奇妙的办法来实现跨域，这就是JSONP。<br>要实现JSONP，需要浏览器和服务器来一个天衣无缝的绝妙配合。<br>JSONP的做法是：当需要跨域请求时，不使用AJAX，转而生成一个script元素去请求服务器，由于浏览器并不阻止script元素的请求，这样请求可以到达服务器。服务器拿到请求后，响应一段JS代码，这段代码实际上是一个函数调用，调用的是客户端预先生成好的函数，并把浏览器需要的数据作为参数传递到函数中，从而间接的把数据传递给客户端</p><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221211094003.jpg"></p><h3 id="跨域解决方法3-CORS"><a href="#跨域解决方法3-CORS" class="headerlink" title="跨域解决方法3-CORS"></a>跨域解决方法3-CORS</h3><p>CORS是基于http1.1的一种跨域解决方案，它的全称是Cross-Origin Resource Sharing，跨域资源共享。<br>它的总体思路是：如果浏览器要跨域访问服务器的资源，需要获得服务器的允许<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221211094034.jpg"><br>而要知道，一个请求可以附带很多信息，从而会对服务器造成不同程度的影响</p><p>比如有的请求只是获取一些新闻，有的请求会改动服务器的数据</p><p>针对不同的请求，CORS 规定了三种不同的交互模式，分别是：</p><ul><li>简单请求</li><li>需要预检的请求</li><li>附带身份凭证的请求<br>这三种模式从上到下层层递进，请求可以做的事越来越多，要求也越来越严格。<br>下面分别说明三种请求模式的具体规范。</li></ul><p><code>简单请求</code><br>当浏览器端运行了一段 ajax 代码（无论是使用 XMLHttpRequest 还是 fetch api），浏览器会首先判断它属于哪一种请求模式</p><h3 id="简单请求的判定"><a href="#简单请求的判定" class="headerlink" title="简单请求的判定"></a>简单请求的判定</h3><p>当请求同时满足以下条件时，浏览器会认为它是一个简单请求：</p><ol><li>求方法属于下面的一种：</li></ol><ul><li>get</li><li>post</li><li>head</li></ul><ol start="2"><li>请求头仅包含安全的字段，常见的安全字段如下：</li></ol><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type</li><li>DPR</li><li>DownLink</li><li>Save-Data</li><li>Viewport-Width</li><li>Width</li></ul><ol start="3"><li>请求头如果包含Content-Type，仅限下面的值之一：</li></ol><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded<br><code>如果以上三个条件同时满足，浏览器判定为简单请求。</code><h3 id="简单请求的交互规范"><a href="#简单请求的交互规范" class="headerlink" title="简单请求的交互规范"></a>简单请求的交互规范</h3>当浏览器判定某个ajax 跨域请求是简单请求时，会发生以下的事情</li></ul><ol><li>求头中会自动添加Origin字段<br>比如，在页面<code>http://my.com/index.html</code>中有以下代码造成了跨域<br>fetch(‘<a href="http://crossdomain.com/api/news&#39;">http://crossdomain.com/api/news&#39;</a>);<br>请求发出后，请求头会是下面的格式：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /api/news/ <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: crossdomain.<span class="property">com</span></span><br><span class="line"><span class="title class_">Connection</span>: keep-alive</span><br><span class="line">...</span><br><span class="line"><span class="title class_">Referer</span>: <span class="attr">http</span>:<span class="comment">//my.com/index.html</span></span><br><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//my.com</span></span><br></pre></td></tr></table></figure>看到最后一行没，Origin字段会告诉服务器，是哪个源地址在跨域请求</li><li>服务器响应头中应包含Access-Control-Allow-Origin<br>当服务器收到请求后，如果允许该请求跨域访问，需要在响应头中添加Access-Control-Allow-Origin字段<br>该字段的值可以是：</li></ol><ul><li>*：表示我很开放，什么人我都允许访问</li><li>具体的源：比如<a href="http://my.com,表示我就允许你访问/">http://my.com，表示我就允许你访问</a><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实际上，这两个值对于客户端http://my.com而言，都一样，因为客户端才不会管其他源服务器允不允许，就关心自己是否被允许</span><br><span class="line"></span><br><span class="line">当然，服务器也可以维护一个可被允许的源列表，如果请求的Origin命中该列表，才响应*或具体的源</span><br><span class="line"></span><br><span class="line">为了避免后续的麻烦，强烈推荐响应具体的源</span><br></pre></td></tr></table></figure>假设服务器做出了以下的响应：<br>``HTTP/1.1 200 OK<br>Date: Tue, 21 Apr 2020 08:03:35 GMT<br>…<br>Access-Control-Allow-Origin: <a href="http://my.com/">http://my.com</a><br>…</li></ul><p>消息体中的数据<br><code>当浏览器看到服务器允许自己访问后，高兴的像一个两百斤的孩子，于是，它就把响应顺利的交给 js，以完成后续的操作 下图简述了整个交互过程 ![](https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/微信图片_20221211094943.jpg)</code>简单的请求对服务器的威胁不大，所以允许使用上述的简单交互即可完成。``<br>但是，如果浏览器不认为这是一种简单请求，就会按照下面的流程进行：</p><ul><li>浏览器发送预检请求，询问服务器是否允许</li><li>服务器允许</li><li>浏览器发送真实请求</li><li>服务器完成真实的响应<br>比如，在页面<code>http://my.com/index.html</code>中有以下代码造成了跨域<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://crossdomain.com/api/user&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="comment">// post 请求</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;袁小进&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;), <span class="comment">// 设置请求体</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>浏览器发现它不是一个简单请求，则会按照下面的流程与服务器交互</p><ol><li><strong>浏览器发送预检请求，询问服务器是否允许</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPTIONS /api/user HTTP/1.1</span><br><span class="line">Host: crossdomain.com</span><br><span class="line">...</span><br><span class="line">Origin: http://my.com</span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: a, b, content-type</span><br></pre></td></tr></table></figure><p>可以看出，这并非我们想要发出的真实请求，请求中不包含我们的请求头，也没有消息体。</p><p>这是一个预检请求，它的目的是询问服务器，是否允许后续的真实请求。</p><p>预检请求没有请求体，它包含了后续真实请求要做的事情<br>预检请求有以下特征：</p><ul><li>请求方法为OPTIONS</li><li>没有请求体</li><li>请求头中包含<ul><li>请求方法为OPTIONS<br>没有请求体<br>请求头中包含</li><li>Access-Control-Request-Method：后续的真实请求将使用的请求方法</li><li>Access-Control-Request-Headers：后续的真实请求会改动的请求头</li></ul></li></ul><ol start="2"><li>服务器允许<br>服务器收到预检请求后，可以检查预检请求中包含的信息，如果允许这样的请求，需要响应下面的消息格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 21 Apr 2020 08:03:35 GMT</span><br><span class="line">...</span><br><span class="line">Access-Control-Allow-Origin: http://my.com</span><br><span class="line">Access-Control-Allow-Methods: POST</span><br><span class="line">Access-Control-Allow-Headers: a, b, content-type</span><br><span class="line">Access-Control-Max-Age: 86400</span><br><span class="line">...</span><br></pre></td></tr></table></figure>对于预检请求，不需要响应任何的消息体，只需要在响应头中添加：</li></ol><ul><li>Access-Control-Allow-Origin：和简单请求一样，表示允许的源</li><li>Access-Control-Allow-Methods：表示允许的后续真实的请求方法</li><li>Access-Control-Allow-Headers：表示允许改动的请求头</li><li>Access-Control-Max-Age：告诉浏览器，多少秒内，对于同样的请求源、方法、头，都不需要再发送预检请求了</li></ul><ol start="3"><li>浏览器发送真实请求<br>预检被服务器允许后，浏览器就会发送真实请求了，上面的代码会发生下面的请求数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /api/user HTTP/1.1</span><br><span class="line">Host: crossdomain.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">...</span><br><span class="line">Referer: http://my.com/index.html</span><br><span class="line">Origin: http://my.com</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;: &quot;xiaoming&quot;, &quot;age&quot;: 18 &#125;</span><br></pre></td></tr></table></figure></li><li>服务器响应真实请求<figure class="highlight plaintext"><figcaption><span>200 OK</span></figcaption><table><tr><td class="code"><pre><span class="line">Date: Tue, 21 Apr 2020 08:03:35 GMT</span><br><span class="line">...</span><br><span class="line">Access-Control-Allow-Origin: http://my.com</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">添加用户成功</span><br></pre></td></tr></table></figure></li></ol><p>可以看出，当完成预检之后，后续的处理与简单请求相同<br>下图简述了整个交互过程<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221211095559.jpg"></p><p><code>一个额外的补充</code><br>在跨域访问时，JS 只能拿到一些最基本的响应头，如：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。<br><code>Access-Control-Expose-Headers</code>头让服务器把允许浏览器访问的头放入白名单，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access-Control-Expose-Headers: authorization, a, b</span><br></pre></td></tr></table></figure><h3 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h3><p>本周主要还是以考试复习为重，学习了CORS关于跨域的产生和解决办法</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七个JavaScript的简写方法</title>
      <link href="/2022/12/03/%E4%B8%83%E4%B8%AAJavascript%E7%9A%84%E7%AE%80%E5%86%99%E6%96%B9%E6%B3%95/"/>
      <url>/2022/12/03/%E4%B8%83%E4%B8%AAJavascript%E7%9A%84%E7%AE%80%E5%86%99%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="多字符串检查"><a href="#多字符串检查" class="headerlink" title="多字符串检查"></a>多字符串检查</h3><p>通常，如果我们需要检查字符串是否等于多个值中的一个，往往很快就会觉得疲惫不堪，性欲的是，JavaScript有一个内置方法帮助你解决这个问题</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isVowel</span> = (<span class="params">letter</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    letter === <span class="string">&quot;a&quot;</span> ||</span><br><span class="line">    letter === <span class="string">&quot;e&quot;</span> ||</span><br><span class="line">    letter === <span class="string">&quot;i&quot;</span> ||</span><br><span class="line">    letter === <span class="string">&quot;o&quot;</span> ||</span><br><span class="line">    letter === <span class="string">&quot;u&quot;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写方法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isVowel</span> = (<span class="params">letter</span>) =&gt;</span><br><span class="line">  [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;u&quot;</span>].<span class="title function_">includes</span>(letter);</span><br></pre></td></tr></table></figure><h3 id="For-of和For-in循环"><a href="#For-of和For-in循环" class="headerlink" title="For-of和For-in循环"></a>For-of和For-in循环</h3><p>For-of和For-in循环是迭代array或object的好方法，因为无需手动跟踪object键的索引。</p><ol><li>For-of<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> element = arr[i];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写方法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>For-in<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> key = keys[i];</span><br><span class="line">  <span class="keyword">const</span> value = obj[key];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写方法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="keyword">const</span> value = obj[key];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Falsey（假值）检查<br>如果要检查变量是null、undefined、0、false、NaN还是空string，可以使用逻辑非 (!)运算符一次检查所有变量，而无需编写多个条件。这使得检查变量是否包含有效数据变得相对容易多了。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isFalsey</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    value === <span class="literal">null</span> ||</span><br><span class="line">    value === <span class="literal">undefined</span> ||</span><br><span class="line">    value === <span class="number">0</span> ||</span><br><span class="line">    value === <span class="literal">false</span> ||</span><br><span class="line">    value === <span class="title class_">NaN</span> ||</span><br><span class="line">    value === <span class="string">&quot;&quot;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写方法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isFalsey</span> = (<span class="params">value</span>) =&gt; !value;</span><br></pre></td></tr></table></figure><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3>作为JavaScript开发人员，你一定遇到过三元运算符。这是编写简洁if-else语句的好方法。但是，也可用来编写简洁的代码，甚至将它们链接起来来检查多个条件。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 普通写法</span><br><span class="line">let info;</span><br><span class="line">if (value &lt; minValue) &#123;</span><br><span class="line">  info = &quot;Value is too small&quot;;</span><br><span class="line">&#125; else if (value &gt; maxValue) &#123;</span><br><span class="line">  info = &quot;Value is too large&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  info = &quot;Value is in range&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 简写方法</span><br><span class="line">const info =</span><br><span class="line">  value &lt; minValue</span><br><span class="line">    ? &quot;Value is too small&quot;</span><br><span class="line">    : value &gt; maxValue ? &quot;Value is too large&quot; : &quot;Value is in range&quot;;</span><br></pre></td></tr></table></figure><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3>在三元运算符的帮助下，你还可以根据条件确定要调用哪个函数。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="title function_">f1</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="title function_">f2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写方法</span></span><br><span class="line">(condition ? f1 : f2)();</span><br></pre></td></tr></table></figure><h3 id="Switch简写"><a href="#Switch简写" class="headerlink" title="Switch简写"></a>Switch简写</h3>通常我们可以使用以键作为switch条件并将值作为返回值的对象来优化长switch语句。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dayNumber = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getDay</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="keyword">let</span> day;</span><br><span class="line"><span class="keyword">switch</span> (dayNumber) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    day = <span class="string">&quot;Sunday&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    day = <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    day = <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    day = <span class="string">&quot;Wednesday&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    day = <span class="string">&quot;Thursday&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    day = <span class="string">&quot;Friday&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    day = <span class="string">&quot;Saturday&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写方法</span></span><br><span class="line"><span class="keyword">const</span> days = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;Sunday&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;Monday&quot;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&quot;Tuesday&quot;</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">  <span class="number">4</span>: <span class="string">&quot;Thursday&quot;</span>,</span><br><span class="line">  <span class="number">5</span>: <span class="string">&quot;Friday&quot;</span>,</span><br><span class="line">  <span class="number">6</span>: <span class="string">&quot;Saturday&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> day = days[dayNumber];</span><br></pre></td></tr></table></figure><h3 id="回退值"><a href="#回退值" class="headerlink" title="回退值"></a>回退值</h3>||运算符可以为变量设置回退值。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="keyword">let</span> name;</span><br><span class="line"><span class="keyword">if</span> (user?.<span class="property">name</span>) &#123;</span><br><span class="line">  name = user.<span class="property">name</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;Anonymous&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写方法</span></span><br><span class="line"><span class="keyword">const</span> name = user?.<span class="property">name</span> || <span class="string">&quot;Anonymous&quot;</span>;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS对象复制</title>
      <link href="/2022/11/27/JS%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6/"/>
      <url>/2022/11/27/JS%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>我们知道，赋值运算符不会创建对象的副本，只会分配对它的引用，请看以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> copy = obj;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">a</span> = <span class="number">5</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy.<span class="property">a</span>);</span><br><span class="line"><span class="comment">// Result </span></span><br><span class="line"><span class="comment">// a = 5;</span></span><br></pre></td></tr></table></figure><p>obj变量是初始化的新对象的容器。copy变量指向同一个对象，并且是该对象的引用。所以基本上这个{ a: 1, b: 2, }对象是在说现在有两种方法可以访问我：通过obj变量或copy变量以任何一种方式传递给我，并且你通过这些方式对我所做的任何操作都会影响我。</p><p>此方法消除了任何形式的不变性，如果原始对象被代码的另一部分使用，可能会导致bug。</p><h2 id="复制对象的简单方法"><a href="#复制对象的简单方法" class="headerlink" title="复制对象的简单方法"></a>复制对象的简单方法</h2><p>复制对象的简单方法是遍历原始对象并一个接一个地复制每个属性。让我们看一下这段代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">copy</span>(<span class="params">mainObj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> objCopy = &#123;&#125;; <span class="comment">// objCopy will store a copy of the mainObj</span></span><br><span class="line">  <span class="keyword">let</span> key;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> mainObj) &#123;</span><br><span class="line">    objCopy[key] = mainObj[key]; <span class="comment">// copies each property to the objCopy object</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> objCopy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mainObj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">c</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">7</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">4</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">copy</span>(mainObj));</span><br></pre></td></tr></table></figure><p>但这里有几个问题：</p><ol><li>objCopy对象有一个新的Object.prototype方法，不同于mainObj对象的原型方法，这不是我们想要的。我们想要的是原始对象的精确副本。</li><li>不复制属性描述符。值设置为false的“可写”描述符在objCopy对象中将为true。<br>上面的代码只复制了mainObj的可枚举属性。</li><li>如果原始对象中的属性之一是对象本身，那么它将在副本和原始对象之间共享，使它们各自的属性指向同一个对象。<h2 id="浅拷贝对象"><a href="#浅拷贝对象" class="headerlink" title="浅拷贝对象"></a>浅拷贝对象</h2>当源顶层属性在没有任何引用的情况下被复制并且存在一个值为对象并被复制为引用的源属性时，就称该对象为浅拷贝。如果源值是对对象的引用，那么它只会将该引用值复制到目标对象。</li></ol><p>浅拷贝将复制顶层属性，但嵌套对象在原始（源）和副本（目标）之间共享.</p><h2 id="使用Object-assign-方法"><a href="#使用Object-assign-方法" class="headerlink" title="使用Object.assign()方法"></a>使用Object.assign()方法</h2><p>Object.assign()方法用于将所有可枚举自身属性的值从一个或多个源对象复制到目标对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> objCopy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objCopy);</span><br><span class="line"><span class="comment">// Result - &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure><p>到目前为止，我们制作了obj的副本。现在让我们看看是否存在不可变性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> objCopy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objCopy); <span class="comment">// result - &#123; a: 1, b: 2 &#125;</span></span><br><span class="line">objCopy.<span class="property">b</span> = <span class="number">89</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objCopy); <span class="comment">// result - &#123; a: 1, b: 89 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// result - &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure><p>上面的代码将objCopy对象中的属性b的值更改为89，当我们在控制台中记录修改后的objCopy对象时，更改仅应用于objCopy。最后一行代码检查obj对象是否仍然完整且未曾更改。如果是的话，意味着我们已经成功地创建了源对象的副本，而没有对其进行任何引用。</p><h3 id="Object-assign-的陷阱"><a href="#Object-assign-的陷阱" class="headerlink" title="Object.assign()的陷阱"></a>Object.assign()的陷阱</h3><p>虽然我们成功创建了副本，并且一切似乎都运行良好，但还记得我们讨论过浅拷贝吗？看一个例子：<br>let obj = {<br>  a: 1,<br>  b: {<br>    c: 2,<br>  },<br>}</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj); <span class="comment">// &#123; a: 1, b: &#123; c: 2&#125; &#125;</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">a</span> = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; a: 10, b: &#123; c: 2&#125; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj); <span class="comment">// &#123; a: 1, b: &#123; c: 2&#125; &#125;</span></span><br><span class="line"></span><br><span class="line">newObj.<span class="property">a</span> = <span class="number">20</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; a: 10, b: &#123; c: 2&#125; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj); <span class="comment">// &#123; a: 20, b: &#123; c: 2&#125; &#125;</span></span><br><span class="line"></span><br><span class="line">newObj.<span class="property">b</span>.<span class="property">c</span> = <span class="number">30</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; a: 10, b: &#123; c: 30&#125; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj); <span class="comment">// &#123; a: 20, b: &#123; c: 30&#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: newObj.b.c = 30; Read why..</span></span><br></pre></td></tr></table></figure><p>为什么obj.b.c = 30？<br>嗯，这是Object.assign()的一个陷阱。Object.assign只制作浅拷贝。newObj.b和obj.b两者共享对同一个对象的相同引用，因为没有制作单独的副本，而是复制了对同一个对象的引用。对那个对象的任何属性所做的任何更改都适用于使用该对象的所有引用。<br><code>注意：不能复制原型链上的属性和不可枚举的属性。</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someObj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(someObj, &#123; </span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">2</span>,  </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">c</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,  </span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objCopy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objCopy); <span class="comment">// &#123; c: 3 &#125;</span></span><br></pre></td></tr></table></figure><ol><li>someObj在obj的原型链上，所以它不会被复制。</li><li>属性b是不可枚举的属性。</li><li>属性c有一个可枚举的属性描述符，允许其成为可枚举。这就是属性c被复制的原因</li></ol><h3 id="深度拷贝对象"><a href="#深度拷贝对象" class="headerlink" title="深度拷贝对象"></a>深度拷贝对象</h3><p>深拷贝将复制它遇到的每个对象。副本和原始对象不会共享任何内容。下面是使用Object.assign()遇到的问题的解决方法。</p><h3 id="使用JSON-parse-JSON-stringify-object"><a href="#使用JSON-parse-JSON-stringify-object" class="headerlink" title="使用JSON.parse(JSON.stringify(object));"></a>使用JSON.parse(JSON.stringify(object));</h3><p>这解决了我们之前遇到的问题。现在newObj.b有一个副本而不是引用！这是一种深度复制对象的方法。请看例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; </span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123; </span><br><span class="line">    <span class="attr">c</span>: <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line"></span><br><span class="line">obj.<span class="property">b</span>.<span class="property">c</span> = <span class="number">20</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; a: 1, b: &#123; c: 20 &#125; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj); <span class="comment">// &#123; a: 1, b: &#123; c: 2 &#125; &#125; (New Object Intact!)</span></span><br></pre></td></tr></table></figure><p>陷阱<br>不幸的是，此方法不能用于复制用户定义的对象方法。</p><h3 id="复制对象方法"><a href="#复制对象方法" class="headerlink" title="复制对象方法"></a>复制对象方法</h3><p>到目前为止的示例中，我们还不能复制对象的方法。现在让我们尝试一下，如何来复制对象的方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;scotch.io&#x27;</span>,</span><br><span class="line">  <span class="attr">exec</span>: <span class="keyword">function</span> <span class="title function_">exec</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> method1 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"><span class="keyword">let</span> method2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(method1); <span class="comment">//Object.assign(&#123;&#125;, obj)</span></span><br><span class="line"><span class="comment">/* result</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  exec: function exec() &#123;</span></span><br><span class="line"><span class="comment">    return true;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  name: &quot;scotch.io&quot;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(method2); <span class="comment">// JSON.parse(JSON.stringify(obj))</span></span><br><span class="line"><span class="comment">/* result</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  name: &quot;scotch.io&quot;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>结果表明Object.assign()可以用来复制对象方法，而JSON.parse(JSON.stringify(obj))却不能。</p><h3 id="复制circular对象"><a href="#复制circular对象" class="headerlink" title="复制circular对象"></a>复制circular对象</h3><p>circular对象是具有引用自身属性的对象。让我们使用复制对象的方法来复制circular对象，看看它是否有效。</p><h3 id="使用JSON-parse-JSON-stringify-object-1"><a href="#使用JSON-parse-JSON-stringify-object-1" class="headerlink" title="使用JSON.parse(JSON.stringify(object))"></a>使用JSON.parse(JSON.stringify(object))</h3><p>先试试JSON.parse(JSON.stringify(object))：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// circular object</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; </span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123; </span><br><span class="line">    <span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">d</span>: <span class="string">&#x27;d&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">c</span> = obj.<span class="property">b</span>;</span><br><span class="line">obj.<span class="property">e</span> = obj.<span class="property">a</span>;</span><br><span class="line">obj.<span class="property">b</span>.<span class="property">c</span> = obj.<span class="property">c</span>;</span><br><span class="line">obj.<span class="property">b</span>.<span class="property">d</span> = obj.<span class="property">b</span>;</span><br><span class="line">obj.<span class="property">b</span>.<span class="property">e</span> = obj.<span class="property">b</span>.<span class="property">c</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj); </span><br></pre></td></tr></table></figure><p>结果：<br><code>JSON.parse(JSON.stringify(obj))</code>显然不适用于<code>circular</code>对象。</p><h3 id="使用Object-assign"><a href="#使用Object-assign" class="headerlink" title="使用Object.assign()"></a>使用Object.assign()</h3><p>再试试Object.assign()：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// circular object</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; </span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123; </span><br><span class="line">    <span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">d</span>: <span class="string">&#x27;d&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">c</span> = obj.<span class="property">b</span>;</span><br><span class="line">obj.<span class="property">e</span> = obj.<span class="property">a</span>;</span><br><span class="line">obj.<span class="property">b</span>.<span class="property">c</span> = obj.<span class="property">c</span>;</span><br><span class="line">obj.<span class="property">b</span>.<span class="property">d</span> = obj.<span class="property">b</span>;</span><br><span class="line">obj.<span class="property">b</span>.<span class="property">e</span> = obj.<span class="property">b</span>.<span class="property">c</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newObj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj2); </span><br></pre></td></tr></table></figure><p>结果：</p><p><code>Object.assign()</code>适用于浅拷贝<code>circular</code>对象，但不适用于深拷贝。</p><h3 id="使用展开运算符-…"><a href="#使用展开运算符-…" class="headerlink" title="使用展开运算符(…)"></a>使用展开运算符(…)</h3><p>ES6已经实现了用于数组解构赋值的rest元素和用于数组字面量的展开运算符。数组的展开运算符实现如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [</span><br><span class="line">  <span class="string">&quot;a&quot;</span>,</span><br><span class="line">  <span class="string">&quot;c&quot;</span>,</span><br><span class="line">  <span class="string">&quot;d&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">four</span>: <span class="number">4</span></span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> newArray = [...array];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArray);</span><br><span class="line"><span class="comment">// Result </span></span><br><span class="line"><span class="comment">// [&quot;a&quot;, &quot;c&quot;, &quot;d&quot;, &#123; four: 4 &#125;]</span></span><br></pre></td></tr></table></figure><p>对象初始值设定项中的扩展属性将自己的可枚举属性从源对象复制到目标对象。如果ECMAScript的Stage 3提案接受的话，那么复制对象变得非常容易：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">one</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">two</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newObj = &#123; ...obj &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; one: 1, two: 2 &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯云_宝塔面板部署hexo</title>
      <link href="/2022/11/20/hexo%E9%83%A8%E7%BD%B2/"/>
      <url>/2022/11/20/hexo%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul><li>已经搭建好 hexo 博客，并将 hexo 部署到 GitHub</li><li>已经购买好云服务器</li><li>已经购买好域名（没有的也可以用 IP 地址访问）</li></ul><h2 id="安装宝塔面板"><a href="#安装宝塔面板" class="headerlink" title="安装宝塔面板"></a>安装宝塔面板</h2><ul><li>可以在服务器预装系统选择 宝塔面板</li><li>或者对服务器进行重装系统<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20221120095748.png"><br>重装完成建议 重置一下服务器登录密码<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20221120100041.png"></li></ul><h2 id="进入腾讯云的控制台"><a href="#进入腾讯云的控制台" class="headerlink" title="进入腾讯云的控制台"></a>进入腾讯云的控制台</h2><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20221120100225.png"><br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20221120100345.png"><br>输入 <code>sudo /etc/init.d/bt default</code> 可以查看宝塔控制面板地址，<br>下方有账号密码，最好记录下来</p><p>进入宝塔 登录输入刚刚的账号密码<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20221120100753.png"><br>进入之后 直接点击一键安装默认推荐的软件<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/9b27621822492f5e864a38f1a14a4cfa.png"></p><h2 id="安装并配置-git-仓库"><a href="#安装并配置-git-仓库" class="headerlink" title="安装并配置 git 仓库"></a>安装并配置 git 仓库</h2><p>在远程服务器上配置好 Git 仓库后，才能将本地的 hexo push 到远端。</p><ol><li>打开服务器控制台<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20221120101422.png"><br>若当前账号不是 root 则通过<code>sudo su root</code>命令切换到 root</li><li>安装 git<br><code>yum install git</code></li><li>创建 Git 账户</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adduser git</span><br><span class="line">chmod 740 /etc/sudoers</span><br></pre></td></tr></table></figure><ol start="4"><li>编辑/etc/sudoers 文件</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/sudoers</span><br></pre></td></tr></table></figure><ol start="5"><li>按<code>i</code>键进入编辑模式, 找到 root ALL=(ALL) ALL 在其下方加入</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git     ALL=(ALL)     ALL</span><br></pre></td></tr></table></figure><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20221120101955.png"><br>输入完成后按<code>esc</code>，再输入<code>:wq</code>，保存退出</p><ol start="6"><li>更变/etc/sudoers 权限</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 400 /etc/sudoers</span><br></pre></td></tr></table></figure><ol start="7"><li>设置 git 账户密码</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo passwd git</span><br></pre></td></tr></table></figure><p>注意:<code>输入密码，输入的时候是看不到任何显示的，输完回车即可</code>。</p><ol start="8"><li>切换至 <code>git 用户</code>，创建<code>~/.ssh</code>文件夹和<code>~/.ssh/authorized_keys</code>文件</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su git</span><br><span class="line">mkdir ~/.ssh</span><br><span class="line">vim ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>同样 i 进入编辑模式，把之前本地准备的 id_rsa.pub 文件中的公钥复制进去，按 esc 后，输入:wq 保存。 9. 更改权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 600 /home/git/.ssh/authorized_keys</span><br><span class="line">chmod 700 /home/git/.ssh</span><br></pre></td></tr></table></figure><p>配置完成之后 接下来创建 Git 仓库</p><h2 id="创建-Git-仓库"><a href="#创建-Git-仓库" class="headerlink" title="创建 Git 仓库"></a>创建 Git 仓库</h2><p>在服务端控制台进行操作</p><ol><li>切换<code>root</code>用户</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su root</span><br></pre></td></tr></table></figure><ol start="2"><li>创建 repo 作为仓库目录，并加权限</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /var/repo</span><br><span class="line">chown -R git:git /var/repo</span><br><span class="line">chmod -R 755 /var/repo</span><br></pre></td></tr></table></figure><ol start="3"><li>创建 hexo 目录作为网站根目录</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /www/wwwroot/hexo</span><br><span class="line">chown -R git:git /www/wwwroot/hexo</span><br><span class="line">chmod -R 755 /www/wwwroot/hexo</span><br></pre></td></tr></table></figure><ol start="4"><li>创建一个空白的 git 仓库</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /var/repo</span><br><span class="line">git init --bare hexo.git</span><br></pre></td></tr></table></figure><ol start="5"><li>编辑一个 Git 钩子</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /var/repo/hexo.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>按<code>i</code>进入编辑模式，添加下面的代码，按<code>esc</code>输入<code>:wq</code> 保存</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">git --work-tree=/var/hexo --git-dir=/var/repo/hexo.git checkout -f</span><br></pre></td></tr></table></figure><ol start="6"><li>更改权限</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown -R git:git /var/repo/hexo.git/hooks/post-receive</span><br><span class="line">chmod +x /var/repo/hexo.git/hooks/post-receive</span><br></pre></td></tr></table></figure><h2 id="宝塔网站配置"><a href="#宝塔网站配置" class="headerlink" title="宝塔网站配置"></a>宝塔网站配置</h2><p>点击添加站点<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20221120103418.png"><br>配置<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20221120103313.png"><br>根目录 选择刚刚创建的 hexo 文件夹<br>点击提交</p><h2 id="本地推送"><a href="#本地推送" class="headerlink" title="本地推送"></a>本地推送</h2><p>在博客目录中配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@服务器ip或域名:/var/repo/hexo.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>配置完成后，可直接 hexo 三连到自己的服务器。简单快捷。</p><p>之后就能通过服务器 IP 地址，访问博客了 默认是 80 端口<br>所以直接输入服务器 IP 就能访问了</p>]]></content>
      
      
      <categories>
          
          <category> 记录&#39; </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2 笔记</title>
      <link href="/2022/11/08/Vue%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/08/Vue%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h2><pre><code>├── node_modules├── public│   ├── favicon.ico: 页签图标│   └── index.html: 主页面├── src│   ├── assets: 存放静态资源│   │   └── logo.png│   │── component: 存放组件│   │   └── HelloWorld.vue│   │── App.vue: 汇总所有组件│   │── main.js: 入口文件├── .gitignore: git版本管制忽略的配置├── babel.config.js: babel的配置文件├── package.json: 应用包配置文件├── README.md: 应用描述文件├── package-lock.json：包版本控制文件</code></pre><h2 id="关于不同版本的-Vue"><a href="#关于不同版本的-Vue" class="headerlink" title="关于不同版本的 Vue"></a>关于不同版本的 Vue</h2><ol><li>vue.js 与 vue.runtime.xxx.js 的区别：<ol><li>vue.js 是完整版的 Vue，包含：核心功能 + 模板解析器。</li><li>vue.runtime.xxx.js 是运行版的 Vue，只包含：核心功能；没有模板解析器。</li></ol></li><li>因为 vue.runtime.xxx.js 没有模板解析器，所以不能使用 template 这个配置项，需要使用 render 函数接收到的 createElement 函数去指定具体内容。</li></ol><h2 id="vue-config-js-配置文件"><a href="#vue-config-js-配置文件" class="headerlink" title="vue.config.js 配置文件"></a>vue.config.js 配置文件</h2><ol><li>使用 vue inspect &gt; output.js 可以查看到 Vue 脚手架的默认配置。</li><li>使用 vue.config.js 可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></li></ol><h2 id="ref-属性"><a href="#ref-属性" class="headerlink" title="ref 属性"></a>ref 属性</h2><ol><li>被用来给元素或子组件注册引用信息（id 的替代者）</li><li>应用在 html 标签上获取的是真实 DOM 元素，应用在组件标签上是组件实例对象（vc）</li><li>使用方式：<ol><li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li><li>获取：<code>this.$refs.xxx</code></li></ol></li></ol><h2 id="props-配置项"><a href="#props-配置项" class="headerlink" title="props 配置项"></a>props 配置项</h2><ol><li><p>功能：让组件接收外部传过来的数据</p></li><li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p></li><li><p>接收数据：</p><ol><li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p></li><li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p></li><li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>:&#123;</span><br><span class="line"><span class="attr">name</span>:&#123;</span><br><span class="line"><span class="attr">type</span>:<span class="title class_">String</span>, <span class="comment">//类型</span></span><br><span class="line"><span class="attr">required</span>:<span class="literal">true</span>, <span class="comment">//必要性</span></span><br><span class="line"><span class="attr">default</span>:<span class="string">&#x27;老王&#x27;</span> <span class="comment">//默认值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>备注：props 是只读的，Vue 底层会监测你对 props 的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制 props 的内容到 data 中一份，然后去修改 data 中的数据。</p></blockquote></li></ol><h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a>mixin(混入)</h2><ol><li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p></li><li><p>使用方式：</p><p>第一步定义混合：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    data()&#123;....&#125;,</span><br><span class="line">    methods:&#123;....&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步使用混入：</p><p>​ 全局混入：<code>Vue.mixin(xxx)</code><br>​ 局部混入：<code>mixins:[&#39;xxx&#39;]    </code></p></li></ol><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ol><li><p>功能：用于增强 Vue</p></li><li><p>本质：包含 install 方法的一个对象，install 的第一个参数是 Vue，第二个以后的参数是插件使用者传递的数据。</p></li><li><p>定义插件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue, options</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 添加全局过滤器</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">filter</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 添加全局指令</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">directive</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 配置全局混入(合)</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;...&#125;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myProperty</span> = xxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用插件：<code>Vue.use()</code></p></li></ol><h2 id="scoped-样式"><a href="#scoped-样式" class="headerlink" title="scoped 样式"></a>scoped 样式</h2><ol><li>作用：让样式在局部生效，防止冲突。</li><li>写法：<code>&lt;style scoped&gt;</code></li></ol><h2 id="总结-TodoList-案例"><a href="#总结-TodoList-案例" class="headerlink" title="总结 TodoList 案例"></a>总结 TodoList 案例</h2><ol><li><p>组件化编码流程：</p><p>​ (1).拆分静态组件：组件要按照功能点拆分，命名不要与 html 元素冲突。</p><p>​ (2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p><p>​ 1).一个组件在用：放在组件自身即可。</p><p>​ 2). 一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。</p><p>​ (3).实现交互：从绑定事件开始。</p></li><li><p>props 适用于：</p><p>​ (1).父组件 ==&gt; 子组件 通信</p><p>​ (2).子组件 ==&gt; 父组件 通信（要求父先给子一个函数）</p></li><li><p>使用 v-model 时要切记：v-model 绑定的值不能是 props 传过来的值，因为 props 是不可以修改的！</p></li><li><p>props 传过来的若是对象类型的值，修改对象中的属性时 Vue 不会报错，但不推荐这样做。</p></li></ol><h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><ol><li><p>存储内容大小一般支持 5MB 左右（不同浏览器可能还不一样）</p></li><li><p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p></li><li><p>相关 API：</p><ol><li><p><code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);</code><br>该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</p></li><li><p><code>xxxxxStorage.getItem(&#39;person&#39;);</code></p><p>​ 该方法接受一个键名作为参数，返回键名对应的值。</p></li><li><p><code>xxxxxStorage.removeItem(&#39;key&#39;);</code></p><p>​ 该方法接受一个键名作为参数，并把该键名从存储中删除。</p></li><li><p><code> xxxxxStorage.clear()</code></p><p>​ 该方法会清空存储中的所有数据。</p></li></ol></li><li><p>备注：</p><ol><li>SessionStorage 存储的内容会随着浏览器窗口关闭而消失。</li><li>LocalStorage 存储的内容，需要手动清除才会消失。</li><li><code>xxxxxStorage.getItem(xxx)</code>如果 xxx 对应的 value 获取不到，那么 getItem 的返回值是 null。</li><li><code>JSON.parse(null)</code>的结果依然是 null。</li></ol></li></ol><h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><ol><li><p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 ===&gt; 父组件</strong></p></li><li><p>使用场景：A 是父组件，B 是子组件，B 想给 A 传数据，那么就要在 A 中给 B 绑定自定义事件（<span style="color:red">事件的回调在 A 中</span>）。</p></li><li><p>绑定自定义事件：</p><ol><li><p>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code> 或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></p></li><li><p>第二种方式，在父组件中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Demo</span> ref=<span class="string">&quot;demo&quot;</span>/&gt;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">xxx</span>.$on(<span class="string">&#x27;atguigu&#x27;</span>,<span class="variable language_">this</span>.<span class="property">test</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p></li></ol></li><li><p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,数据)</code></p></li><li><p>解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code></p></li><li><p>组件上也可以绑定原生 DOM 事件，需要使用<code>native</code>修饰符。</p></li><li><p>注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在 methods 中</span>，<span style="color:red">要么用箭头函数</span>，否则 this 指向会出问题！</p></li></ol><h2 id="全局事件总线（GlobalEventBus）"><a href="#全局事件总线（GlobalEventBus）" class="headerlink" title="全局事件总线（GlobalEventBus）"></a>全局事件总线（GlobalEventBus）</h2><ol><li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p></li><li><p>安装全局事件总线：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span> <span class="comment">//安装全局事件总线，$bus就是当前应用的vm</span></span><br><span class="line">&#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>使用事件总线：</p><ol><li><p>接收数据：A 组件想接收数据，则在 A 组件中给$bus 绑定自定义事件，事件的<span style="color:red">回调留在 A 组件自身。</span></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&#x27;xxxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p></li></ol></li><li><p>最好在 beforeDestroy 钩子中，用$off 去解绑<span style="color:red">当前组件所用到的</span>事件。</p></li></ol><h2 id="消息订阅与发布（pubsub）"><a href="#消息订阅与发布（pubsub）" class="headerlink" title="消息订阅与发布（pubsub）"></a>消息订阅与发布（pubsub）</h2><ol><li><p> 一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p></li><li><p>使用步骤：</p><ol><li><p> 安装 pubsub：<code>npm i pubsub-js</code></p></li><li><p> 引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p></li><li><p>接收数据：A 组件想接收数据，则在 A 组件中订阅消息，订阅的<span style="color:red">回调留在 A 组件自身。</span></p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pid</span> = pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;xxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>) <span class="comment">//订阅消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p> 提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p></li><li><p> 最好在 beforeDestroy 钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p></li></ol></li></ol><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><ol><li>语法：<code>this.$nextTick(回调函数)</code></li><li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li><li>什么时候用：当改变数据后，要基于更新后的新 DOM 进行某些操作时，要在 nextTick 所指定的回调函数中执行。</li></ol><h2 id="Vue-封装的过度与动画"><a href="#Vue-封装的过度与动画" class="headerlink" title="Vue 封装的过度与动画"></a>Vue 封装的过度与动画</h2><ol><li><p>作用：在插入、更新或移除 DOM 元素时，在合适的时候给元素添加样式类名。</p></li><li><p>图示：<img src="https://img04.sogoucdn.com/app/a/100520146/5990c1dff7dc7a8fb3b34b4462bd0105" style="width:60%" /></p></li><li><p>写法：</p><ol><li><p>准备好样式：</p><ul><li>元素进入的样式：<ol><li>v-enter：进入的起点</li><li>v-enter-active：进入过程中</li><li>v-enter-to：进入的终点</li></ol></li><li>元素离开的样式：<ol><li>v-leave：离开的起点</li><li>v-leave-active：离开过程中</li><li>v-leave-to：离开的终点</li></ol></li></ul></li><li><p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置 name 属性：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;transition name=&quot;hello&quot;&gt;</span><br><span class="line">&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></li><li><p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p></li></ol></li></ol><h2 id="vue-脚手架配置代理"><a href="#vue-脚手架配置代理" class="headerlink" title="vue 脚手架配置代理"></a>vue 脚手架配置代理</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​ 在 vue.config.js 中添加如下配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">  <span class="attr">proxy</span>: <span class="string">&quot;http://localhost:5000&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li><li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li><li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​ 编写 vue.config.js 配置具体代理规则：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&quot;/api1&quot;</span>: &#123;</span><br><span class="line">        <span class="comment">// 匹配所有以 &#x27;/api1&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&quot;http://localhost:5000&quot;</span>, <span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123; <span class="string">&quot;^/api1&quot;</span>: <span class="string">&quot;&quot;</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;/api2&quot;</span>: &#123;</span><br><span class="line">        <span class="comment">// 匹配所有以 &#x27;/api2&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&quot;http://localhost:5001&quot;</span>, <span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123; <span class="string">&quot;^/api2&quot;</span>: <span class="string">&quot;&quot;</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class="line"><span class="comment">   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080</span></span><br><span class="line"><span class="comment">   changeOrigin默认值为true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li><li>缺点：配置略微繁琐，请求资源时必须加前缀。</li></ol><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><ol><li><p>作用：让父组件可以向子组件指定位置插入 html 结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 ===&gt; 子组件</strong> 。</p></li><li><p>分类：默认插槽、具名插槽、作用域插槽</p></li><li><p>使用方式：</p><ol><li><p>默认插槽：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">           &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 定义插槽 --&gt;</span><br><span class="line">    &lt;slot&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li><li><p>具名插槽：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">            &lt;template slot=&quot;center&quot;&gt;</span><br><span class="line">              &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">            &lt;template v-slot:footer&gt;</span><br><span class="line">               &lt;div&gt;html结构2&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 定义插槽 --&gt;</span><br><span class="line">    &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li><li><p>作用域插槽：</p><ol><li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games 数据在 Category 组件中，但使用数据所遍历出来的结构由 App 组件决定）</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;template scope=&quot;scopeData&quot;&gt;</span><br><span class="line">&lt;!-- 生成的是ul列表 --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;template slot-scope=&quot;scopeData&quot;&gt;</span><br><span class="line">&lt;!-- 生成的是h4标题 --&gt;</span><br><span class="line">&lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Category&quot;,</span><br><span class="line">  props: [&quot;title&quot;],</span><br><span class="line">  //数据在子组件自身</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      games: [&quot;红色警戒&quot;, &quot;穿越火线&quot;, &quot;劲舞团&quot;, &quot;超级玛丽&quot;],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>​ 在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p><h3 id="2-何时使用？"><a href="#2-何时使用？" class="headerlink" title="2.何时使用？"></a>2.何时使用？</h3><p>​ 多个组件需要共享数据时</p><h3 id="3-搭建-vuex-环境"><a href="#3-搭建-vuex-环境" class="headerlink" title="3.搭建 vuex 环境"></a>3.搭建 vuex 环境</h3><ol><li><p>创建文件：<code>src/store/index.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"><span class="comment">//应用Vuex插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions对象——响应组件中用户的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;&#125;;</span><br><span class="line"><span class="comment">//准备mutations对象——修改state中的数据</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;&#125;;</span><br><span class="line"><span class="comment">//准备state对象——保存具体的数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  actions,</span><br><span class="line">  mutations,</span><br><span class="line">  state,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>在<code>main.js</code>中创建 vm 时传入<code>store</code>配置项</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">//引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vm</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line"><span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line"><span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-基本使用"><a href="#4-基本使用" class="headerlink" title="4.基本使用"></a>4.基本使用</h3><ol><li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"><span class="comment">//引用Vuex</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="comment">//响应组件中加的动作</span></span><br><span class="line">  <span class="title function_">jia</span>(<span class="params">context, value</span>) &#123;</span><br><span class="line">    <span class="comment">// console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value)</span></span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&quot;JIA&quot;</span>, value);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  <span class="comment">//执行加</span></span><br><span class="line">  <span class="title function_">JIA</span>(<span class="params">state, value</span>) &#123;</span><br><span class="line">    <span class="comment">// console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value)</span></span><br><span class="line">    state.<span class="property">sum</span> += value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="attr">sum</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  actions,</span><br><span class="line">  mutations,</span><br><span class="line">  state,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>组件中读取 vuex 中的数据：<code>$store.state.sum</code></p></li><li><p>组件中修改 vuex 中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p><blockquote><p>备注：若没有网络请求或其他业务逻辑，组件中也可以越过 actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p></blockquote></li></ol><h3 id="5-getters-的使用"><a href="#5-getters-的使用" class="headerlink" title="5.getters 的使用"></a>5.getters 的使用</h3><ol><li><p>概念：当 state 中的数据需要经过加工后再使用时，可以使用 getters 加工。</p></li><li><p>在<code>store.js</code>中追加<code>getters</code>配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line"><span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">......</span><br><span class="line">getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件中读取数据：<code>$store.getters.bigSum</code></p></li></ol><h3 id="6-四个-map-方法的使用"><a href="#6-四个-map-方法的使用" class="headerlink" title="6.四个 map 方法的使用"></a>6.四个 map 方法的使用</h3><ol><li><p><strong>mapState 方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（对象写法）</span></span><br><span class="line">     ...<span class="title function_">mapState</span>(&#123;<span class="attr">sum</span>:<span class="string">&#x27;sum&#x27;</span>,<span class="attr">school</span>:<span class="string">&#x27;school&#x27;</span>,<span class="attr">subject</span>:<span class="string">&#x27;subject&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapState</span>([<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p><strong>mapGetters 方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（对象写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>(&#123;<span class="attr">bigSum</span>:<span class="string">&#x27;bigSum&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>([<span class="string">&#x27;bigSum&#x27;</span>])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p><strong>mapActions 方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>(&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（数组形式）</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>([<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="string">&#x27;jiaWait&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>mapMutations 方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：increment、decrement（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>(&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//靠mapMutations生成：JIA、JIAN（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;JIA&#x27;</span>,<span class="string">&#x27;JIAN&#x27;</span>]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>备注：mapActions 与 mapMutations 使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p></blockquote><h3 id="7-模块化-命名空间"><a href="#7-模块化-命名空间" class="headerlink" title="7.模块化+命名空间"></a>7.模块化+命名空间</h3><ol><li><p>目的：让代码更好维护，让多种数据分类更加明确。</p></li><li><p>修改<code>store.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> countAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    countAbout,</span><br><span class="line">    personAbout</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中读取 state 数据：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">personAbout</span>.<span class="property">list</span></span><br><span class="line"><span class="comment">//方式二：借助mapState读取：</span></span><br><span class="line">...<span class="title function_">mapState</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中读取 getters 数据：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">&#x27;personAbout/firstPersonName&#x27;</span>]</span><br><span class="line"><span class="comment">//方式二：借助mapGetters读取：</span></span><br><span class="line">...<span class="title function_">mapGetters</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;bigSum&#x27;</span>])</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中调用 dispatch</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接dispatch</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;personAbout/addPersonWang&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapActions：</span></span><br><span class="line">...<span class="title function_">mapActions</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中调用 commit</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接commit</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;personAbout/ADD_PERSON&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapMutations：</span></span><br><span class="line">...<span class="title function_">mapMutations</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br></pre></td></tr></table></figure></li></ol><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol><li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li><li>前端路由：key 是路径，value 是组件。</li></ol><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><ol><li><p>安装 vue-router，命令：<code>npm i vue-router</code></p></li><li><p>应用插件：<code>Vue.use(VueRouter)</code></p></li><li><p>编写 router 配置项:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入VueRouter</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="comment">//引入Luyou 组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&quot;../components/About&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&quot;../components/Home&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建router实例对象，去管理一组一组的路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">About</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Home</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露router</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure></li><li><p>实现切换（active-class 可配置高亮样式）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li><li><p>指定展示位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-几个注意点"><a href="#2-几个注意点" class="headerlink" title="2.几个注意点"></a>2.几个注意点</h3><ol><li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li><li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li><li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li><li>整个应用只有一个 router，可以通过组件的<code>$router</code>属性获取到。</li></ol><h3 id="3-多级路由（多级路由）"><a href="#3-多级路由（多级路由）" class="headerlink" title="3.多级路由（多级路由）"></a>3.多级路由（多级路由）</h3><ol><li><p>配置路由规则，使用 children 配置项：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">About</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Home</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      <span class="comment">//通过children配置子级路由</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;news&quot;</span>, <span class="comment">//此处一定不要写：/news</span></span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">News</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;message&quot;</span>, <span class="comment">//此处一定不要写：/message</span></span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">Message</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li><li><p>跳转（要写完整路径）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-路由的-query-参数"><a href="#4-路由的-query-参数" class="headerlink" title="4.路由的 query 参数"></a>4.路由的 query 参数</h3><ol><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link</span><br><span class="line">  :to=&quot;&#123;</span><br><span class="line">    path: &#x27;/home/message/detail&#x27;,</span><br><span class="line">    query: &#123;</span><br><span class="line">      id: 666,</span><br><span class="line">      title: &#x27;你好&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$route.<span class="property">query</span>.<span class="property">id</span>;</span><br><span class="line">$route.<span class="property">query</span>.<span class="property">title</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-命名路由"><a href="#5-命名路由" class="headerlink" title="5.命名路由"></a>5.命名路由</h3><ol><li><p>作用：可以简化路由的跳转。</p></li><li><p>如何使用</p><ol><li><p>给路由命名：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/demo&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Demo</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Test</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line">                      <span class="attr">name</span>:<span class="string">&#x27;hello&#x27;</span> <span class="comment">//给路由命名</span></span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;welcome&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Hello</span>,</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>简化跳转：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--简化前，需要写完整的路径 --&gt;</span><br><span class="line">&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化后，直接通过名字跳转 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123; name: &#x27;hello&#x27; &#125;&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化写法配合传递参数 --&gt;</span><br><span class="line">&lt;router-link</span><br><span class="line">  :to=&quot;&#123;</span><br><span class="line">    name: &#x27;hello&#x27;,</span><br><span class="line">    query: &#123;</span><br><span class="line">      id: 666,</span><br><span class="line">      title: &#x27;你好&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="6-路由的-params-参数"><a href="#6-路由的-params-参数" class="headerlink" title="6.路由的 params 参数"></a>6.路由的 params 参数</h3><ol><li><p>配置路由，声明接收 params 参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Message</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title&#x27;</span>, <span class="comment">//使用占位符声明接收params参数</span></span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Detail</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link</span><br><span class="line">  :to=&quot;&#123;</span><br><span class="line">    name: &#x27;xiangqing&#x27;,</span><br><span class="line">    params: &#123;</span><br><span class="line">      id: 666,</span><br><span class="line">      title: &#x27;你好&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><blockquote><p>特别注意：路由携带 params 参数时，若使用 to 的对象写法，则不能使用 path 配置项，必须使用 name 配置！</p></blockquote></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$route.<span class="property">params</span>.<span class="property">id</span>;</span><br><span class="line">$route.<span class="property">params</span>.<span class="property">title</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="7-路由的-props-配置"><a href="#7-路由的-props-配置" class="headerlink" title="7.路由的 props 配置"></a>7.路由的 props 配置</h3><p>​ 作用：让路由组件更方便的收到参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;detail/:id&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Detail</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span></span><br><span class="line"><span class="comment">// props:&#123;a:900&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span></span><br><span class="line"><span class="comment">// props:true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span></span><br><span class="line"><span class="title function_">props</span>(<span class="params">route</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">id</span>:route.<span class="property">query</span>.<span class="property">id</span>,</span><br><span class="line"><span class="attr">title</span>:route.<span class="property">query</span>.<span class="property">title</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-lt-router-link-gt-的-replace-属性"><a href="#8-lt-router-link-gt-的-replace-属性" class="headerlink" title="8.&lt;router-link&gt;的 replace 属性"></a>8.<code>&lt;router-link&gt;</code>的 replace 属性</h3><ol><li>作用：控制路由跳转时操作浏览器历史记录的模式</li><li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li><li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li></ol><h3 id="9-编程式路由导航"><a href="#9-编程式路由导航" class="headerlink" title="9.编程式路由导航"></a>9.编程式路由导航</h3><ol><li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p></li><li><p>具体编码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//$router的两个API</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xiangqing&quot;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: xxx,</span><br><span class="line">    <span class="attr">title</span>: xxx,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xiangqing&quot;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: xxx,</span><br><span class="line">    <span class="attr">title</span>: xxx,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">forward</span>(); <span class="comment">//前进</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>(); <span class="comment">//后退</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>(); <span class="comment">//可前进也可后退</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="10-缓存路由组件"><a href="#10-缓存路由组件" class="headerlink" title="10.缓存路由组件"></a>10.缓存路由组件</h3><ol><li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;News&quot;&gt; </span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="11-两个新的生命周期钩子"><a href="#11-两个新的生命周期钩子" class="headerlink" title="11.两个新的生命周期钩子"></a>11.两个新的生命周期钩子</h3><ol><li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li><li>具体名字：<ol><li><code>activated</code>路由组件被激活时触发。</li><li><code>deactivated</code>路由组件失活时触发。</li></ol></li></ol><h3 id="12-路由守卫"><a href="#12-路由守卫" class="headerlink" title="12.路由守卫"></a>12.路由守卫</h3><ol><li><p>作用：对路由进行权限控制</p></li><li><p>分类：全局守卫、独享守卫、组件内守卫</p></li><li><p>全局守卫:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局前置守卫：初始化时执行、每次路由切换前执行</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforeEach&quot;</span>, to, <span class="keyword">from</span>);</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">meta</span>.<span class="property">isAuth</span>) &#123;</span><br><span class="line">    <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;school&quot;</span>) === <span class="string">&quot;atguigu&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">//权限控制的具体规则</span></span><br><span class="line">      <span class="title function_">next</span>(); <span class="comment">//放行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&quot;暂无权限查看&quot;</span>);</span><br><span class="line">      <span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>(); <span class="comment">//放行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局后置守卫：初始化时执行、每次路由切换后执行</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;afterEach&quot;</span>, to, <span class="keyword">from</span>);</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">meta</span>.<span class="property">title</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = to.<span class="property">meta</span>.<span class="property">title</span>; <span class="comment">//修改网页的title</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&quot;vue_test&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>独享守卫:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">beforeEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEnter&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line"><span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line"><span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>组件内守卫：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入守卫：通过路由规则，进入该组件时被调用</span></span><br><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//离开守卫：通过路由规则，离开该组件时被调用</span></span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="13-路由器的两种工作模式"><a href="#13-路由器的两种工作模式" class="headerlink" title="13.路由器的两种工作模式"></a>13.路由器的两种工作模式</h3><ol><li>对于一个 url 来说，什么是 hash 值？—— #及其后面的内容就是 hash 值。</li><li>hash 值不会包含在 HTTP 请求中，即：hash 值不会带给服务器。</li><li>hash 模式：<ol><li>地址中永远带着#号，不美观 。</li><li>若以后将地址通过第三方手机 app 分享，若 app 校验严格，则地址会被标记为不合法。</li><li>兼容性较好。</li></ol></li><li>history 模式：<ol><li>地址干净，美观 。</li><li>兼容性和 hash 模式相比略差。</li><li>应用部署上线时需要后端人员支持，解决刷新页面服务端 404 的问题。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise.all() 的小技巧</title>
      <link href="/2022/11/06/Promise.all()%20%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/11/06/Promise.all()%20%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>Promise 在处理异步操作时很有用。<br>JavaScript 提供了一个辅助函数Promise.all(promisesArrayOrIterable)来同时并行处理多个 promise，并在单个聚合数组中获取结果。让我们看看它是如何工作的。</p><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p>Promise.all() 接受一组 promises（或通常是一个可迭代的）。该函数返回一个 promise：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> allPromise = <span class="title class_">Promise</span>.<span class="title function_">all</span>([promise1, promise2, ...]);</span><br></pre></td></tr></table></figure><p>然后您可以使用 then-able 语法提取 Promise 解析的值：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">allPromise.<span class="title function_">then</span>(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  values; <span class="comment">// [valueOfPromise1, valueOfPromise2, ...]</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  error;  <span class="comment">// rejectReason of any first rejected promise</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>或 async/await语法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> values = <span class="keyword">await</span> allPromise;</span><br><span class="line">  values; <span class="comment">// [valueOfPromise1, valueOfPromise2, ...]</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  error;  <span class="comment">// rejectReason of any first rejected promise</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="所有的-Promise-fulfilled"><a href="#所有的-Promise-fulfilled" class="headerlink" title="所有的 Promise fulfilled"></a>所有的 Promise fulfilled</h2><p>为了研究如何 Promise.all() 工作，我将使用 2 个助手 -resolveTimeout(value, delay)和rejectTimeout(reason, delay).</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolveTimeout</span>(<span class="params">value, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(</span><br><span class="line">    <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(value), delay)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">rejectTimeout</span>(<span class="params">reason, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(</span><br><span class="line">    <span class="function">(<span class="params">r, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(reason), delay)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> allPromise = <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">  <span class="title function_">resolveTimeout</span>([<span class="string">&#x27;potatoes&#x27;</span>, <span class="string">&#x27;tomatoes&#x27;</span>], <span class="number">1000</span>),</span><br><span class="line">  <span class="title function_">resolveTimeout</span>([<span class="string">&#x27;oranges&#x27;</span>, <span class="string">&#x27;apples&#x27;</span>], <span class="number">1000</span>)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait...</span></span><br><span class="line"><span class="keyword">const</span> lists = <span class="keyword">await</span> allPromise;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after 1 second</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lists); </span><br><span class="line"><span class="comment">// [[&#x27;potatoes&#x27;, &#x27;tomatoes&#x27;], [&#x27;oranges&#x27;, &#x27;apples&#x27;]]</span></span><br></pre></td></tr></table></figure><p>promises 数组的顺序直接影响结果的顺序。</p><h3 id="一个-Promise-rejects"><a href="#一个-Promise-rejects" class="headerlink" title="一个 Promise rejects"></a>一个 Promise rejects</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> allPromise = <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">  <span class="title function_">resolveTimeout</span>([<span class="string">&#x27;potatoes&#x27;</span>, <span class="string">&#x27;tomatoes&#x27;</span>], <span class="number">1000</span>),</span><br><span class="line">  <span class="title function_">rejectTimeout</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Out of fruits!&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// wait...</span></span><br><span class="line">  <span class="keyword">const</span> lists = <span class="keyword">await</span> allPromise;</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="comment">// after 1 second</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error.<span class="property">message</span>); <span class="comment">// &#x27;Out of fruits!&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种行为Promise.all([…])被命名为fail-fast。如果 promises 数组中至少有一个 promise 拒绝，则allPromise = Promise.all([…])rejects返回的promise也会被拒绝。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Promise.all() 方法接收一个promise的iterable类型（注：Array，Map，Set都属于ES6的iterable类型）的输入，并且只返回一个Promise实例， 那个输入的所有promise的resolve回调的结果是一个数组。这个Promise的resolve回调执行是在所有输入的promise的resolve回调都结束，或者输入的iterable里没有promise了的时候。它的reject回调执行是，只要任何一个输入的promise的reject回调执行或者输入不合法的promise就会立即抛出错误，并且reject的是第一个抛出的错误信息。</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法题</title>
      <link href="/2022/10/29/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2022/10/29/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>输入一个字符串，打印出该字符串中字符的所有排列。<br>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。<br><code>输入：s = &quot;abc&quot; 输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string[]</span>&#125;</span></span><br><span class="line"><span class="comment"> * 全排列算法:</span></span><br><span class="line"><span class="comment"> *   固定位置依次递归交换位置穷举出所有的可能性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permutation = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> char = s.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> dsf = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="comment">// 递归的出口,如果是遍历到最后一个位置此方法就解了</span></span><br><span class="line">    <span class="keyword">if</span> (n === char.<span class="property">length</span>) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(char.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> catSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = n; i &lt; char.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//如果有相同的交换，则不需要处理枝减。</span></span><br><span class="line">      <span class="keyword">if</span> (catSet.<span class="title function_">has</span>(char[i])) <span class="keyword">continue</span>;</span><br><span class="line">      catSet.<span class="title function_">add</span>(char[i]);</span><br><span class="line">      <span class="comment">// 被固定的位置和其他位置依次交换位置</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">const</span> t = char[n];</span><br><span class="line">        char[n] = char[i];</span><br><span class="line">        char[i] = t;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 递归下一个位置</span></span><br><span class="line">      <span class="title function_">dsf</span>(n + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 被交换的位置需要回溯归位。</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">const</span> t = char[n];</span><br><span class="line">        char[n] = char[i];</span><br><span class="line">        char[i] = t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">dsf</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">sort</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 ajax javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html的小技巧</title>
      <link href="/2022/10/23/html%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/10/23/html%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="使用capture属性打开设备摄像头"><a href="#使用capture属性打开设备摄像头" class="headerlink" title="使用capture属性打开设备摄像头"></a>使用capture属性打开设备摄像头</h3><p>正如input标签具有email、text和password属性一样，我们也可以通过一些属性打开移动设备的摄像头以捕获图像。<br>那就是capture属性，属性值有两个：</p><ul><li>user用于前置摄像头</li><li>environment用于后置摄像头<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">capture</span>=<span class="string">&quot;user&quot;</span> <span class="attr">accept</span>=<span class="string">&quot;image/*&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="网站自动刷新"><a href="#网站自动刷新" class="headerlink" title="网站自动刷新"></a>网站自动刷新</h3>你可以在head标签中将网站设置为定时刷新！<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="激活拼写检查"><a href="#激活拼写检查" class="headerlink" title="激活拼写检查"></a>激活拼写检查</h3>你可以使用HTML的spellcheck属性并将其设置为true以激活拼写检查。使用lang属性指定待检查的语言。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">spellcheck</span>=<span class="string">&quot;true&quot;</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="指定要上传的文件类型"><a href="#指定要上传的文件类型" class="headerlink" title="指定要上传的文件类型"></a>指定要上传的文件类型</h3>你可以使用accept属性在input标签中指定允许用户上传的文件类型。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">accept</span>=<span class="string">&quot;.jpeg,.png&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="阻止浏览器翻译"><a href="#阻止浏览器翻译" class="headerlink" title="阻止浏览器翻译"></a>阻止浏览器翻译</h3>将translate属性设置为no会阻止浏览器翻译该内容。如果你不想翻译某个短语或单词，例如logo、公司或品牌名称，那就可以应用这个属性。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">translate</span>=<span class="string">&quot;no&quot;</span>&gt;</span>Brand name<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在input标签中输入多个项目"><a href="#在input标签中输入多个项目" class="headerlink" title="在input标签中输入多个项目"></a>在input标签中输入多个项目</h3>这可以通过multiple属性来完成。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="为视频创建海报（缩略图）"><a href="#为视频创建海报（缩略图）" class="headerlink" title="为视频创建海报（缩略图）"></a>为视频创建海报（缩略图）</h3>使用poster属性，我们可以在视频加载时，或者在用户点击播放按钮之前，显示指定的缩略图。</li></ul><p>如果不指定图片，则默认使用视频的第一帧作为缩略图。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">poster</span>=<span class="string">&quot;picture.png&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="点击链接自动下载）"><a href="#点击链接自动下载）" class="headerlink" title="点击链接自动下载）"></a>点击链接自动下载）</h3><p>如果你希望在单击目标资源的链接时下载特定资源，那就添加download属性。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;image.png&quot;</span> <span class="attr">download</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 ajax javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 数组方法</title>
      <link href="/2022/10/15/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2022/10/15/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>JavaScript中的Array对象与其他编程语言中的数组一样，可以将多个项目的集合存储在单个变量名下，并具有用于执行常见数组操作的成员。<br>声明数组<br>有两种不同的方式可以声明数组。</p><h3 id="使用new-Array"><a href="#使用new-Array" class="headerlink" title="使用new Array"></a>使用new Array</h3><p>通过new Array，我们可以指定希望存在于数组中的元素，如下所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits.<span class="property">length</span>);</span><br></pre></td></tr></table></figure><h4 id="数组字面量表示法"><a href="#数组字面量表示法" class="headerlink" title="数组字面量表示法"></a>数组字面量表示法</h4><p>使用数组字面量声明，我们可以指定数组将具有的值。如果我们不声明任何值，则数组将为空。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过数组字面量创建一个有2个元素的&#x27;fruits&#x27;数组.</span></span><br><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits.<span class="property">length</span>);</span><br></pre></td></tr></table></figure><h4 id="1-forEach"><a href="#1-forEach" class="headerlink" title="1. forEach"></a>1. forEach</h4><p>forEach()方法将为每个数组元素执行一次指定的函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">array1.<span class="title function_">forEach</span>(<span class="function"><span class="params">element</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(element));</span><br><span class="line"></span><br><span class="line"><span class="comment">// expected output: &quot;a&quot;</span></span><br><span class="line"><span class="comment">// expected output: &quot;b&quot;</span></span><br><span class="line"><span class="comment">// expected output: &quot;c&quot;</span></span><br></pre></td></tr></table></figure><p>forEach()为数组中的每个元素按索引升序调用提供的callbackFn函数一次。它不会为已删除或未初始化的索引属性调用。</p><h4 id="2-map"><a href="#2-map" class="headerlink" title="2. map"></a>2. map</h4><p>Array.map()方法允许你遍历数组并使用回调函数修改其元素。然后将在数组的每个元素上执行回调函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">map</span>(callback[, thisObject]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> modifiedArr = arr.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> element *<span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(modifiedArr); <span class="comment">// [9, 12, 15, 18]</span></span><br></pre></td></tr></table></figure><p>Array.map()方法通常用于对元素应用一些更改，无论是像在上面代码中那样乘以特定数字，还是执行应用程序可能需要的任何其他操作。</p><h4 id="3-concat"><a href="#3-concat" class="headerlink" title="3. concat"></a>3. concat</h4><p>JavaScript中的concat()方法是一个字符串方法，用于将字符串连接在一起。concat()方法将一个或多个字符串值附加到调用字符串，然后将连接的结果作为新字符串返回。因为concat()方法是String对象的方法，所以必须通过String类的特定实例来调用它。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">concat</span>(value1, value2, ..., valueN);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> array2 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> array3 = array1.<span class="title function_">concat</span>(array2);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array3);</span><br><span class="line"><span class="comment">// expected output: Array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="4-push"><a href="#4-push" class="headerlink" title="4. push"></a>4. push</h4><p>Javascript数组中的push()方法将给定元素附加到数组最后并返回新数组的长度。</p><p>如果你想在数组末尾添加一个元素，请使用push()。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">push</span>(element1, ..., elementN);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> countries = [<span class="string">&quot;Nigeria&quot;</span>, <span class="string">&quot;Ghana&quot;</span>, <span class="string">&quot;Rwanda&quot;</span>];</span><br><span class="line"></span><br><span class="line">countries.<span class="title function_">push</span>(<span class="string">&quot;Kenya&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(countries); <span class="comment">// [&quot;Nigeria&quot;,&quot;Ghana&quot;,&quot;Rwanda&quot;,&quot;Kenya&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="5-pop"><a href="#5-pop" class="headerlink" title="5. pop"></a>5. pop</h4><p>pop()方法将删除数组的最后一个元素并将该值返回给调用者。如果你在空数组上调用pop()，则返回undefined。</p><p>Array.prototype.shift()与pop()具有相似的行为，但应用于数组中的第一个元素。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">pop</span>();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> plants = [<span class="string">&#x27;broccoli&#x27;</span>, <span class="string">&#x27;cauliflower&#x27;</span>, <span class="string">&#x27;cabbage&#x27;</span>, <span class="string">&#x27;kale&#x27;</span>, <span class="string">&#x27;tomato&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(plants.<span class="title function_">pop</span>());</span><br><span class="line"><span class="comment">// expected output: &quot;tomato&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(plants);</span><br><span class="line"><span class="comment">// expected output: Array [&quot;broccoli&quot;, &quot;cauliflower&quot;, &quot;cabbage&quot;, &quot;kale&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="6-splice"><a href="#6-splice" class="headerlink" title="6. splice"></a>6. splice</h4><p>splice()方法是一种通用方法，用于在数组的指定位置通过删除、替换或添加元素来更改数组的内容。本节将介绍如何使用此方法将元素添加到特定位置。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">splice</span>(index, howMany, [element1][, ..., elementN]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span>];</span><br><span class="line"></span><br><span class="line">fruits.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&quot;Lemon&quot;</span>, <span class="string">&quot;Kiwi&quot;</span>); <span class="comment">//Banana,Orange,Lemon,Kiwi,Apple,Mango</span></span><br></pre></td></tr></table></figure><h4 id="7-slice"><a href="#7-slice" class="headerlink" title="7. slice"></a>7. slice</h4><p>slice()方法将一部分数组的浅表副本返回到从开始到结束（不包括结束）选择的新数组对象中，其中开始和结束表示该数组中项目的索引。该方法不会修改原始数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">slice</span>( begin [,end] );</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> animals = [<span class="string">&#x27;ant&#x27;</span>, <span class="string">&#x27;bison&#x27;</span>, <span class="string">&#x27;camel&#x27;</span>, <span class="string">&#x27;duck&#x27;</span>, <span class="string">&#x27;elephant&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(animals.<span class="title function_">slice</span>(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// expected output: Array [&quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(animals.<span class="title function_">slice</span>(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// expected output: Array [&quot;camel&quot;, &quot;duck&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="8-shift"><a href="#8-shift" class="headerlink" title="8. shift"></a>8. shift</h4><p>shift()是内置的JavaScript函数，用于从数组中删除第一个元素。shift()函数直接修改正在使用的数组。同时shift()返回数组中删除的项目。</p><p>shift()函数删除索引位置0的项目，并将索引号的值依次向下移动1。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">shift</span>();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> firstElement = array1.<span class="title function_">shift</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array1);</span><br><span class="line"><span class="comment">// expected output: Array [2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstElement);</span><br><span class="line"><span class="comment">// expected output: 1</span></span><br></pre></td></tr></table></figure><h4 id="9-unshift"><a href="#9-unshift" class="headerlink" title="9. unshift"></a>9. unshift</h4><p>unshift()方法将插入给定值到类数组对象的开头。</p><p>Array.prototype.push()与unshift()具有相似的行为，但应用于数组的末尾。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">unshift</span>( element1, ..., elementN );</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array1.<span class="title function_">unshift</span>(<span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line"><span class="comment">// expected output: 5</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array1);</span><br><span class="line"><span class="comment">// expected output: Array [4, 5, 1, 2, 3]</span></span><br></pre></td></tr></table></figure><h4 id="10-join"><a href="#10-join" class="headerlink" title="10. join"></a>10. join</h4><p>JavaScript数组中的join()方法是一个内置方法，通过连接数组的所有元素来创建并返回新字符串。join()方法将连接数组的项到字符串并返回该字符串。指定的分隔符用于分隔元素数组。默认分隔符是逗号(,)。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">join</span>(separator);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> elements = [<span class="string">&#x27;Fire&#x27;</span>, <span class="string">&#x27;Air&#x27;</span>, <span class="string">&#x27;Water&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(elements.<span class="title function_">join</span>());</span><br><span class="line"><span class="comment">// expected output: &quot;Fire,Air,Water&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(elements.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line"><span class="comment">// expected output: &quot;FireAirWater&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(elements.<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>));</span><br><span class="line"><span class="comment">// expected output: &quot;Fire-Air-Water&quot;</span></span><br></pre></td></tr></table></figure><h4 id="11-every"><a href="#11-every" class="headerlink" title="11. every"></a>11. every</h4><p>every()方法测试数组中的所有元素是否都满足指定的条件。返回的是布尔值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">every</span>(callback[, thisObject]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isBelowThreshold</span> = (<span class="params">currentValue</span>) =&gt; currentValue &lt; <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">30</span>, <span class="number">39</span>, <span class="number">29</span>, <span class="number">10</span>, <span class="number">13</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array1.<span class="title function_">every</span>(isBelowThreshold));</span><br><span class="line"><span class="comment">// expected output: true</span></span><br></pre></td></tr></table></figure><h4 id="12-filter"><a href="#12-filter" class="headerlink" title="12. filter"></a>12. filter</h4><p>filter()方法创建部分给定数组的浅表副本，向下过滤到给定数组中的元素，且元素通过所提供函数实现的条件测试。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">filter</span>(callback[, thisObject]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> words = [<span class="string">&#x27;spray&#x27;</span>, <span class="string">&#x27;limit&#x27;</span>, <span class="string">&#x27;elite&#x27;</span>, <span class="string">&#x27;exuberant&#x27;</span>, <span class="string">&#x27;destruction&#x27;</span>, <span class="string">&#x27;present&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = words.<span class="title function_">filter</span>(<span class="function"><span class="params">word</span> =&gt;</span> word.<span class="property">length</span> &gt; <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"><span class="comment">// expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="13-indexOf"><a href="#13-indexOf" class="headerlink" title="13. indexOf"></a>13. indexOf</h4><p>indexOf()方法返回可以在数组中找到给定元素的第一个索引，如果不存在则返回-1。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">indexOf</span>(searchElement[, fromIndex]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> beasts = [<span class="string">&#x27;ant&#x27;</span>, <span class="string">&#x27;bison&#x27;</span>, <span class="string">&#x27;camel&#x27;</span>, <span class="string">&#x27;duck&#x27;</span>, <span class="string">&#x27;bison&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(beasts.<span class="title function_">indexOf</span>(<span class="string">&#x27;bison&#x27;</span>));</span><br><span class="line"><span class="comment">// expected output: 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// start from index 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(beasts.<span class="title function_">indexOf</span>(<span class="string">&#x27;bison&#x27;</span>, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// expected output: 4</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(beasts.<span class="title function_">indexOf</span>(<span class="string">&#x27;giraffe&#x27;</span>));</span><br><span class="line"><span class="comment">// expected output: -1</span></span><br></pre></td></tr></table></figure><h4 id="14-reduce"><a href="#14-reduce" class="headerlink" title="14. reduce"></a>14. reduce</h4><p>reduce()方法按顺序对数组的每个元素执行用户提供的reducer回调函数，传入前一个元素的计算返回值。在数组的所有元素上运行reducer的最终结果是单个值。。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">reduce</span>(callback[, initialValue]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 + 1 + 2 + 3 + 4</span></span><br><span class="line"><span class="keyword">const</span> initialValue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> sumWithInitial = array1.<span class="title function_">reduce</span>(</span><br><span class="line">  <span class="function">(<span class="params">previousValue, currentValue</span>) =&gt;</span> previousValue + currentValue,</span><br><span class="line">  initialValue</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sumWithInitial)</span><br></pre></td></tr></table></figure><h4 id="15-reverse"><a href="#15-reverse" class="headerlink" title="15. reverse"></a>15. reverse</h4><p>reverse()方法将反转数组并返回对相同数组的引用，第一个数组元素成为最后一个，最后一个数组元素成为第一个。换句话说，数组中的元素顺序将转向与之前相反的方向。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">reverse</span>();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;array1:&#x27;</span>, array1);</span><br><span class="line"><span class="comment">// expected output: &quot;array1:&quot; Array [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reversed = array1.<span class="title function_">reverse</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reversed:&#x27;</span>, reversed);</span><br><span class="line"><span class="comment">// expected output: &quot;reversed:&quot; Array [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Careful: reverse is destructive -- it changes the original array.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;array1:&#x27;</span>, array1);</span><br><span class="line"><span class="comment">// expected output: &quot;array1:&quot; Array [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="16-sort"><a href="#16-sort" class="headerlink" title="16. sort"></a>16. sort</h4><p>sort()方法对数组的元素进行就地排序，并返回对同一个数组的引用，而此时数组已排序。默认排序顺序是升序，将元素转换为字符串，然后比较它们的UTF-16代码单元值序列。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">sort</span>( compareFunction );</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> months = [<span class="string">&#x27;March&#x27;</span>, <span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>];</span><br><span class="line">months.<span class="title function_">sort</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(months);</span><br><span class="line"><span class="comment">// expected output: Array [&quot;Dec&quot;, &quot;Feb&quot;, &quot;Jan&quot;, &quot;March&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">30</span>, <span class="number">4</span>, <span class="number">21</span>, <span class="number">100000</span>];</span><br><span class="line">array1.<span class="title function_">sort</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array1);</span><br><span class="line"><span class="comment">// expected output: Array [1, 100000, 21, 30, 4]</span></span><br></pre></td></tr></table></figure><h4 id="17-toString"><a href="#17-toString" class="headerlink" title="17. toString"></a>17. toString</h4><p>toString()方法返回表示对象的字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">toString</span>();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog1 = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Gabby&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span> <span class="title function_">dogToString</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog1.<span class="title function_">toString</span>());</span><br><span class="line"><span class="comment">// expected output: &quot;Gabby&quot;</span></span><br></pre></td></tr></table></figure><h4 id="18-at"><a href="#18-at" class="headerlink" title="18. at"></a>18. at</h4><p>at()方法接受整数值并返回at索引的项目，正整数和负整数皆可。负整数从数组中的最后一项开始倒数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">at</span>(index)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Using an index of <span class="subst">$&#123;index&#125;</span> the item returned is <span class="subst">$&#123;array1.at(index)&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// expected output: &quot;Using an index of 2 the item returned is 8&quot;</span></span><br><span class="line"></span><br><span class="line">index = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Using an index of <span class="subst">$&#123;index&#125;</span> item returned is <span class="subst">$&#123;array1.at(index)&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// expected output: &quot;Using an index of -2 item returned is 130&quot;</span></span><br></pre></td></tr></table></figure><h4 id="19-find"><a href="#19-find" class="headerlink" title="19. find"></a>19. find</h4><p>find()方法返回数组中满足条件测试函数的第一个元素。如果没有值满足提供的测试函数，则返回undefined。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">find</span>(<span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>),thisValue)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> found = array1.<span class="title function_">find</span>(<span class="function"><span class="params">element</span> =&gt;</span> element &gt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(found);</span><br><span class="line"><span class="comment">// expected output: 12</span></span><br></pre></td></tr></table></figure><h4 id="20-some"><a href="#20-some" class="headerlink" title="20. some"></a>20. some</h4><p>some()方法测试数组中是不是至少有一个元素通过了函数实现的条件测试。如果在数组中找到这样的元素就返回true；否则返回false。该方法不修改原数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">some</span>(callback[, thisObject]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// checks whether an element is even</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">even</span> = (<span class="params">element</span>) =&gt; element % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array.<span class="title function_">some</span>(even));</span><br><span class="line"><span class="comment">// expected output: true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12个实用的JS函数</title>
      <link href="/2022/10/07/12%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84JS%E5%87%BD%E6%95%B0/"/>
      <url>/2022/10/07/12%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84JS%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文收集了 12 个在日常开发中非常常用的函数，有些可能很复杂，有些可能很简单，但我相信或多或少会对大家都会有所帮助。</p><h3 id="生成随机颜色"><a href="#生成随机颜色" class="headerlink" title="生成随机颜色"></a>生成随机颜色</h3><p>你的网站是否需要生成随机颜色？下面一行代码就可以实现。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">generateRandomHexColor</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">  <span class="string">`#<span class="subst">$&#123;<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">0xffffff</span>).toString(<span class="number">16</span>)&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generateRandomHexColor</span>());</span><br></pre></td></tr></table></figure><h3 id="数组重排序"><a href="#数组重排序" class="headerlink" title="数组重排序"></a>数组重排序</h3><p>对数组的元素进行重新排序是一项非常重要的技巧，但是原生 Array 中并没有这项功能。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">shuffle</span> = (<span class="params">arr</span>) =&gt; arr.<span class="title function_">sort</span>(<span class="function">() =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">shuffle</span>(arr));</span><br></pre></td></tr></table></figure><h3 id="复制到剪切板"><a href="#复制到剪切板" class="headerlink" title="复制到剪切板"></a>复制到剪切板</h3><p>复制到剪切板是一项非常实用且能够提高用户便利性的功能。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">copyToClipboard</span> = (<span class="params">text</span>) =&gt;</span><br><span class="line">  navigator.<span class="property">clipboard</span> &amp;&amp;</span><br><span class="line">  navigator.<span class="property">clipboard</span>.<span class="property">writeText</span> &amp;&amp;</span><br><span class="line">  navigator.<span class="property">clipboard</span>.<span class="title function_">writeText</span>(text);</span><br><span class="line"></span><br><span class="line"><span class="title function_">copyToClipboard</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="检测暗色主题"><a href="#检测暗色主题" class="headerlink" title="检测暗色主题"></a>检测暗色主题</h3><p>暗色主题日益普及，很多用的都会在设备中启用案模式，我们将应用程序切换到暗色主题可以提高用户体验度。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isDarkMode</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">matchMedia</span> &amp;&amp;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">matchMedia</span>(<span class="string">&quot;(prefers-color-scheme: dark)&quot;</span>).<span class="property">matches</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isDarkMode</span>());</span><br></pre></td></tr></table></figure><h3 id="滚动到顶部"><a href="#滚动到顶部" class="headerlink" title="滚动到顶部"></a>滚动到顶部</h3><p>将元素滚动到顶部最简单的方法是使用 scrollIntoView。设置 block 为 start 可以滚动到顶部；设置 behavior 为 smooth 可以开启平滑滚动。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">与滚动到顶部一样，滚动到底部只需要设置block为end即可。</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">scrollToBottom</span> = (<span class="params">element</span>) =&gt;</span><br><span class="line">  element.<span class="title function_">scrollIntoView</span>(&#123; <span class="attr">behavior</span>: <span class="string">&quot;smooth&quot;</span>, <span class="attr">block</span>: <span class="string">&quot;end&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><h3 id="检测元素是否在屏幕中"><a href="#检测元素是否在屏幕中" class="headerlink" title="检测元素是否在屏幕中"></a>检测元素是否在屏幕中</h3><p>检查元素是否在窗口中最好的方法是使用 IntersectionObserver。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">callback</span> = (<span class="params">entries</span>) =&gt; &#123;</span><br><span class="line">  entries.<span class="title function_">forEach</span>(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">      <span class="comment">// `entry.target` is the dom element</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;entry.target.id&#125;</span> is visible`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="attr">threshold</span>: <span class="number">1.0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(callback, options);</span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> bottomBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;bottom-btn&quot;</span>);</span><br><span class="line">observer.<span class="title function_">observe</span>(btn);</span><br><span class="line">observer.<span class="title function_">observe</span>(bottomBtn);</span><br></pre></td></tr></table></figure><h3 id="检测设备"><a href="#检测设备" class="headerlink" title="检测设备"></a>检测设备</h3><p>使用 navigator.userAgent 来检测网站运行在哪种平台设备上。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">detectDeviceType</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">  <span class="regexp">/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i</span>.<span class="title function_">test</span>(</span><br><span class="line">    navigator.<span class="property">userAgent</span></span><br><span class="line">  )</span><br><span class="line">    ? <span class="string">&quot;Mobile&quot;</span></span><br><span class="line">    : <span class="string">&quot;Desktop&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">detectDeviceType</span>());</span><br></pre></td></tr></table></figure><h3 id="隐藏元素"><a href="#隐藏元素" class="headerlink" title="隐藏元素"></a>隐藏元素</h3><p>我们可以将元素的 style.visibility 设置为 hidden，隐藏元素的可见性，但元素的空间仍然会被占用。如果设置元素的 style.display 为 none，会将元素从渲染流中删除。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">hideElement</span> = (<span class="params">el, removeFromFlow = <span class="literal">false</span></span>) =&gt; &#123;</span><br><span class="line">  removeFromFlow</span><br><span class="line">    ? (el.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>)</span><br><span class="line">    : (el.<span class="property">style</span>.<span class="property">visibility</span> = <span class="string">&quot;hidden&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="从-URL-中获取参数"><a href="#从-URL-中获取参数" class="headerlink" title="从 URL 中获取参数"></a>从 URL 中获取参数</h3><p>JavaScript 中有一个 URL 对象，通过它可以非常方便的获取 URL 中的参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getParamByUrl</span> = (<span class="params">key</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(location.<span class="property">href</span>);</span><br><span class="line">  <span class="keyword">return</span> url.<span class="property">searchParams</span>.<span class="title function_">get</span>(key);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="深拷贝对象"><a href="#深拷贝对象" class="headerlink" title="深拷贝对象"></a>深拷贝对象</h3><p>深拷贝对象非常简单，先将对象转换为字符串，再转换成对象即可。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">deepCopy</span> = (<span class="params">obj</span>) =&gt; <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br></pre></td></tr></table></figure><p>除了利用 JSON 的 API，还有更新的深拷贝对象的 structuredClone API，但并不是在所有的浏览器中都支持。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">structuredClone</span>(obj);</span><br></pre></td></tr></table></figure><h3 id="等待函数"><a href="#等待函数" class="headerlink" title="等待函数"></a>等待函数</h3><p>JavaScript 提供了 setTimeout 函数，但是它并不返回 Promise 对象，所以我们没办法使用 async 作用在这个函数上，但是我们可以封装等待函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">wait</span> = (<span class="params">ms</span>) =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">asyncFn</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">wait</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;等待异步函数执行结束&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncFn</span>();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的深度与广度优先遍历</title>
      <link href="/2022/09/24/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%B8%8E%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
      <url>/2022/09/24/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%B8%8E%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="深度优先遍历算法口诀"><a href="#深度优先遍历算法口诀" class="headerlink" title="深度优先遍历算法口诀"></a>深度优先遍历算法口诀</h2><ul><li>访问根节点</li><li>对根节点的没访问过相邻节点挨个进行深度优先遍历<br>code</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> graph = &#123;</span><br><span class="line">  <span class="number">0</span>: [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  <span class="number">1</span>: [<span class="number">2</span>],</span><br><span class="line">  <span class="number">2</span>: [<span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">  <span class="number">3</span>: [<span class="number">3</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">n</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n); <span class="comment">//访问根节点</span></span><br><span class="line">  visted.<span class="title function_">add</span>(n); <span class="comment">//访问过的做一个记录</span></span><br><span class="line">  graph[n].<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visted.<span class="title function_">has</span>(item)) &#123;</span><br><span class="line">      <span class="title function_">dfs</span>(item); <span class="comment">//递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">dfs</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//结果为   2  0  1  3</span></span><br></pre></td></tr></table></figure><h2 id="广度优先遍历算法口诀"><a href="#广度优先遍历算法口诀" class="headerlink" title="广度优先遍历算法口诀"></a>广度优先遍历算法口诀</h2><ul><li>新建一个队列，把根节点入队</li><li>把队头出队并访问</li><li>把队头的没访问过的相邻节点入队</li><li>重复第二三步，直到队列为空<br>code</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="keyword">const</span> q = [<span class="number">2</span>]; <span class="comment">//根节点入队</span></span><br><span class="line">visited.<span class="title function_">add</span>(<span class="number">2</span>); <span class="comment">//添加到访问记录</span></span><br><span class="line"><span class="keyword">while</span> (q.<span class="property">length</span>) &#123;</span><br><span class="line">  <span class="comment">//循环</span></span><br><span class="line">  <span class="keyword">const</span> n = q.<span class="title function_">shift</span>(); <span class="comment">//队头出队并访问</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">  graph[n].<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//把队头没访问过的相邻节点入队</span></span><br><span class="line">    <span class="keyword">if</span> (!visited.<span class="title function_">has</span>(item)) &#123;</span><br><span class="line">      q.<span class="title function_">push</span>(item);</span><br><span class="line">      visited.<span class="title function_">add</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果<br><img src="https://s2.loli.net/2022/09/18/bnU753C1qlmox6L.png" alt="QQ截图20220918154348.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>图是网络结构的抽象模型，是一组由边连接的节点</li><li>图可以表示任何二次元关系，比如道路，航班</li><li>JS 中没有图，但是可以用，Object 和 Array 构件图</li><li>图的表示法：邻接矩阵,邻接表</li><li>图的常用操作: 深度/广度优先遍历</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列,链表,集合,字典，树</title>
      <link href="/2022/09/17/%E9%98%9F%E5%88%97/"/>
      <url>/2022/09/17/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="用JS数组方法模拟队列"><a href="#用JS数组方法模拟队列" class="headerlink" title="用JS数组方法模拟队列"></a>用JS数组方法模拟队列</h2><p>队列实例演示视频，可以看出是先进先出</p><iframe height=419 width=745 src='https://player.youku.com/embed/XNTkwMjUzNjY2OA==' frameborder=0 allowfullscreen="true"></iframe><h2 id="JS异步中的任务队列"><a href="#JS异步中的任务队列" class="headerlink" title="JS异步中的任务队列"></a>JS异步中的任务队列</h2><ul><li>JS是单线程的，无法同时处理异步中的并发任务</li><li>使用任务队列先后处理异步任务</li></ul><h2 id="链表模拟"><a href="#链表模拟" class="headerlink" title="链表模拟"></a>链表模拟</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表  模拟</span></span><br><span class="line"><span class="keyword">const</span> a=&#123;<span class="attr">val</span>:<span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> b=&#123;<span class="attr">val</span>:<span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> c=&#123;<span class="attr">val</span>:<span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> d=&#123;<span class="attr">val</span>:<span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line">a.<span class="property">next</span>=b;</span><br><span class="line">b.<span class="property">next</span>=c;</span><br><span class="line">c.<span class="property">next</span>=d;</span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="keyword">let</span> p=a;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">val</span>);</span><br><span class="line">    p=p.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入 改变next指向</span></span><br><span class="line"><span class="keyword">const</span> e=&#123;<span class="attr">val</span>:<span class="string">&quot;e&quot;</span>&#125;;</span><br><span class="line">c.<span class="property">next</span>=e;</span><br><span class="line">e.<span class="property">next</span>=d;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">val</span>);</span><br><span class="line">    p=p.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除e</span></span><br><span class="line">c.<span class="property">next</span>=d;</span><br></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//去重</span></span><br><span class="line"><span class="keyword">const</span> arr=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr2=[...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];<span class="comment">//得到一个集合</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2);</span><br><span class="line"><span class="comment">//判断元素是否在集合中</span></span><br><span class="line"><span class="keyword">const</span> set=<span class="keyword">new</span> <span class="title class_">Set</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">has</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//求交集</span></span><br><span class="line"><span class="keyword">const</span> set2=<span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> set3=<span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> set2.<span class="title function_">has</span>(item);</span><br><span class="line">&#125;))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...set3]);</span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><ul><li>与集合类似，字典也是一种储存为一只的数据结构，但他是以键值对的形式来储存<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ES6总有字典，名为Map</span></span><br><span class="line"><span class="keyword">const</span> m=<span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line"><span class="comment">//删除字典</span></span><br><span class="line">m.<span class="title function_">delete</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">m.<span class="title function_">clear</span>(); </span><br><span class="line"><span class="comment">//改</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;awdawd&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2></li><li>一种分层数据抽象模型</li><li>前端工作中常见的树包括，DOM数，级联选择,树形控件<br>js 中没有树，但是可以用Object和Array构建数</li><li>树的常用操作，深度/广度操作<ul><li>深度优先遍历<br>   1.访问根节点<br>   2.对根节点的chidren挨个进行深度优先遍历<br>就是递归的使用<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tree=&#123;</span><br><span class="line">    <span class="attr">val</span>:<span class="string">&quot;根节点&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>:[&#123;</span><br><span class="line">        <span class="attr">val</span>:<span class="string">&quot;二级节点1&quot;</span>,</span><br><span class="line">        <span class="attr">children</span>:[&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="string">&quot;三级节点1&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>:[]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="string">&quot;三级节点2&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>:[]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        <span class="attr">val</span>:<span class="string">&quot;二级节点2&quot;</span>,</span><br><span class="line">        <span class="attr">children</span>:[&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="string">&quot;三级节点3&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>:[]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="string">&quot;三级节点4&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>:[]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        <span class="attr">val</span>:<span class="string">&quot;二级节点3&quot;</span>,</span><br><span class="line">        <span class="attr">children</span>:[&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="string">&quot;三级节点5&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>:[]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="string">&quot;三级节点6&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>:[]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">dfs</span>=(<span class="params">root</span>)=&gt;&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>);</span><br><span class="line">    root.<span class="property">children</span>.<span class="title function_">forEach</span>(dfs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">dfs</span>(tree);</span><br></pre></td></tr></table></figure>执行结果<br><img src="https://s2.loli.net/2022/09/17/minX4Qz2MsVFBlJ.png" alt="执行结果"></li></ul></li><li>广度优先遍历<ul><li>新建一个队列，把根节点入队</li><li>把队头出队，并访问</li><li>把对头的children挨个入队</li><li>重读第二，三步直到队列为空<br>接续用上述的tree使用广度优先遍历实现<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bfs=<span class="keyword">function</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="comment">//拿到队头</span></span><br><span class="line">    <span class="keyword">let</span> queue=[root];</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> n=queue.<span class="title function_">shift</span>();<span class="comment">//出队并访问</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">        <span class="comment">//把队头的children挨个入队</span></span><br><span class="line">        n.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">            queue.<span class="title function_">push</span>(item);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的前中后序遍历"><a href="#二叉树的前中后序遍历" class="headerlink" title="二叉树的前中后序遍历"></a>二叉树的前中后序遍历</h1></li></ul></li></ul><h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><ul><li>先序遍历算法口诀<ul><li>访问根节点</li><li>对根节点的左子树进行先序遍历</li><li>对根节点的右子树进行先序遍历</li></ul></li></ul><p>如下二叉树</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bt=&#123;</span><br><span class="line">    <span class="attr">val</span>:<span class="number">1</span>,</span><br><span class="line">   <span class="attr">left</span>:&#123;</span><br><span class="line">        <span class="attr">val</span>:<span class="number">2</span>,</span><br><span class="line">        <span class="attr">left</span>:&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="number">3</span>,</span><br><span class="line">            <span class="attr">left</span>:<span class="literal">null</span>,</span><br><span class="line">            <span class="attr">right</span>:<span class="literal">null</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">right</span>:&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="number">4</span>,</span><br><span class="line">            <span class="attr">left</span>:<span class="literal">null</span>,</span><br><span class="line">            <span class="attr">right</span>:<span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">right</span>:&#123;</span><br><span class="line">    <span class="attr">val</span>:<span class="number">5</span>,</span><br><span class="line">    <span class="attr">left</span>:&#123;</span><br><span class="line">        <span class="attr">val</span>:<span class="number">6</span>,</span><br><span class="line">        <span class="attr">left</span>:<span class="literal">null</span>,</span><br><span class="line">        <span class="attr">right</span>:<span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">right</span>:&#123;</span><br><span class="line">        <span class="attr">val</span>:<span class="number">7</span>,</span><br><span class="line">        <span class="attr">left</span>:<span class="literal">null</span>,</span><br><span class="line">        <span class="attr">right</span>:<span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=bt;</span><br></pre></td></tr></table></figure><p>根据算法口诀先序遍历</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> perorder=<span class="keyword">function</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment">//当子树不存在时退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>)<span class="comment">//访问根节点</span></span><br><span class="line">    <span class="title function_">perorder</span>(root.<span class="property">left</span>)<span class="comment">//对根节点的左子树进行遍历</span></span><br><span class="line">    <span class="title function_">perorder</span>(root.<span class="property">right</span>)<span class="comment">//对根节点的右子树进行遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/18/dVHLJOCIUrQKbGN.png" alt="QQ截图20220918085919.png">;<br>按照这个顺序进行遍历<br>得到<br><img src="https://s2.loli.net/2022/09/18/Ord5Uhp2lgqvTKW.png" alt="QQ截图20220918090811.png"></p><h2 id="中序遍历算法口诀"><a href="#中序遍历算法口诀" class="headerlink" title="中序遍历算法口诀"></a>中序遍历算法口诀</h2><ol><li>对根节点的左子树进行中序遍历</li><li>访问根节点</li><li>对根节点的右子树进行中序遍历<br>code实现<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> inorder=<span class="keyword">function</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">//判断</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">inorder</span>(root.<span class="property">left</span>)<span class="comment">//先访问左子树</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>)<span class="comment">//访问根节点</span></span><br><span class="line">    <span class="title function_">inorder</span>(root.<span class="property">right</span>)<span class="comment">//访问右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>遍历顺序图<br><img src="https://s2.loli.net/2022/09/18/UGCem8DWR7atn6o.png" alt="QQ截图20220918091819.png"><br>结果图<br><img src="https://s2.loli.net/2022/09/18/DfS3ZzAEIidNbn9.png" alt="QQ截图20220918091844.png"></li></ol><h2 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h2><ol><li>对根节点中的左子树进行遍历</li><li>对根节点的右子树进行遍历</li><li>访问根节点<br>code<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> backorder=<span class="keyword">function</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backorder</span>(root.<span class="property">left</span>);</span><br><span class="line">    <span class="title function_">backorder</span>(root.<span class="property">right</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>遍历顺序<br><img src="https://s2.loli.net/2022/09/18/pdosLHDP3RBNVuS.png" alt="QQ截图20220918092612.png"><br>结果；<br><img src="https://s2.loli.net/2022/09/18/5ayDoIKxzgvPcmO.png" alt="QQ截图20220918092620.png"><br>结果如图<br><img src="https://s2.loli.net/2022/09/17/xjUY4a9K2bX3uMT.png" alt="结果"></li></ol><h3 id="解压小视频"><a href="#解压小视频" class="headerlink" title="解压小视频"></a>解压小视频</h3><iframe height=419 width=745 src='https://player.youku.com/embed/XMzMxMjE0MjY4NA==' frameborder=0 allowfullscreen="true"></iframe>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈结构+一道算法</title>
      <link href="/2022/09/15/%E6%A0%88%E7%BB%93%E6%9E%84+%E7%AE%97%E6%B3%95/"/>
      <url>/2022/09/15/%E6%A0%88%E7%BB%93%E6%9E%84+%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-栈（stack）"><a href="#1-栈（stack）" class="headerlink" title="1.栈（stack）"></a>1.栈（stack）</h2><p><img src="https://s2.loli.net/2022/09/16/PSWIgxmMZ4RKpF9.png" alt="QQ截图20220916150957.png"></p><ol><li>它是一种受限制的线性表，后见先出</li></ol><ul><li>其限制是仅允许在表的一端进行插入和删除操作，这一段被称为<code>栈顶</code>相对地把另一端称为<code>栈底</code></li><li>LIFO表示就是后进入的元素，带一个弹出栈空间，类似于自动餐托盘最后放上托盘，往往先拿出去使用</li><li>向一个栈插入新元素又称作<code>进栈</code>，<code>入栈</code>，或者<code>压栈</code>，他是把新元素放到栈顶元素的上面，使之成为新的栈顶元素</li><li>从一个栈删除元素又称作<code>出栈</code>，或者<code>退栈</code>，他是把栈顶元素删掉，使其相邻的元素成为新的栈顶元素。<h2 id="2-栈结构的实现-例一"><a href="#2-栈结构的实现-例一" class="headerlink" title="2.栈结构的实现  例一"></a>2.栈结构的实现  例一</h2><img src="https://s2.loli.net/2022/09/16/TYaosZUxe2y8bIv.png" alt="QQ截图20220916173538.png"><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestValidParentheses = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxLen = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    stack.<span class="title function_">push</span>(-<span class="number">1</span>) <span class="comment">// 初始化一个参照物</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// ( 入栈   )出栈</span></span><br><span class="line">            stack.<span class="title function_">push</span>(i)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// )的情况 出栈</span></span><br><span class="line">            stack.<span class="title function_">pop</span>()</span><br><span class="line">            <span class="keyword">if</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="comment">// 每次出栈 计算下当前有效连续长度</span></span><br><span class="line">                <span class="comment">// 如何计算连续长度 当前位置 - 栈顶下标  并取值最大的有效长度</span></span><br><span class="line">                maxLen = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLen, i - stack[stack.<span class="property">length</span> - <span class="number">1</span>])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.<span class="title function_">push</span>(i) <span class="comment">//栈为空时 放入右括号参照物 表示从这个下标开始 需要重新计算长度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>利用栈结构解题<h3 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h3><img src="https://s2.loli.net/2022/09/19/rV46HcgxIdEjk5M.png" alt="QQ截图20220919102019.png"></li></ul><p>code</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>%<span class="number">2</span>===<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>  <span class="comment">//如果为奇数  不可能匹配</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> stack=[];<span class="comment">//创建一个空栈</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.<span class="property">length</span>;i++)&#123;<span class="comment">//遍历</span></span><br><span class="line">         <span class="keyword">const</span> c=s[i];<span class="comment">//取得字符</span></span><br><span class="line">         <span class="keyword">if</span>(c===<span class="string">&#x27;[&#x27;</span>||c===<span class="string">&#x27;&#123;&#x27;</span>||c===<span class="string">&#x27;(&#x27;</span>)&#123;<span class="comment">//将右括号入栈，碰到对应的左括号出战</span></span><br><span class="line">             stack.<span class="title function_">push</span>(c);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">const</span> top=stack[stack.<span class="property">length</span>-<span class="number">1</span>];<span class="comment">//取出栈顶元素</span></span><br><span class="line">            <span class="keyword">if</span>((top===<span class="string">&quot;&#123;&quot;</span>&amp;&amp;c==<span class="string">&#x27;&#125;&#x27;</span>)||(top===<span class="string">&quot;(&quot;</span>&amp;&amp;c==<span class="string">&#x27;)&#x27;</span>)||(top===<span class="string">&quot;[&quot;</span>&amp;&amp;c===<span class="string">&#x27;]&#x27;</span>))&#123;    <span class="comment">//如果栈顶元素与之匹配，则出栈</span></span><br><span class="line">                stack.<span class="title function_">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//不匹配直接退出</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//最后判断以下栈中是否有匹配剩下的  有则匹配失败   无则匹配成功</span></span><br><span class="line">     <span class="keyword">return</span> stack.<span class="property">length</span>===<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="JS中的函数调用堆栈"><a href="#JS中的函数调用堆栈" class="headerlink" title="JS中的函数调用堆栈"></a>JS中的函数调用堆栈</h3><p><strong>演示视频</strong></p><iframe height=419 width=745 src='https://player.youku.com/embed/XNTkwNDc3NTQ2MA==' frameborder=0 allowfullscreen='true'></iframe>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS语言基础（一）</title>
      <link href="/2022/09/15/JS%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/09/15/JS%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-严格模式"><a href="#1-严格模式" class="headerlink" title="1.严格模式"></a>1.严格模式</h2><p>严格模式是一种不同的javascript解析和执行的模型，如果要对整个脚本开启严格模式在脚本开头加上<code>use strict</code>虽然看起来没有复制给任何变量的字符串吗，但它其实是一个预处理指令，任何支持JavaScript的引擎看到就会切换到严格模式，</p><h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h2><ul><li>var关键字</li><li>let关键字</li><li>const关键字<h2 id="3-暂时性死区"><a href="#3-暂时性死区" class="headerlink" title="3.暂时性死区"></a>3.暂时性死区</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//name会被提升</span><br><span class="line">console.log(name);//undefined</span><br><span class="line">var name=&quot;小明&quot;;</span><br><span class="line">//name不会提升</span><br><span class="line">console.log(name)//报错</span><br><span class="line">let name=&quot;小明&quot;;</span><br></pre></td></tr></table></figure>在let声明之前的执行瞬间被称为。暂时性死区，在此阶段引用任何后面声明的变量都会抛出<code>ReferenceError</code><h2 id="4-全局声明"><a href="#4-全局声明" class="headerlink" title="4.全局声明"></a>4.全局声明</h2>与var关键字不同，使用let在全局作用域中声明的变量不会成为window对象的属性（var声明的变量则会）;<h2 id="声明风格及最佳实践"><a href="#声明风格及最佳实践" class="headerlink" title="声明风格及最佳实践"></a>声明风格及最佳实践</h2></li><li>不使用var </li><li>const优先 ，let次之</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS基础复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript, </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺时针打印矩阵JS版</title>
      <link href="/2022/09/15/%E5%89%91%E6%8C%87%20Offer%2029.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5(JS%E7%89%88)/"/>
      <url>/2022/09/15/%E5%89%91%E6%8C%87%20Offer%2029.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5(JS%E7%89%88)/</url>
      
        <content type="html"><![CDATA[<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">matrix</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> spiralOrder = <span class="keyword">function</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.<span class="property">length</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(matrix[<span class="number">0</span>].<span class="property">length</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向右  获取长和宽 </span></span><br><span class="line">    <span class="keyword">let</span> height=matrix.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> width=matrix[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> result=[];</span><br><span class="line">    <span class="comment">//向右打印</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;width;i++)&#123;</span><br><span class="line">       result.<span class="title function_">push</span>(matrix[<span class="number">0</span>][i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果有向下的，则向下 不能则返回结果</span></span><br><span class="line">   <span class="keyword">if</span>(height&gt;<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> k=<span class="number">1</span>;k&lt;height;k++)&#123;</span><br><span class="line">           result.<span class="title function_">push</span>(matrix[k][width-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果能向左就向左 不能则返回结果</span></span><br><span class="line">   <span class="keyword">if</span>(width&gt;<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> i=width-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">           result.<span class="title function_">push</span>(matrix[height-<span class="number">1</span>][i]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果能向上 则向上，不能则返回结果</span></span><br><span class="line">   <span class="keyword">if</span>(height&gt;<span class="number">2</span>)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> i=height-<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">           result.<span class="title function_">push</span>(matrix[i][<span class="number">0</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//剥除里面的矩阵  (循环一次减掉两层高度)</span></span><br><span class="line">    <span class="keyword">let</span> inner=<span class="keyword">new</span> <span class="title class_">Array</span>(height-<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;height-<span class="number">2</span>;i++)&#123;</span><br><span class="line">        inner[i]=matrix[i+<span class="number">1</span>].<span class="title function_">slice</span>(<span class="number">1</span>,width-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    result=result.<span class="title function_">concat</span>(<span class="title function_">spiralOrder</span>(inner));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS基础</title>
      <link href="/2022/09/15/JS%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/09/15/JS%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="script元素"><a href="#script元素" class="headerlink" title="script元素"></a>script元素</h1><ol><li>async:可选，表示应该立即开始下载脚本，但是不能阻止其他页面动作，比如下载资源挥着等待其他脚本加载，只对外部脚本有效，</li><li>charset：可选，使用src指定的代码字符集，这个属性很少使用，大多数浏览器不在乎它的值。</li><li>corssorigin:可选，配置相关请求的cors（跨源资源共享）设置，默认不使用CORS,     crossorigin=”use-credentials”设置凭据标志，意味着出站请求会包含凭据，</li><li>defer:可选。表示在问达能解析和显示完成后，再执行脚本是没有有问题的。只对外部脚本有效，</li><li>integrity:可选允许比对接收到的资源和指定的加密协议以验证子资源的完整性，如果接受到的资源的签名，与这个属性指定的签名不匹配则页面报错,脚本不会执行，这个属性可以用与确保内容分发网络不会提供恶意内容</li><li>src:可选。表示要执行的代码的外部文件</li><li>type:可选，用于指定代码块中的语言类型，按照管理，这个始终都是“text/JavaScript”。如果这个值时“module”则代码会被当成ES6模块，<br>包含在script标签里的内容，会从上至下解释，在&lt;\script&gt;元素中的代码被执行完毕之前，页面的其余内容不会被加载，也不会被显示，就形成了阻塞<br>在使用行内&lt;\script&gt;代码时，注意代码中崩出现字符串&lt;\script&gt;。比如以下代码，<br>会导致浏览器报错，浏览器解析行内脚本会将其当乘结束的&lt;\script&gt;的&lt;\script&gt;标签，想避免这个问题，只需要转义字符\即可<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span>  <span class="title function_">msg</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&quot;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>这样修改之后就可以被浏览器完全解释，不会导致任何错误，</li><li>在解释外还不JavaScript文件时页面也会阻塞，（阻塞时间包括文件的下载时间，）在XHTML可以忽略结束标签，</li><li>另外使用了src属性的&lt;\script&gt;的元素不应该在其内部写入代码，如果两种方式都使用的话，则浏览器只会下载执行脚本，而忽略内部代码，</li><li>&lt;\script&gt;最为强大，同时也备受争议的特性时，它可以包含来自外部域的JavaScript代码，与img的src很像<br>“&lt;\script src=’<a href="http://www.baidu.com&/#39;&gt;">www.baidu.com&#39;&gt;</a>&lt;\script&gt;”</li></ol><p>浏览器在计息这个资源时，会向SRC指定的地址发送一个get请求，以取得相应资源，这个初始的请求不受浏览器同源策略限制，但返回被执行的JS代码则受限制，当然请求仍然收父页面HTTP/HTTPS协议的限制</p><p>这就可能收到恶意的攻击，如果引用了别人服务器上的JS文件，就要格外小心，因为恶意的程序员，随时可能替换这个文件，在百翰外部与的JS文件时，要确保该域是自己所有的，或者该域是一个可靠的来源，&lt;\script&gt;时防范这种问题的一个武器，但是不是所有的浏览器都支持，这个属性，</p><p>不管包含的是什么代码，浏览器都会按照&lt;\script&gt;在页面中出现的顺序依次去解析他们，前提是他们没有使用defer和async属性，第二个&lt;\script&gt;代码会在第一个&lt;\script&gt;执行完毕之后进行，第三个会在第二个执行完毕之后进行，依次类推。</p><h1 id="标签位置"><a href="#标签位置" class="headerlink" title="标签位置"></a>标签位置</h1><ol><li>过去所有的&lt;\script&gt;元素都放在head标签内部，如下面的例子，<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">   <span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">HTML</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">title</span>&gt;</span>案例1<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">               这是页面内容</span><br><span class="line">            <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">HTML</span>&gt;</span></span><br><span class="line">```   </span><br><span class="line">这种做法的主要目的，就是把外部的CSS和JavaScript文件都集中到一起，不过把所有JavaScript文件都放在头部，也就意味着必须把所有的JavaScript文件都加载完毕才会开始渲染页面，对于需要很多JavaScript文件的页面这回导致，渲染时间明显变长，在此期间页面窗口完全空白，为解决这个问题，现代web应用程序将所有的Javascript引用放到了&lt;\body&gt;元素中的页面内容之后，如下</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">   <span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">HTML</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">title</span>&gt;</span>案例1<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">               这是页面内容</span><br><span class="line">            <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">HTML</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>推迟执行脚本<br>defer属性，这个属性表示这个脚本在执行的时候不会改变页面结构，完全可以等到整个页面解析完成以后，再运行，这个属性会告诉浏览器，应该立即下载，但执行会延迟，会等待html标签执行完毕之后，再执行</li><li>异步执行脚本<br>async   async与defer相似，都只是用与外部脚本，都会告诉浏览器立即开始下载，不过与defer不同的是，async并不能保证能按照出现的顺序执行，<br>给脚本添加async的目的是告诉浏览器 ，不必等待脚本下载和执行完毕再加载页面，同样也不必等待脚本下载执行完毕。再去执行其他脚本，正因为如此异步脚本不应该在加载期间修改DOM</li></ol><p>4.动态加载脚本</p><p>这个方式不推荐，很影响性能，而且会造成混乱。</p><p>5.行内代码，与外部文件</p><p>这两种方式，比较推荐外部文件，有以下优点</p><p>一.可维护性</p><p>二.缓存，如果两个html文件用到相同的JS文件，浏览器会根据缓存机制，只加载一次。意味着网页的加载速度更快</p><p>三.适应未来，</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>websocket基础</title>
      <link href="/2022/09/10/websocket%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/09/10/websocket%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1-传统的是HTTP模式，"><a href="#1-传统的是HTTP模式，" class="headerlink" title="1.传统的是HTTP模式，"></a>1.传统的是HTTP模式，</h1><p>因为 HTTP 协议有一个缺陷：通信只能由客户端发起 一个request对应一个respond<br>通信是单向的，请求==响应<br>没有请求就没有响应，举个例子：就比如我需要查询天气，只能是从客户端发送请求，接受查询结果。HTTP做不到主动向客户端推送信息，这种单向的请求的特点，注定如果服务器有连续的状态变化，客户端想要及时了解就很不方便，只能通过轮询的方式实现，这样是非常浪费资源的因为需要不停的连接,所以发明了websocket </p><h1 id="2-websocket"><a href="#2-websocket" class="headerlink" title="2.websocket"></a>2.websocket</h1><p>websocket 是一种网络传输协议，可在单个TCP连接进行全双工通信，位于OSI模型的应用层<br>最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话<br>特点：</p><ol><li>TCP连接，与HTTP协议兼容</li><li>双向通信，主动推送（服务端向客户端）</li><li>无同源限制，协议标识符是WS（加密wss）</li></ol><p>应用场景：</p><ul><li><input checked="" disabled="" type="checkbox"> 聊天，消息，点赞，</li><li><input checked="" disabled="" type="checkbox"> 直播弹幕</li><li><input checked="" disabled="" type="checkbox"> 游戏，协同编辑，基于位置的应用</li></ul><h1 id="原生websocket-的简单使用案例"><a href="#原生websocket-的简单使用案例" class="headerlink" title="原生websocket 的简单使用案例"></a>原生websocket 的简单使用案例</h1><p>我使用的node.js平台做的一个服务端，开启websocket服务<br>在sever.js文件中 ,建立服务先安装ws模块<br><code>npm i ws</code><br>在sever.js中</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">WebSocket</span>=<span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);<span class="comment">//引入模块</span></span><br><span class="line"><span class="keyword">const</span> wss=<span class="keyword">new</span> <span class="title class_">WebSocket</span>.<span class="title class_">Server</span>(&#123;<span class="attr">port</span>:<span class="number">3000</span>&#125;);<span class="comment">//监听本地3000端口</span></span><br><span class="line">wss.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>,<span class="function">(<span class="params">ws</span>)=&gt;</span>&#123;<span class="comment">//对连接进行监听</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;监听到服务&quot;</span>);</span><br><span class="line">    ws.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>,<span class="function">(<span class="params">msg</span>)=&gt;</span>&#123;<span class="comment">//同时接受客户端发送的信息</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">    &#125;)</span><br><span class="line">    ws.<span class="title function_">send</span>(<span class="string">&#x27;我是服务端&#x27;</span>);<span class="comment">//向客户端发送的信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>服务端建立好之后接下载，看客户端<br>新建一个HTML文件</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// WebSocket通信测试网址</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> ws=<span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;http://127.0.0.1:3000&#x27;</span>);<span class="comment">//连接本地测试地址</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//实例对象的onopen属性，用于指定连接成功后的回调函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//如果要指定多个回调函数，可以使用addEventListener方法。</span></span></span><br><span class="line"><span class="language-javascript">        ws.<span class="property">onopen</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">lgo</span>(<span class="string">&quot;连接建立成功！&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//建立成功之后 可以使用这个连接对象进行通信发送消息</span></span></span><br><span class="line"><span class="language-javascript">           ws.<span class="title function_">send</span>(<span class="string">&#x27;我是客户端&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        ws.<span class="property">onmessage</span>=<span class="keyword">function</span>(<span class="params">msg</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(msg.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来在控制台输入<code>node sever.js</code>来启动服务<br>在浏览器控制台可以看到<br><img src="https://img-blog.csdnimg.cn/bf21920e35cb4b79ab4f4d5275dd9698.png#pic_center" alt="客户端结果"><br>连接成功，并接收到服务端发来的消息<br>websocket有很多API </p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器(iterator)原理</title>
      <link href="/2022/09/03/%E8%BF%AD%E4%BB%A3%E5%99%A8(iterator)%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/03/%E8%BF%AD%E4%BB%A3%E5%99%A8(iterator)%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><strong>目录</strong></p><p><a href="#1.iterator%E4%BB%8B%E7%BB%8D%C2%A0%20%C2%A0">1.iterator介绍   </a></p><p><a href="#2.itertor%E4%BD%9C%E7%94%A8%C2%A0%20%C2%A0%20%C2%A0%C2%A0">2.itertor作用      </a></p><p><a href="#3.iterator%E7%9A%84%E9%81%8D%E5%8E%86%E5%8E%9F%E7%90%86">3.iterator的遍历原理</a></p><hr><h2 id="1-iterator介绍"><a href="#1-iterator介绍" class="headerlink" title="1.iterator介绍"></a>1.iterator介绍</h2><p>iterator是一种接口，为各种不同数据结构提供一种统一的访问机制，任何数据只要部署iterator接口，就可以完成遍历操作，</p><h2 id="2-itertor作用"><a href="#2-itertor作用" class="headerlink" title="2.itertor作用"></a><strong>2.itertor作用</strong></h2><p> iterator的作用有三个：一是为各种数据结构，提供一个统一的，简便的访问接口；二是使得数据结构的成员能够按照某种次序排列，三是ES6创造了一种新的遍历命令for···of循环，iterator接口主要供for···of消费</p><h2 id="3-iterator的遍历原理"><a href="#3-iterator的遍历原理" class="headerlink" title="3.iterator的遍历原理"></a>3.iterator的遍历原理</h2><p>(1) 创建一个指针对象，指向当前数据结构的起始位置，也就是说，遍历器本质上是一个指针对象</p><p>(2) 第一次调用指针对象的next 方法   可以将指针指向数据结构的第一个成员</p><p>(3) 第二次调用指针对象的next方法   指针对象将指向数据结构的第二个成员</p><p>(4) 不断调用指针对象的next方法， 直到它指向数据结构的结束位置，每一次调用next方法，都会返回数据结构的当前成员信息，具体来说就是返回一个包含value和done  两个属性的对象其中value是当前成员的值，done属性是一个布尔值  ，表示遍历是否结束</p><p><strong>模拟例子</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> it = <span class="title function_">makeIterator</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]);</span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;a&quot;, done: false &#125;</span></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;b&quot;, done: false &#125;</span></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeIterator</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.<span class="property">length</span> ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">        &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>makeIterator是一个迭代器生成函数，作用就是返回一个遍历器对象，对数组[‘a’,’b’]  执行这个函数</p><p>返回该数组的迭代器对象（即指针对象）</p><p> 2021字节跳动web工程师笔试题</p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><blockquote><p>[<br>{num: 12, city: ‘beijing’},<br>{num: 56, city: ‘shanghai’},<br>{num: 167, city: ‘guangzhou’},<br>{num: 23, city: ‘shenzhen’},<br>{num: 45, city: ‘caoxian’}<br>]<br>写一个方法实现把上面的数组转换成下面这种格式：<br>{beijing: 12, shanghai: 56,…}</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = [</span><br><span class="line">           &#123;<span class="attr">num</span>: <span class="number">12</span>, <span class="attr">city</span>: <span class="string">&#x27;beijing&#x27;</span>&#125;,</span><br><span class="line">           &#123;<span class="attr">num</span>: <span class="number">56</span>, <span class="attr">city</span>: <span class="string">&#x27;shanghai&#x27;</span>&#125;,</span><br><span class="line">           &#123;<span class="attr">num</span>: <span class="number">167</span>, <span class="attr">city</span>: <span class="string">&#x27;guangzhou&#x27;</span>&#125;,</span><br><span class="line">           &#123;<span class="attr">num</span>: <span class="number">23</span>, <span class="attr">city</span>: <span class="string">&#x27;shenzhen&#x27;</span>&#125;,</span><br><span class="line">           &#123;<span class="attr">num</span>: <span class="number">45</span>, <span class="attr">city</span>: <span class="string">&#x27;caoxian&#x27;</span>&#125;</span><br><span class="line">               ]</span><br><span class="line">           <span class="keyword">let</span> res=&#123;&#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;obj.<span class="property">length</span>;i++)&#123;</span><br><span class="line">               res[obj[i].<span class="property">city</span>]=obj[i].<span class="property">num</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure><p>遍历数组添加到对象就行了</p><p>        本周主要进行了复习，对JS基础  JS高级  ES6进行了回顾  剩余时间在学习Vue  加油！</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回顾express</title>
      <link href="/2022/08/14/%E5%9B%9E%E9%A1%BEexpress/"/>
      <url>/2022/08/14/%E5%9B%9E%E9%A1%BEexpress/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="1-express-是什么"><a href="#1-express-是什么" class="headerlink" title="1.express 是什么"></a>1.express 是什么</h2><p>Express 是一个基于 <a href="https://so.csdn.net/so/search?q=Node&spm=1001.2101.3001.7020" title="Node">Node</a>平台的Web应用开发框架，它提供了一系列的强大特性，帮助你创建各种Web应用。</p><h2 id="2-Express-框架特性"><a href="#2-Express-框架特性" class="headerlink" title="2 .Express 框架特性"></a>2 .Express 框架特性</h2><ul><li>提供了<strong>简洁的路由定义</strong>方式</li><li>对获取 http <strong>请求参数</strong>进行了<strong>简化处理</strong></li><li>对<strong>模板引擎支持程度高</strong>，方便渲染动态HTML页面</li><li>拥有<strong>中间件</strong>机制有效<strong>控制 HTTP 请求</strong></li><li>拥有大量第三方中间件对功能进行扩展</li></ul><h2 id="3-原生-node-js-与-Express-框架对比"><a href="#3-原生-node-js-与-Express-框架对比" class="headerlink" title="3 .原生 node.js 与 Express 框架对比"></a>3 .原生 node.js 与 Express 框架对比</h2><p><img src="https://img-blog.csdnimg.cn/422f6da8b6d34336ae69e70859163419.png" alt="422f6da8b6d34336ae69e70859163419.png"></p><p><img src="https://img-blog.csdnimg.cn/e9c435389c0542b5b5da8e592be66431.png" alt="e9c435389c0542b5b5da8e592be66431.png"> </p><h2 id="4-中间件"><a href="#4-中间件" class="headerlink" title="4.中间件"></a>4.中间件</h2><p> </p><p><img src="https://img-blog.csdnimg.cn/55bd7475882742339b921dc03a8d95e8.png" alt="55bd7475882742339b921dc03a8d95e8.png"></p><p><img src="https://img-blog.csdnimg.cn/647096f6d82246239deb7a99732285b2.png" alt="647096f6d82246239deb7a99732285b2.png"> </p><p><img src="https://img-blog.csdnimg.cn/27cf49b6412f40669e23658c0d81748b.png" alt="27cf49b6412f40669e23658c0d81748b.png"> </p><h2 id="5-中间件应用"><a href="#5-中间件应用" class="headerlink" title="5  中间件应用"></a>5  中间件应用</h2><h3 id="路由保护："><a href="#路由保护：" class="headerlink" title="路由保护："></a>路由保护：</h3><p>客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。</p><p>错误处理中间件</p><p>  本周还是对项目的完善，使之更加严谨可用，</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓展运算符是深拷贝还是浅拷贝</title>
      <link href="/2022/08/07/%E6%8B%93%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%BF%98%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2022/08/07/%E6%8B%93%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%BF%98%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>对于拓展运算符是深拷贝还是浅拷贝网上怎么说的都有，我就说一下我的理解。</p><p><strong>什么是深拷贝？什么是浅拷贝？</strong></p><p>假如B复制了A，修改A的时候，看B是否发生变化：</p><p>如果B也跟着<strong>变</strong>了，说明是浅拷贝，拿别人手段！</p><p>如果B<strong>没有改变</strong>，说明是深拷贝，自食其力！</p><p><strong>怎么判断拓展运算符是什么拷贝呢？</strong></p><p>看一下下面的例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"> <span class="keyword">let</span> b = [...a];</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//[1,2,3]</span></span><br><span class="line"> a[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//[1,4,3]</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure><p>结合浅拷贝和深拷贝的概念，那拓展运算符是不是深拷贝？别急看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> peoples = [&#123;<span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">sex</span>:<span class="string">&quot;男&quot;</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&#x27;ls&#x27;</span>,<span class="attr">age</span>:<span class="number">16</span>,<span class="attr">sex</span>:<span class="string">&quot;女&quot;</span>&#125;];</span><br><span class="line">  <span class="keyword">let</span> peoplesTwo = [...peoples];</span><br><span class="line">  peoples[<span class="number">0</span>].<span class="property">age</span> = <span class="number">22</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(peoples);<span class="comment">//[&#123;name:&#x27;zs&#x27;,age:22,sex:&quot;男&quot;&#125;,&#123;name:&#x27;ls&#x27;,age:16,sex:&quot;女&quot;&#125;]</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(peoplesTwo);<span class="comment">//[&#123;name:&#x27;zs&#x27;,age:22,sex:&quot;男&quot;&#125;,&#123;name:&#x27;ls&#x27;,age:16,sex:&quot;女&quot;&#125;]</span></span><br></pre></td></tr></table></figure><p>结合浅拷贝和深拷贝的概念，那拓展运算符是不是浅拷贝？</p><p>所以结合上面两个例子得出一个结论，拓展运算符是深拷贝还是浅拷贝是看具体拷贝内容的，当拷贝的内容只有一层时是深拷贝，层数很多时时浅拷贝，如果还是不太理解可以先看深拷贝和浅拷贝的定义然后自己手敲一下代码，</p><p>        加油</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript vue.js 开发语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目总结篇</title>
      <link href="/2022/07/31/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E7%AF%87/"/>
      <url>/2022/07/31/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>        从开始项目到现在也快40天了，在这个过程中不得不说，交流真的很重要，要是交流多一点，项目估计早就完成了，找bug也找的差不多了，项目现在还有些功能不太完善，学分认证系统功能应该朝着实用性，和安全性出发，这是最重要的，还有交互体验很重要，能够简单明了的一眼看出网站的使用规则，而不是功能隐藏起来，轻松上手，快速使用。</p><p>        项目bug正在修复，代码嵌入，功能失效·······啥的，正在改,还有交互体验上，各种信息的提示需要做出来，给用户足够的反馈信息。明白咋回事，</p><p>        学习方面，主要还是项目经验吧，还有各种第三方工具的使用，接下来继续努力，加油</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 java html 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS通过文件URL路径下载文件</title>
      <link href="/2022/07/24/JS%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6URL%E8%B7%AF%E5%BE%84%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/"/>
      <url>/2022/07/24/JS%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6URL%E8%B7%AF%E5%BE%84%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">exportFile</span> <span class="operator">=</span> (data, fileName, _this)=&gt;&#123;</span><br><span class="line">　<span class="comment">// 地址不存在时，禁止操作</span></span><br><span class="line">  <span class="keyword">if</span>(!data)<span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 下载文件并保存到本地</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">callback</span> <span class="operator">=</span> (data)=&gt;&#123;</span><br><span class="line">　　 <span class="comment">// 创建a标签，使用 html5 download 属性下载，</span></span><br><span class="line">    <span class="type">const</span> <span class="variable">link</span> <span class="operator">=</span> document.createElement(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">　　 <span class="comment">// 创建url对象</span></span><br><span class="line">    <span class="type">const</span> <span class="variable">objectUrl</span> <span class="operator">=</span> window.URL.createObjectURL(<span class="keyword">new</span> <span class="title class_">Blob</span>([data]));</span><br><span class="line">    link.style.display=<span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    link.href=objectUrl;</span><br><span class="line">　　 <span class="comment">// 自定义文件名称， fileName</span></span><br><span class="line">　　 link.download = fileName; </span><br><span class="line">　　 document.body.appendChild(link); </span><br><span class="line">　　 link.click();</span><br><span class="line">　　 <span class="comment">// 适当释放url</span></span><br><span class="line">    window.URL.revokeObjectURL(objectUrl);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 把接口返回的url地址转换为 blob</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">xhr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.open(<span class="string">&#x27;get&#x27;</span>, data, <span class="literal">true</span>);</span><br><span class="line">  xhr.responseType = <span class="string">&#x27;blob&#x27;</span>;</span><br><span class="line">  xhr.onload = ()=&gt; &#123;</span><br><span class="line">　　 <span class="comment">// 返回文件流，进行下载处理</span></span><br><span class="line">    callback(xhr.response);</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.send(); <span class="comment">// 不要忘记发送</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ie和浏览器兼容模式会有问题，可以用下面代码调试。</span></span><br><span class="line">　<span class="keyword">try</span>&#123;</span><br><span class="line">    exportFile(); <span class="comment">// 调用方式</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="comment">// 兼容模式下，IE</span></span><br><span class="line">    <span class="type">const</span> <span class="variable">exportBlob</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Blob</span>([data]);</span><br><span class="line">    <span class="keyword">if</span> (navigator.userAgent.indexOf(<span class="string">&#x27;Trident&#x27;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      window.navigator.msSaveBlob(data, fileName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      exportFile(); <span class="comment">// 调用方式</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>调用方式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">exportFile</span>(<span class="string">&#x27;https://reading.oss.iyougu.com/uploads/mp/opus/1c5a8b6a391742cf93595d0a506b2d43.mp3&#x27;</span>, <span class="string">&#x27;测试.mp3&#x27;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript 前端 开发语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="/2022/07/17/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/17/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><strong>一、基本命令</strong><br>1.1 关机和重启<br>关机<br>    shutdown -h now        立刻关机<br>    shutdown -h 5        5分钟后关机<br>    poweroff            立刻关机<br>重启<br>    shutdown -r now        立刻重启<br>    shutdown -r 5        5分钟后重启<br>    reboot                立刻重启</p><h2 id="1-2-帮助命令"><a href="#1-2-帮助命令" class="headerlink" title="1.2 帮助命令"></a>1.2 帮助命令</h2><p>--help命令<br>  shutdown --help：<br>  ifconfig  --help：查看网卡信息<br> <br>man命令（命令说明书） <br>  man shutdown<br>  注意：man shutdown打开命令说明书之后，使用按键q退出</p><p><strong>二、目录操作命令</strong><br>2.1 目录切换 cd<br>命令：cd 目录</p><p>cd /        切换到根目录<br>cd /usr        切换到根目录下的usr目录<br>cd ../        切换到上一级目录 或者  cd ..<br>cd ~        切换到home目录<br>cd -        切换到上次访问的目录</p><p><strong>2.2 目录查看 ls [-al]</strong><br>命令：ls [-al]</p><p>ls                查看当前目录下的所有目录和文件<br>ls -a            查看当前目录下的所有目录和文件（包括隐藏的文件）<br>ls -l 或 ll       列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）<br>ls /dir            查看指定目录下的所有目录和文件   如：ls /usr</p><p><strong>2.3 目录操作【增，删，改，查】</strong><br>2.3.1 创建目录【增】 mkdir<br>命令：mkdir 目录</p><p>mkdir    aaa            在当前目录下创建一个名为aaa的目录<br>mkdir    /usr/aaa    在指定目录下创建一个名为aaa的目录</p><p><strong>2.3.2 删除目录或文件【删】rm</strong><br>命令：rm [-rf] 目录</p><p>删除文件：<br>rm 文件        删除当前目录下的文件<br>rm -f 文件    删除当前目录的的文件（不询问）</p><p>删除目录：<br>rm -r aaa    递归删除当前目录下的aaa目录<br>rm -rf aaa    递归删除当前目录下的aaa目录（不询问）</p><p>全部删除：<br>rm -rf *    将当前目录下的所有目录和文件全部删除<br>rm -rf /*    【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除</p><p>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录/文件/压缩包   </p><p>正在学习，，，</p><p>本周呢，还是以项目为主又完成了一些功能，马上就能做完了，加油</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本周学习总结</title>
      <link href="/2022/07/03/%E6%9C%AC%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/03/%E6%9C%AC%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>        </p><h2 id="1使用-Bootstrap-构建快速、响应式布局的网站"><a href="#1使用-Bootstrap-构建快速、响应式布局的网站" class="headerlink" title="1使用 Bootstrap 构建快速、响应式布局的网站"></a><strong>1使用 Bootstrap 构建快速、响应式布局的网站</strong></h2><p><a href="https://so.csdn.net/so/search?q=Bootstrap&spm=1001.2101.3001.7020" title="Bootstrap">Bootstrap</a> 是全球最流行的前端开源工具包，它支持 Sass 变量和 mixins、响应式网格系统、大量的预建组件和强大的 JavaScript 插件，助你快速设计和自定义响应式、移动设备优先的站点。</p><h2 id="2-布局容器"><a href="#2-布局容器" class="headerlink" title="** 2.布局容器**"></a>** 2.布局容器**</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span><br><span class="line">.<span class="property">container</span>-<span class="attr">fluid</span>:横跨视口的全宽度的容器。</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    .container：有最大固定宽度的容器。最大固定宽度依据于视口（viewport）的断点（breakpoints）而不同。</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="3-网格系统"><a href="#3-网格系统" class="headerlink" title="3.网格系统"></a>3.网格系统</h2><p>Bootstrap 4 网格系统有以下 5 个类:</p><p>.col- 针对所有设备<br>.col-sm- 平板 - 屏幕宽度等于或大于 576px<br>.col-md- 桌面显示器 - 屏幕宽度等于或大于 768px)<br>.col-lg- 大桌面显示器 - 屏幕宽度等于或大于 992px)<br>.col-xl- 超大桌面显示器 - 屏幕宽度等于或大于 1200px)<br>        这周主要就是学习使用了<strong>Bootstrap5</strong> 写网页，学习了使用axios 对第三方接口进行请求，统一配置请求头，请求拦截器，响应拦截器，对错误代码同意管理，接下来就是尽量熟练的使用axios,完成交互任务，��数据做点什么<br>    return response;<br>  }, function (error) {<br>    // 对响应错误做点什么<br>    return Promise.reject(error);<br>  });<br>```</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本周学习笔记</title>
      <link href="/2022/06/26/%E6%9C%AC%E5%91%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/06/26/%E6%9C%AC%E5%91%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>一、node.js简介</p><p> </p><p>1.Node.js是一个能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境。</p><p>2.Node采用Google开发的V8引擎运行js代码，使用事件驱动、非阻塞和异步I/O模型等技术来提高性能，可优化应用程序的传输量和规模。</p><p>3.Node大部分基本模块都用JavaScript编写。在Node出现之前，JS通常作为客户端程序设计语言使用，以JS写出的程序常在用户的浏览器上运行。</p><p>3.目前，Node已被IBM、Microsoft、Yahoo!、Walmart、Groupon、SAP、 LinkedIn、Rakuten、PayPal、Voxer和GoDaddy等企业采用</p><p>4.Node主要用于编写像Web服务器一样的网络应用，这和PHP和Python是类似的。</p><p>但是Node与其他语言最大的不同之处在于，PHP等语言是阻塞的而Node是非阻塞的。</p><p>Node是事件驱动的。开发者可以在不使用线程的情况下开发出一个能够承载高并发的服务器。其他服务器端语言难以开发高并发应用，而且即使开发出来，性能也不尽人意。</p><p>Node正是在这个前提下被创造出来。</p><p>Node把JS的易学易用和Unix网络编程的强大结合到了一起。</p><p>5.Node.js允许通过JS和一系列模块来编写服务器端应用和网络相关的应用。</p><p>6.核心模块包括文件系统I/O、网络（HTTP、TCP、UDP、DNS、TLS/SSL等）、二进制数据流、加密算法、数据流等等。Node模块的API形式简单，降低了编程的复杂度。</p><p>7.使用框架可以加速开发。常用的框架有Express.js、Socket.IO和Connect等。Node.js的程序可以在Microsoft Windows、Linux、Unix、Mac OS X等服务器上运行。</p><p>8.Node.js也可以使用CoffeeScript、TypeScript、Dart语言，以及其他能够编译成JavaScript的语言编程。</p><p>二.Node.Js用途</p><p> </p><p>1.Web服务API，比如REST</p><p>实时多人游戏</p><p>2.后端的Web服务，例如跨域、服务器端的请求</p><p>3.基于Web的应用</p><p>多客户端的通信，如即时通信</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 javascript node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一周学习总结</title>
      <link href="/2022/06/19/%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2022/06/19/%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>这一周，按照学习计划学习了node.js及相关的内容，学习了一个简单的数据库，我感觉真的要是精通node.js那真的是非常厉害，几乎是想做什么就做什么，接下来我将会进行实践练习，加深理解，更加熟练的运用，该与对于项目结构的规范都要进行实践练习，</p><p>        这段时间的学习，感觉到挺充实的，相比整天在家玩耍好得多，每天按时规律起床,晚上出去跑个步，其余时间用来敲代码我感觉还是很好的，我的许多同学都外出打工了，确实能挣到很多钱，但是他们的能力在原地踏步，不羡慕他们，加油提升自己更重要</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PS学习总结</title>
      <link href="/2022/06/11/PS%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2022/06/11/PS%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>        这周对PS进行了基础的学习，简单的操作，抠图，蒙版的使用，调色，各种工具的使用都应经学会了，其实PS大有可学，因为我不是专业的，仅仅学习了PS的一点皮毛，这些皮毛就已经够我用的了，这是用来找新做东西用的，希望我能够为招新做点什么，让宣传海报更加具有吸引力，</p><p>        这周呢，在家学习感到是时间很是充足，想学什么都有时间，下一阶段要学习node.js这是一个用js做后端的一个基于V8的一个运行环境，感觉学完这个就能够自己做一整个项目了，既有前端，又有后端，我会更加努力的，这个的学习是对JS的基础的考验，平时会多看看红宝书，加强自己的基础知识，巩固一下，学好node.js,就想做什么就做什么了，自己一个人就能完成前后端的工作,加油，不过最近要把考试课复习一下，还有一场考试加油！</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目继续进行</title>
      <link href="/2022/05/15/%E9%A1%B9%E7%9B%AE%E7%BB%A7%E7%BB%AD%E8%BF%9B%E8%A1%8C/"/>
      <url>/2022/05/15/%E9%A1%B9%E7%9B%AE%E7%BB%A7%E7%BB%AD%E8%BF%9B%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>  这次的考核内容的完善项目，我准备把项目进行进一步的完善，改一改bug，这次新加的内容全部使用原生JS，除了ajax 用JQ其他的都使用原生的，本次后端使用了spring boot 这就要求我们要使用th前几天我对th进行了学习，现在项目到了后期阶段，想要全换成th是不太可能的，再写的内容尽量使用th，我会吸取上次的教训，把学长们提出的问题进行修复，使得页面看起来更加合理，各种内容的分页处理，增删改查，美食网站，我尽量让它看起来像美食网站，</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美食项目考核总结</title>
      <link href="/2022/05/08/%E7%BE%8E%E9%A3%9F%E9%A1%B9%E7%9B%AE%E8%80%83%E6%A0%B8%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/08/%E7%BE%8E%E9%A3%9F%E9%A1%B9%E7%9B%AE%E8%80%83%E6%A0%B8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>从项目开始到结束，经过了差不多一个月，项目功能基本实现，考核中，才知道自己原来还有很多问题没有考虑周到，这次之后我会格外注意，各种漏洞，要尽可能去想用户会怎么操作做这个页面，应对多种情况，防止一些操作直接使得网页崩溃，这次考核中出现的很多问题，例如用户界面的关注，收藏什么的没有做成分页的形式，导致内容很多的时候浏览器压力很大，导致崩溃，项目后续会进行完善，增加功能，同时修改原先的bug,增加更加人性化的操作，还有在css动画效果上，我会尽量使用原生的js,css去写动画效果，JQ只用一个ajax就够了，锻炼自己的能力，项目上我负责的是网站前台部分。整个部分的结构不复杂，应用的技术不是不是很难，这次主要锻炼一下使用promise的能力。才知道，promise的状态只能改变一次，要不就重新返回一个new promise</p><p>我们项目组三个人，两个前端，一个后端，合作起来还算可以，进度基本能够相互配合，这次考核学到很多东西，有了做项目的经验，团队合作，分工好，才能更高效的完成任务，前后端交流好,互相说明一下需求，交互起来更加容易，得心应手。这次的评论我做的不好，评论的回复，子评论的回复后显示，直接刷新整个评论，这样确实更简单了，但是确实多流量的浪费，如果评论有很多那么就会非常浪费资源，接下来我会尽量改进这个评论功能；</p><p>        考核中没有使用thymeleaf,这是应该会的，但是我不太会用，所以从一开始就没有用，到了中期再用也比较麻烦。下次有机会一定会用的，这个方法,thymeleaf的话，是在服务器渲染页面，而直接ajax是再客户端渲染页面，</p><p>        下一阶段，我计划加强自己的代码规范，尽量原生JS写所有的内容，加油</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 css3 html 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目最后总结</title>
      <link href="/2022/04/30/%E9%A1%B9%E7%9B%AE%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93/"/>
      <url>/2022/04/30/%E9%A1%B9%E7%9B%AE%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>        这次项目就快要结束了，项目希望这几天能够做完，做好，保质保量， 最后会进行bug测试，尽量使得项目能够像一个正常的网站能够正常使用，在这一周的的过程中，发现项目还是有点不够人性化，希望让用户用着舒服，不追求功能多么厉害，但是要好用，评论还差点，希望我能够顺利完成，之后会进行拓展功能的实现，后台希望能够尽快与网页主体实现正常功能。</p><p>其他也没什么说的</p><p>把我项目的工具库函数发出来吧</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getStyle</span>(<span class="params">obj, name</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">getComputedStyle</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">getComputedStyle</span>(obj, <span class="literal">null</span>)[name];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> obj.<span class="property">currentStyle</span>[name];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">imgup</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> file = obj.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line"><span class="keyword">let</span> name1 = obj.<span class="property">parentNode</span>.<span class="property">children</span>[<span class="number">0</span>];</span><br><span class="line">reader.<span class="title function_">readAsDataURL</span>(file);</span><br><span class="line">reader.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span><br><span class="line"><span class="comment">/*  $(name).attr(&quot;src&quot;, ev.target.result); */</span></span><br><span class="line">name1.<span class="title function_">setAttribute</span>(<span class="string">&quot;src&quot;</span>, ev.<span class="property">target</span>.<span class="property">result</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outdifficulty</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> text = obj.<span class="property">innerText</span>;</span><br><span class="line">$(<span class="string">&quot;.pr-inner-xz:eq(0)&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;value&quot;</span>, text);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outdifficulty2</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> text = obj.<span class="property">innerText</span>;</span><br><span class="line">$(<span class="string">&quot;.pr-inner-xz:eq(1)&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;value&quot;</span>, text);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除功能</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">del</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> a = obj.<span class="property">parentNode</span>;</span><br><span class="line">a.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">del1</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> a = obj.<span class="property">parentNode</span>.<span class="property">parentNode</span>;</span><br><span class="line">a.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">userkouweitext</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> text = obj.<span class="property">innerText</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span><br><span class="line">$(<span class="string">&quot;.kouweiinput&quot;</span>).<span class="title function_">val</span>(text);</span><br><span class="line">$(<span class="string">&quot;.kouweilist&quot;</span>).<span class="title function_">fadeOut</span>(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pushcode</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line"><span class="attr">async</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="attr">dataType</span>:<span class="string">&quot;json&quot;</span>,</span><br><span class="line"><span class="attr">type</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line"><span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/user/getSession&quot;</span>,</span><br><span class="line"><span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">date</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (date.<span class="property">data</span> == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">obj.<span class="property">src</span> = <span class="string">&quot;http://localhost:8080/recipe/getCode?id=&quot;</span> +date.<span class="property">data</span>.<span class="property">id</span>+ <span class="string">&quot;&amp;&quot;</span> + <span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pushcode2</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line"><span class="attr">async</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="attr">dataType</span>:<span class="string">&quot;json&quot;</span>,</span><br><span class="line"><span class="attr">type</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line"><span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/user/getSession&quot;</span>,</span><br><span class="line"><span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">date</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (date.<span class="property">data</span> == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">obj.<span class="property">src</span> = <span class="string">&quot;http://localhost:8080/menu/getCode?id=&quot;</span> +date.<span class="property">data</span>.<span class="property">id</span>+ <span class="string">&quot;&amp;&quot;</span> + <span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outlogin</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> userimgtab = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;userimgmodel&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> longin = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;longin&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">userimgtab.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">longin.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">$.<span class="title function_">get</span>(<span class="string">&quot;http://localhost:8080/user/exist&quot;</span>,</span><br><span class="line">&#123;&#125;,</span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">assign</span>(<span class="string">&#x27;./home-page.html&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logintest</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> userimgtab = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;userimgmodel&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> admin=<span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;userimgtab&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> longin = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;longin&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line"><span class="attr">async</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="attr">dataType</span>:<span class="string">&quot;json&quot;</span>,</span><br><span class="line"><span class="attr">type</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line"><span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/user/getSession&quot;</span>,</span><br><span class="line"><span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">date</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (date.<span class="property">data</span> == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">userimgtab.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">longin.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">userimgtab.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">longin.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(date.<span class="property">data</span>.<span class="property">sign</span>==<span class="number">1</span>)&#123;</span><br><span class="line">$(admin.<span class="property">children</span>[<span class="number">0</span>]).<span class="title function_">append</span>(<span class="string">`&lt;li&gt;&lt;a href=&quot;./back-html/background.html&quot;&gt;进入后台&lt;/a&gt;&lt;/li&gt;`</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;普通用户&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">upmsg</span>(<span class="params">param</span>) &#123;</span><br><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line"><span class="attr">async</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="attr">dataType</span>:<span class="string">&quot;json&quot;</span>,</span><br><span class="line"><span class="attr">type</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line"><span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/user/getSession&quot;</span>,</span><br><span class="line"><span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">date</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (date.<span class="property">data</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">$.<span class="title function_">get</span>(<span class="string">&quot;http://localhost:8080/user/getUser&quot;</span>,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;id&quot;</span>: date.<span class="property">data</span>.<span class="property">id</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">function</span> (<span class="params">date</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> userimgmodel = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;userimgmodel&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">$(userimgmodel.<span class="property">children</span>[<span class="number">0</span>].<span class="property">children</span>[<span class="number">0</span>]).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>, date.<span class="property">data</span>.<span class="property">userInfo</span>.<span class="property">photo</span>);</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取URL传递的参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getQueryVariable</span>(<span class="params">variable</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> query = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>.<span class="title function_">substring</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> vars = query.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vars.<span class="property">length</span>; i++) &#123;</span><br><span class="line"><span class="keyword">var</span> pair = vars[i].<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pair[<span class="number">0</span>] == variable) &#123; <span class="keyword">return</span> pair[<span class="number">1</span>]; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getQueryVariable2</span>(<span class="params">variable, url</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> query = url.<span class="title function_">substring</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> vars = query.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vars.<span class="property">length</span>; i++) &#123;</span><br><span class="line"><span class="keyword">var</span> pair = vars[i].<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pair[<span class="number">0</span>] == variable) &#123; <span class="keyword">return</span> pair[<span class="number">1</span>]; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasclass</span>(<span class="params">obj, join</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;\\b&quot;</span> + join + <span class="string">&quot;\\b&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> reg.<span class="title function_">test</span>(obj.<span class="property">className</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addClass</span>(<span class="params">obj, join</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_">hasclass</span>(obj, join)) &#123;</span><br><span class="line">obj.<span class="property">className</span> += <span class="string">&quot; &quot;</span> + join;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deleteclass</span>(<span class="params">obj, join</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;\\b&quot;</span> + join + <span class="string">&quot;\\b&quot;</span>);</span><br><span class="line">obj.<span class="property">className</span> = obj.<span class="property">className</span>.<span class="title function_">replace</span>(reg, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">statuswitch</span>(<span class="params">i</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> type1 = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;type-head&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="title function_">deleteclass</span>(type1.<span class="property">children</span>[i], <span class="string">&quot;active&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;.state:eq(&quot;</span> + (i + <span class="number">2</span>) + <span class="string">&quot;)&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;#020202&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">$(<span class="string">&quot;.state:eq(&quot;</span> + (i + <span class="number">2</span>) + <span class="string">&quot;)&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;rgb(255,197,82)&quot;</span>);</span><br><span class="line"><span class="title function_">addClass</span>(type1.<span class="property">children</span>[i], <span class="string">&quot;active&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;.content2&quot;</span>).<span class="title function_">empty</span>();</span><br><span class="line"><span class="comment">//清空后用根据选择的项目进行ajax请求获取对应数据</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------</span></span><br><span class="line"><span class="comment">//收藏内部的加载</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">$(<span class="string">&quot;.recipe-head&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;display&quot;</span>, <span class="string">&quot;block&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;.content2&quot;</span>).<span class="title function_">empty</span>();</span><br><span class="line"><span class="comment">//ajax请求收藏菜谱的数据！！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">$(<span class="string">&quot;.recipe-head&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;display&quot;</span>, <span class="string">&quot;none&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">search</span>(<span class="params">param</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> tabsearchcontent = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;tabsearchcontent&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tabsearchcontent.<span class="property">value</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">assign</span>(<span class="string">`searchpage.html?name=<span class="subst">$&#123;tabsearchcontent.value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>  <span class="title function_">zuiresousuo</span>(<span class="params">obj</span>) &#123; </span><br><span class="line"><span class="keyword">let</span> url=<span class="built_in">encodeURI</span>(<span class="string">`searchpage.html?name=<span class="subst">$&#123;obj.children[<span class="number">0</span>].innerText&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">assign</span>(url);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">search1</span>(<span class="params">param</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> tabsearchcontent = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;tabsearchcontent&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tabsearchcontent.<span class="property">value</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">assign</span>(<span class="string">`../searchpage.html?name=<span class="subst">$&#123;tabsearchcontent.value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fenlei</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> url=<span class="built_in">encodeURI</span>(<span class="string">`../searchpage.html?name=<span class="subst">$&#123;obj.innerText&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">assign</span>(url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fenlei1</span>(<span class="params">obj</span>) &#123;  </span><br><span class="line"><span class="keyword">let</span> url=<span class="built_in">encodeURI</span>(<span class="string">`./searchpage.html?name=<span class="subst">$&#123;obj.innerText&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">assign</span>(url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">textnums</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">value</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">200</span>-obj.<span class="property">value</span>.<span class="property">lenght</span>&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">obj.<span class="property">value</span>.<span class="property">lenght</span>=<span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"> $(<span class="string">&quot;.talknums&quot;</span>).<span class="title function_">text</span>(<span class="string">`还可以输入<span class="subst">$&#123;<span class="number">200</span>-obj.value.length&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">zitinums</span>(<span class="params">obj</span>)&#123;</span><br><span class="line"><span class="keyword">let</span> obj1=obj.<span class="property">parentNode</span>;</span><br><span class="line"><span class="keyword">let</span> kuang=obj1.<span class="property">children</span>[<span class="number">1</span>].<span class="property">children</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="number">200</span>-obj.<span class="property">value</span>.<span class="property">lenght</span>&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">obj.<span class="property">value</span>.<span class="property">lenght</span>=<span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">$(kuang).<span class="title function_">text</span>(<span class="string">`还可以输入<span class="subst">$&#123;<span class="number">200</span>-obj.value.length&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有注释，因为也就我一个人看😎</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本周项目总结</title>
      <link href="/2022/04/23/%E6%9C%AC%E5%91%A8%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2022/04/23/%E6%9C%AC%E5%91%A8%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>这周我们组后端接口提供的差不多了，压力来到了我们前端，这周完成了主页面的热门菜谱显示，菜单的上传，用户界面的中，菜谱菜单的显示，及菜谱的删除功能，菜谱详情页的展示，关注和收藏，对登录注册页面的重写，美化了用户界面，判断更加严谨，</p><p>在交互中遇到了很多问题，不过都是些小问题，只要交流好都不是问题，这周的交互中，主要是对以前不合理的地方进行修改，代码更加具有普适性，可以搬运，减少重复性劳动，JS中还是要注意规范，不然一个小错误，可能会浪费大量的时间,很难发现</p><p>下周，我计划把网站主体所有功能全部实现，当然评论功能不在其中，因为想要实现一个好的评论功能，可能需要大量的时间，等把主要功能做的差不多了，再去做评论，还有就是上传数据的前端判断，下周把上传相关的判断给完善一下，防止错误数据和空数据的上传，还有界面的美化，感觉还是主要在我们前端，各种交互，需要总结一下经验，如果还有时间，会继续增加功能，</p><p>最后分享一个正则表达式</p><p>是用来检测邮箱的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^[0-9a-zA-Z_.-]+[@][0-9a-zA-Z_.-]+([.][a-zA-Z]+)&#123;1,2&#125;$/</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周总结关于项目</title>
      <link href="/2022/04/16/%E5%91%A8%E6%80%BB%E7%BB%93%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE/"/>
      <url>/2022/04/16/%E5%91%A8%E6%80%BB%E7%BB%93%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>这周静态页面基本已经完工，没剩几个页面了，</p><p>在交互方面实现了，用户的登录注册，账户信息的修改，菜谱步骤的上传（实现了一半），这周的交互我发现前后端传收数据，需要确定好发送的格式，需要与后端讨论好如何去存储一些信息，此次的图片上传中，学会了使用JS原生的FormData来传输文件，传输文件时要使用$.ajax而不能直接使用$.post因为需要调整一些参数的类型，</p><p>如下是一个例子</p><p>我使用$.ajax传输一个图片文件</p><p>其中把</p><p>contentType设置成了false</p><p>processData设置成了false</p><p>就时不对我所发送的数据做处理；直接发送</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">userimg2</span>(<span class="params">param</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> file=param.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">let</span> senddata = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">   senddata.<span class="title function_">append</span>(<span class="string">&quot;file&quot;</span>,file);</span><br><span class="line">   senddata.<span class="title function_">append</span>(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">let</span> ready = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">   $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&quot;http://10.102.241.171:8080/user/insertUserPhoto&quot;</span>,</span><br><span class="line">      <span class="attr">data</span>: senddata,</span><br><span class="line">      <span class="attr">contentType</span>:<span class="literal">false</span>,</span><br><span class="line">      <span class="attr">processData</span>:<span class="literal">false</span>,</span><br><span class="line">      <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span>(response.<span class="property">msg</span>==<span class="string">&quot;插入成功！&quot;</span>)&#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">msg</span>);</span><br><span class="line">            <span class="keyword">let</span> name1 = param.<span class="property">parentNode</span>.<span class="property">parentNode</span>.<span class="property">children</span>[<span class="number">0</span>];</span><br><span class="line">            ready.<span class="title function_">readAsDataURL</span>(file);</span><br><span class="line">            ready.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span><br><span class="line">               name1.<span class="title function_">setAttribute</span>(<span class="string">&quot;src&quot;</span>,ev.<span class="property">target</span>.<span class="property">result</span>);</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">error</span>:<span class="keyword">function</span> (<span class="params">param</span>) &#123;</span><br><span class="line">         <span class="title function_">alert</span>(<span class="string">&quot;失败了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有就是，插入图片的直接显示</p><p>如下传入一个类型为file的input </p><p>通过readAsDataUrl把文件转为base64格式直接赋给img的src属性就能显示了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">imgup</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> file=obj.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> reader = <span class="keyword">new</span>  <span class="title class_">FileReader</span>();</span><br><span class="line"><span class="keyword">let</span> name1=obj.<span class="property">parentNode</span>.<span class="property">children</span>[<span class="number">0</span>];</span><br><span class="line">     reader.<span class="title function_">readAsDataURL</span>(file);</span><br><span class="line">     reader.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span><br><span class="line">        <span class="comment">/*  $(name).attr(&quot;src&quot;, ev.target.result); */</span></span><br><span class="line"> name1.<span class="title function_">setAttribute</span>(<span class="string">&quot;src&quot;</span>,ev.<span class="property">target</span>.<span class="property">result</span>)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thymeleaf</title>
      <link href="/2022/04/10/Thymeleaf/"/>
      <url>/2022/04/10/Thymeleaf/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p> 1. Thymeleaf概述</p><p>Thymeleaf是一个Java模板引擎，支持html、xml、text、javascript、css、raw这几种模型。 </p><p>使用Thymeleaf首先需要引入命名空间</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html  <span class="attr">xmlns</span>:th=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>2. 基本使用方法</p><p>1⃣️引用web静态资源 </p><p>Thymeleaf通过”@{}”来引用web静态资源，例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script <span class="attr">th</span>:src=<span class="string">&quot;@&#123;bootstrap/js/boostrap.min.js&#125;&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>2⃣️访问model模型中的数据，例如访问一个user对象的name属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;span <span class="attr">th</span>:text=<span class="string">&quot;$&#123;user.name&#125;&quot;</span>&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>3⃣️在Javascript中访问model模型数据</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script <span class="attr">th</span>:inline=<span class="string">&quot;javascript&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> user = [[$&#123;user&#125;]]</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span> + <span class="string">&quot;\t&quot;</span> + user.<span class="property">age</span>);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>  这一段时间，感觉自己学习的还是太少，不会的很多，学无止境，各种模版都需要学习，现在开始了前后端交互，怎么合作，怎么合作好是现在我面临的问题，第一次交互，我觉得能后收获很多东西，希望能够顺利完成这次的任务。</p><p>之后会继续写静态页面，等后端接口能用了，在进行下一步</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS引擎的执行机制</title>
      <link href="/2022/04/02/JS%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/04/02/JS%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><em><strong>1.首先JS是单线程的</strong></em></p><p><strong><em>2.JS的Event Loop是JS的执行机制。深入了解JS的执行,就等于深入了解JS里的event loop</em></strong></p><p>Event loop事件循环</p><p>先看一个例子如下:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个例子的执行输出顺序是1 3 2；</p><p>也就是说,setTimeout里的函数并没有立即执行,而是延迟了一段时间,满足一定条件后,才去执行的,这类代码,我们叫异步代码。</p><p>JS中有两类任务，一类是同步任务，一类是异步任务</p><p>按照这种分类方式:JS的执行机制是</p><blockquote><p><strong>Event Table</strong> 就是个注册站：调用栈让Event Table注册一个函数，该函数会在达到条件后被调用。当指定的事情发生时，Event Table会将这个函数移到Event Queue。<strong>Event Queue</strong>其实就是个缓冲区域，这里的函数等着被调用并移到调用栈。</p></blockquote><ul><li>首先判断JS是同步还是异步,同步就进入主线程,异步就进入event table</li><li>异步任务在event table中注册函数,当满足触发条件后,被推入event queue</li><li>同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主线程中</li></ul><p>以上三步循环执行,这就是event loop；</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">​</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)<span class="comment">//同步任务进入主线程；直接输出</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="comment">/*异步任务进入event table(注册站)等待0秒后被放入event queue(缓冲区)中；待主线程行完成后在去缓冲区中看看有没有任务，再执行*/</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)<span class="comment">//同步任务进入主线程直接输出；</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>还有一种情况，假如在一个程序中，有许多个异步任务，那么先执行哪一个呢？；在异步任务中并不是按照进入事件队列的先后顺序去执行的；而是另有规定；</p><p>再举一个例子：如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定时器开始啦&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;马上执行for循环啦&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">        i == <span class="number">99</span> &amp;&amp; <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行then函数啦&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;代码执行结束&#x27;</span>);</span><br><span class="line">   </span><br></pre></td></tr></table></figure><blockquote><p> 这段代码中；第一个定时器是异步任务会被放到event  table中；</p><p>new Promise 是同步任务，会被放到主线程中直l接执行打印</p><p>.then里的函数是异步任务，被放到event table</p><p>console.log(‘代码执行结束’)；是同步代码被放到主线程中；直接执行；</p></blockquote><p> 结果是：      马上执行for循环啦 -– 代码执行结束 -– 执行then函数啦 -– 定时器开始啦</p><p><strong>如果仅仅按照异步同步去判断执行流程是不足够的，不够准确,</strong></p><p>像上面的这个代码.then   和   setTimeout都是异步的，但是执行结果并没有按照进入事件队列的顺序执行的，</p><p>而准确的划分方式是按照<strong>宏任务</strong>和<strong>微任务</strong>划分的</p><p>macro-task(宏任务)：包括整体代码script，setTimeout,setInterval</p><p>micro-task(微任务)：promise，process,nextTick;</p><p><img src="https://img-blog.csdnimg.cn/b93c9dddfb2246af9f5960c0edf540bd.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rqQ5YiD,size_20,color_FFFFFF,t_70,g_se,x_16"></p><blockquote><p>首先执行script下的宏任务,遇到setTimeout,将其放到宏任务的【队列】里（这个在下一个事件循环的宏任务里添加，不是在当前宏任务中添加的）</p><p>遇到 new Promise直接执行,打印”马上执行for循环啦”</p><p>遇到then方法,是微任务,将其放到微任务的【队列里】</p><p>打印 “代码执行结束”</p><p>本轮宏任务执行完毕,查看本轮的微任务,发现有一个then方法里的函数, 打印”执行then函数啦”</p><p>到此,本轮的event loop 全部完成。</p></blockquote><p>下一轮的循环里,先执行一个宏任务,发现宏任务的【队列】里有一个 setTimeout里的函数,执行打印”定时器开始啦了；</p><p><a href="https://segmentfault.com/a/1190000012806637" title="原内容地址，感谢博主的精心讲解！">原内容地址，感谢博主的精心讲解！</a></p><p>周总结：</p><p>这周在学习js高级的内容；内容可以说很多，可以学习的知识很深，我现在只是浅浅的明白一些内容；红宝书的内容很多；这周学习总体上理论上的东西比较多；接下来我会进行实践，实际操作一下更深层次的理解；闭包，对象创建模式；继承都没有进行实践操作过；也不太清楚什么时候会用</p><p>希望能够尽快进行前后端交互;让我多一些实战经验；实际操作可比看书能学到的多的多；这周感觉挺累的，需要稍稍调整一下，马上就要有新成员进来了；我们的压力大了一些，可不能让他们超越了已经学了几个月的我们，要不然就感觉我们学习效率很低；</p><p>加油继续努力（卷）；</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS对象创建模式</title>
      <link href="/2022/03/27/JS%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/03/27/JS%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>对象创建模式有以下几种：</p><p><strong>1.工厂模式</strong></p><p><strong>2.构造函数模式</strong></p><p><strong>3.原型模式</strong></p><p><strong>4.组合使用构造函数模式和原型模式</strong></p><p><strong>5.动态原型模式</strong></p><p><strong>6.寄生构造函数模式</strong></p><p><strong>7.稳妥构造函数模式</strong></p><p>1.<strong>工厂模式</strong> 一种函数用函数来封装以特定接口创建对象的细节</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line"> <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line"> o.<span class="property">name</span> = name; </span><br><span class="line"> o.<span class="property">age</span> = age; </span><br><span class="line"> o.<span class="property">job</span> = job; </span><br><span class="line"> o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="keyword">return</span> o; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="title function_">createPerson</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="title function_">createPerson</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure><p>函数 createPerson()能够根据接受的参数来构建一个包含所有必要信息的 Person 对象。可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建 多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。随着 JavaScript 的发展，又一个新模式出现了。</p><p>2.<strong>构造函数模式</strong></p><p>构造函数可以用来创建特定类型的对象，像object 和Array这样的原生构造函数，可以自定义构造函数，从而定义对象的类型的属性和方法；还是上面的例子用构造函数重写如下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">job</span> = job; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125;; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样对象的类型就能够知道对象的类型</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(person1.<span class="property">constructor</span> == <span class="title class_">Person</span>); <span class="comment">//true </span></span><br><span class="line"><span class="title function_">alert</span>(person2.<span class="property">constructor</span> == <span class="title class_">Person</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>对象的 constructor 属性最初是用来标识对象类型的。但是，提到检测对象类型，还是 instanceof 操作符要更可靠一些。我们在这个例子中创建的所有对象既是 Object 的实例，同时也是 Person 的实例，这一点通过 instanceof 操作符可以得到验证。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">//true </span></span><br><span class="line"><span class="title function_">alert</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">//true </span></span><br><span class="line"><span class="title function_">alert</span>(person2 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">//true </span></span><br><span class="line"><span class="title function_">alert</span>(person2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式 胜过工厂模式的地方</p><p>3.<strong>原型模式</strong></p><p>我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象， 而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那 么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以 让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是 可以将这些信息直接添加到原型对象中，如下面的例子所示。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">//&quot;Nicholas&quot; </span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">//&quot;Nicholas&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">sayName</span> == person2.<span class="property">sayName</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>原型的内容在上一篇博客种已经说过；</p><p>4.<strong>组合使用构造函数模式和原型模式</strong></p><p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实 例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本， 但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参 数；可谓是集两种模式之长。下面的代码重写了前面的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">job</span> = job; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123; </span><br><span class="line"> constructor : <span class="title class_">Person</span>, </span><br><span class="line"> sayName : <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); </span><br><span class="line">person1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Van&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">friends</span>); <span class="comment">//&quot;Shelby,Count,Van&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(person2.<span class="property">friends</span>); <span class="comment">//&quot;Shelby,Count&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">friends</span> === person2.<span class="property">friends</span>); <span class="comment">//false </span></span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">sayName</span> === person2.<span class="property">sayName</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性 constructor 和方 法 sayName()则是在原型中定义的。而修改了 person1.friends（向其中添加一个新字符串），并不 会影响到 person2.friends，因为它们分别引用了不同的数组</p><p>5.<strong>动态原型模式</strong></p><p>可以通过 检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line"> <span class="comment">//属性</span></span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">job</span> = job; </span><br><span class="line"> <span class="comment">//方法</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span>.<span class="property">sayName</span> != <span class="string">&quot;function&quot;</span>)&#123; </span><br><span class="line"> <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125;; </span><br><span class="line"> </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line">friend.<span class="title function_">sayName</span>(); </span><br></pre></td></tr></table></figure><p><strong>使用动态原型模式时，不能使用对象字面量重写原型，如果 在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。</strong></p><p>6.<strong>寄生构造函数模式</strong></p><p>这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊 数组。由于不能直接修改 Array 构造函数，因此可以使用这个模式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SpecialArray</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="comment">//创建数组</span></span><br><span class="line"> <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="title class_">Array</span>(); </span><br><span class="line"> <span class="comment">//添加值</span></span><br><span class="line"> values.<span class="property">push</span>.<span class="title function_">apply</span>(values, <span class="variable language_">arguments</span>); </span><br><span class="line"> <span class="comment">//添加方法</span></span><br><span class="line"> values.<span class="property">toPipedString</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">join</span>(<span class="string">&quot;|&quot;</span>); </span><br><span class="line"> &#125;; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//返回数组</span></span><br><span class="line"> <span class="keyword">return</span> values; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="title class_">SpecialArray</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">toPipedString</span>()); <span class="comment">//&quot;red|blue|green&quot; </span></span><br></pre></td></tr></table></figure><p>关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属 性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此， 不能依赖 instanceof 操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情 况下，不要使用这种模式。</p><p>6.<strong>稳妥构造函数模式</strong></p><p>道格拉斯·克罗克福德（Douglas Crockford）发明了 JavaScript 中的稳妥对象（durable objects）这 个概念。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。稳妥对象最适合在 一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其他应用程序（如 Mashup 程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的 实例方法不引用 this；二是不使用 new 操作符调用构造函数。按照稳妥构造函数的要求，可以将前面 的 Person 构造函数重写如下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line"> <span class="comment">//创建要返回的对象</span></span><br><span class="line"> <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line"> <span class="comment">//可以在这里定义私有变量和函数</span></span><br><span class="line"> <span class="comment">//添加方法</span></span><br><span class="line"> o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="title function_">alert</span>(name); </span><br><span class="line"> &#125;; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//返回对象</span></span><br><span class="line"> <span class="keyword">return</span> o; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也 没有什么关系，因此 instanceof 操作符对这种对象也没有意义。</p><blockquote><p>《Javascript高级程序设计》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型链prototype和__proto__</title>
      <link href="/2022/03/19/%E5%8E%9F%E5%9E%8B%E9%93%BEprototype%E5%92%8C__proto__/"/>
      <url>/2022/03/19/%E5%8E%9F%E5%9E%8B%E9%93%BEprototype%E5%92%8C__proto__/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>所有的 JavaScript 对象都会从一个 prototype（原型对象）中继承属性和方法。</p><p>显示原型和隐式原型；构造函数的显示原型用来存放函数对象，而实例对象的隐式原型等同于构函数的显示原型。所有对象的原型最终都指向object对象，object是原型链的顶端；</p><p><img src="https://img-blog.csdnimg.cn/e4eb068bd2ff4832b6263231b504ec99.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rqQ5YiD,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p><p>function的构造函数也是function，隐式原型指向function的原型对象；</p><p>而function的隐式原型指向object对象的显示原型，object没有隐式原型。object就是最顶层的对象；</p><p>当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它的’_ _ proto_ _‘属性(也就是它的构造函数的’prototype’属性)中去寻找，如果他的构造函数的prototype中没有这个属性就会去object中去寻找。再找不到就没有了；</p><p>首先，fn的构造函数是Foo()。所以：<br>fn._ _ proto _ _=== Foo.prototype<br>又因为Foo.prototype是一个普通的对象，它的构造函数是Object，所以：<br>Foo.prototype._ _ proto _ _=== Object.prototype<br>通过上面的代码，我们知道这个toString()方法是在Object.prototype里面的，当调用这个对象的本身并不存在的方法时，它会一层一层地往上去找，一直到null为止。   </p><p><img src="https://img-blog.csdnimg.cn/cd57f2c5e51949c49e12a3fc957a9ec1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rqQ5YiD,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>暂时的理解，后续会改</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 prototype </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise解决回调函数嵌套</title>
      <link href="/2022/03/13/promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97/"/>
      <url>/2022/03/13/promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件，这就解决了，我上次写的ajax的异步造成的问题，还要在回调函数中去绑定事件，有了promise这些都不是事，有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p><p>promise对象代表一个异步操作，有三种状态pending(进行中)，fulfilled(已成功)，rejected(“已失败”)，异步操作的结果决定这个对象的状态，</p><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p><p>基本用法</p><p>创建一个promise对象，</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行了promise&quot;</span>)</span><br><span class="line">           <span class="title function_">reject</span>(<span class="string">&quot;执行成功返回的数据像接口数据啥的&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       ,<span class="number">1000</span>)</span><br><span class="line">     &#125;)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/f003286678cc48fd81dfb73761b53b1a.png"></p><p> 这我只是创建了一个对promise对象但是却执行了，Promise 新建后就会立即执行。</p><p>所以应该把promise对象放在函数了，比如单击事件函数，单机之后才会新建promise对象然后执行，</p><p>其中两个参数，resolve   reject是两个函数，是由js引擎提供的，不需要自己写</p><p>resolve函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定resolved状态和<code>Promise</code>状态的回调函数。</p><p>promise对象的then方法，可以将两个回调函数作为参数，第一个会回调函数就是当promise的状态为resolve的时候调用的并且可以接受传来的数据。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">       <span class="comment">//成功之后</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/e76bc85121e2457a96cb4dc58ba1de38.png"></p><p> 状态变为resolve之后就会执行then方法的第一个回调函数，并且把数据也传了过来，在进行操作就行了，类似于这样在Ajax中请求成功就把返回数据用resolve函数传递，就会执行then方法的第一个回调函数，在回调函数中也可以再return  promise对象，进行回调函数的执行，形成链式，如果不用promise，在Ajax的回调函数中写就会形成多层嵌套，代码一直往右延申，不利于观察，用promise链式，可以代码让代码看起来更有条理，</p><p>这就我现在的理解，可能有错误，后续会改</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript 前端 react.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AJAX相关问题的解决</title>
      <link href="/2022/03/06/AJAX%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
      <url>/2022/03/06/AJAX%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>AJAX是一默认是异步的程序，AJAX执行的时候是没有顺序性的，就在第一个接口还没有把返回的数据传入dom时，就已经执行其他代码了，如果在这完成之前去用js去获取用ajax加入dom的元素，是获取不到的，但是在一些小型的请求可通过把ajax中的async=flase，设置成同步，就能够在ajax完全执行完成之后，在进行之后的代码，就能够用js获取到动态添加的内容了。</p><p>但是这不是一个好方法，只能满足小型请求是不行的 ，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止，也可以在开启异步时，在ajax的回调函数中去对动态添加的元素进行获取；绑定事件。这是一个挺好用的方法，</p><p>        还有一个方法，这不是一个好方法，但是我觉得还挺有意思，在js中设置一个定时器，把对动态添加的内容执行的函数放到里面，这样无论什么时候ajax加载完成，定时器在反复的寻找需要绑定函数的内容，找到了，就绑定；（感觉有bug，可能和网速有关系。尽量不用）</p><p>        之后继续学习es6的规则；应用到代码中，再深入了解了解ajax，还有jq工具库。</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 ajax javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于git</title>
      <link href="/2022/02/27/%E5%85%B3%E4%BA%8Egit/"/>
      <url>/2022/02/27/%E5%85%B3%E4%BA%8Egit/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>git是一种版本控制器，git的安装非常简单，下一步就行了。</p><p>git的基本操作；</p><p>在需要记录版本的文件夹中用，git init创建本地库</p><p>首次使用需要配置一下个人的用户名和电子邮件地址，输入一下两行代码</p><p>$ git config --global user.name “用户名”</p><p>$git config --global user.email 邮箱</p><p>可以输入一下代码查看是否配置成功</p><p>$git config --list</p><p>git有三个部分，工作区，暂存区，本地库，也可以上传至远程库</p><p>git的基本操作；</p><p>git init 初始化操作</p><p>git add 添加文件到暂存区</p><p>git commit 将暂存区的内容添加到本地仓库中；</p><p>git status 查看仓库当前状态</p><p>git diff 比较暂存区和工作区的差异</p><p>git reset 版本号 回退版本；</p><p>git rm 删除工作区文件</p><p>git mv 移动或重命名工作区文件。</p><p>git log 查看历史提交记录</p><p>git blame&lt;file&gt;以列表形式查看指定文件的历史修改记录</p><p>git remote 远程仓库操作</p><p>git fetch 从远程库获取代码库</p><p>git pull 下载远程代码并合并</p><p>git push 上传远程代码并合并</p><p>其中git pull git fetch git cloned的区别</p><p>git pull相当于是从远程获取最新版本并merge（合并）到本地 git pull = git fetch + git merge</p><p><strong>git fetch</strong> 命令用于从远程获取代码库，该命令执行完后需要执行 git merge 远程分支到你所在的分支。</p><p>git clone 拷贝一个git仓库到本地，本地无需初始化仓库也能拷贝，这是完全拷贝，连历代记录都进行了拷贝，历代版本信息也有，</p><p>2.分支管理</p><p>git branch -v 可以查看分支</p><p>git branch 分支名      可以创建分支，</p><p>git checkout 分支名       可以切换分支</p><p>git merge 分支名      可以合并分支到当前分支；</p><p>git其实还可以用来保存游戏存档的历代版本，当打游戏材料消耗完了，这个时候只需要回退版本，就能恢复存档。</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习记录2</title>
      <link href="/2022/01/23/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/"/>
      <url>/2022/01/23/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>        做考核页面也有三四天了，进展很慢，前一部分的内容很细，有好多小地方需要处理；今天我做到了那个轮播图左边的功能栏的地方了，自我感觉这个地方是最不好做的，希望明天之前能够完成，后面的就好做了。这个地方中，当鼠标放上时，一整排图标上移并且弹出内容栏，肯定要用到动画，也能用JS来写，我尽量能用CSS就不用JS，虽然JS很好用，可以操作基本所有东西，但是还是尽量用基本的写，我的思路就是，先给图标开启定位，当鼠标放上时，让其上移，还有一个同步触发的事件，让该弹出的内容由高度为零变成预定高度，这个过程加一个过渡动画，内容区再用JS去写页面左右切换；现在只是这样想，希望能够实现。希望不要花费太多时间，</p><p>        还有7天就要过年了，希望能够在过年之前写好页面，好好过年，最近学习写页面总感觉时间过的很快，还没有写多少就一天过去了，希望能够提升效率，注意力集中，上午去写一些逻辑性的东西，晚上把文字内容填一填。规划好时间，加油，上班不摸鱼。希望和同学们一起进步，争取突破一下。成为肝帝！！</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 html 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回顾CSS内容</title>
      <link href="/2022/01/16/%E5%9B%9E%E9%A1%BECSS%E5%86%85%E5%AE%B9/"/>
      <url>/2022/01/16/%E5%9B%9E%E9%A1%BECSS%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><strong>目录</strong></p><p><a href="#1.%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90">1.弹性盒子</a></p><p><a href="#2.%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE">2.文本标签</a></p><p><a href="#3.%E5%AE%9A%E4%BD%8D">3.定位</a></p><hr><h2 id="1-弹性盒子"><a href="#1-弹性盒子" class="headerlink" title="1.弹性盒子"></a>1.弹性盒子</h2><p>flex</p><p>flex-direction 指定容器中弹性元素的排列方式；</p><p>主轴由flex的设置的方向决定；</p><p>flex-grow指定弹性元素伸展的系数默认值是零；</p><p>当父元素有多余的空间时子元素如何伸展，0就是不伸展，</p><p>要是把flex-grow写入子元素，则子元素按照flex-grow的比值被分配剩余空白部分</p><p>flex-shrink表示收缩系数。当父元素不足以容纳子元素时对子元素进行收缩</p><p>当值为零的时候就是不收缩，当外面的框小的时候内容会溢出</p><p>这时使用flex-wrap：wrap；多出的部分会沿着辅轴方向排列</p><p>flex-flow是简写属性</p><p>justify-content</p><p>如何分配空白区域</p><p>flex-start 元素沿着主轴起边排列</p><p>flex-end 元素沿着主轴终边排列</p><p>center 元素居中排列</p><p>sparce-between 空白均匀分布到元素间</p><p>spare-around 空白分布到元素两侧。</p><p>在纵向上align-item</p><p>中stretch属性把元素的长度设置为相同的值；</p><p>指的是行与行之间的高度</p><p>flex-start：元素不会拉伸，沿着辅轴起边方向对齐</p><p>flex-end：沿着辅轴终边对齐</p><p>flex-baseline：沿着基线对齐就是文字底边的基线。</p><p>在纵轴上分配空白空间</p><p>用align-conent：</p><p>和横着的一样。</p><p>设置弹性元素的属性</p><p>flex-basic:可以设置弹性元素的基础长度；</p><p>如果主轴是纵向的则设置的是高度；</p><h2 id="2-文本标签"><a href="#2-文本标签" class="headerlink" title="2.文本标签"></a>2.文本标签</h2><p>html格式化标签粗体表示重要性（内容的重要性）或者斜体表示着重点（语气上的强调）表示你要呈现的文章时重要的所以要突出显示 一个粗体，一个斜体</p><p>与是定义粗体或斜体文本与上面的那两个是不一样的</p><p>cite标签：网站中所有加书名号的内容都可以使用cite标签</p><p>《XXX》</p><p>短引用标签的内容浏览器会默认给他加上一个“”</p><p>blockquote长引用（块级引用不能放在中）</p><p>独占一行</p><p>sup标签用来表示一个上标；</p><p>sub标签用来表示一个下标；</p><p>del标签用来表示一个删除的内容画一个横线</p><p>ins表示插入一个内容插入的内容有下划线</p><p>pre标签时预格式标签保留了格式；</p><p>code专门用来表示代码的标签</p><h2 id="3-定位"><a href="#3-定位" class="headerlink" title="3.定位"></a>3.定位</h2><p>通过position属性</p><p>relative是相对定位</p><p>当开启元素相对定位时，而不设置偏移量。和没有设置一样</p><p>2：开启后可以通过，left right top bottom 四个属性设置元素的偏移量。</p><p>是相对与原来位置移动的。</p><p>3：相对定位的元素不会脱离文档流。原来的位置虽然是空的但还占位置。</p><p>4：相对定位会使元素提升一个层级。会覆盖其他元素。</p><p>通常偏移量使用两个就可以对一个元素进行定位。</p><p>相对定位，不会该改变元素的性质，块还是块，内联还是内联</p><p>绝对定位absolute</p><p>开启绝对定位后脱离文档流</p><p>开启绝对定位后</p><p>而且是相对于浏览器窗口定位的</p><p>3：绝对定位是相对于离他最近的的开启了定位的祖先元素定位的</p><p>（一般情况开启子元素的绝对定位，也会开启祖先元素的绝对定位。）</p><p>4：如果所有的祖先元素都未开启定位，则会相对于浏览器窗口定位。</p><p>5：绝对定位会使元素提升一个层级</p><p>6：定位会改变元素的性质</p><p>内联元素变成块元素，块元素的宽度和高度默认被内容撑开</p><p>固定定位fixed</p><p>position也是一种绝对定位</p><p>它的大部分特点都和绝对定位一样</p><p>不同的是：</p><p>固定定位永远会相对于浏览器窗口进行定位</p><p>固定定位会固定在浏览器窗口的某个位置，不会随滚顶条滚动</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 css 前端 html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近期学习随笔</title>
      <link href="/2021/12/29/%E8%BF%91%E6%9C%9F%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/"/>
      <url>/2021/12/29/%E8%BF%91%E6%9C%9F%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>前些天闭组了，虽然闭组了，但是我还是每天坚持来小组学习，开始认真学习专业课程，闭组第一天我早上睡到了九点多，睡了个懒觉，起来之后神清气爽，非常有精神，带上书包就去小组学习了，小组的人很少，没有了往日的热闹和紧张的氛围，但是在这的人还是非常认真的在学习，坐到这里才有学习的动力，在寝室老是想玩游戏，不能很好的学习效率很低，所以我每天还是来小组学习，养成一个好习惯，闭组这段时间我每天晚上都是十点回去，没有像往常一样十点四十回去，毕竟还是想放轻松一下，现在是大一觉得不应该那么卷，还是想轻松一点，适度学习，适度躺平。</p><p>  马上就要放假了，回家每天学习点JS，我觉得应该能够把那个一百多集的视频看完，并学会。希望小组的任务能够轻松一些，每天肝个几个小时就能完成的那种。我们家那边疫情比较严重，只能在家，任务应该都能完成。希望寒假不会延期开学，希望明年疫情消退，让我们大一的出去玩玩吧。寒假我也出不去，我们周口疫情挺严重的，家周围都封闭了，回去还要隔离七天，只有电脑陪我了。期末加油！</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端考核感想</title>
      <link href="/2021/12/13/%E5%89%8D%E7%AB%AF%E8%80%83%E6%A0%B8%E6%84%9F%E6%83%B3/"/>
      <url>/2021/12/13/%E5%89%8D%E7%AB%AF%E8%80%83%E6%A0%B8%E6%84%9F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>        这次前端考核时间很充裕但是我并没有好好利用做的时候有点莽，刚开始先写的整体框架内容填完之后，而且动画还有特效都做好了，才发现一缩小布局是乱的，虽然下边没有出现滚动条，但是我的内容全部都被压缩了，我的内容区的盒子宽度是按照百分比写的，而且使用的是绝对定位，没有响应式布局，直到了最后一天，我才进行改动把所有内容区的宽度改成了固定像素值，并且设置了媒体查询，缩小的页面进行布局。把本来变形的布局改了回来，当然这也不能改变大框架的弄错带来的问题，以后再写就明白怎么去写了，先想明白再去动手不然之后再去修改会很麻烦，总体来说前端做出来的效果事可以看到的，成就感比较强，自己脑海中所想的能够做出来，</p><p>        这一阶段结束之后就要分前后端学习了，两个方向都不容易，都挺好，所以现在我以我的兴趣为导向进行选择，我打算选择前端，我觉得前端我有学下去的动力，我想象力很好，我觉得对前端的学习有所帮助。这马上就要期末考试了，要注意课程的学习，不能挂科，尽量安排好自己的时间，小组学习和正常课程，都要弄好，</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 html asp.net </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高度塌陷问题的解决办法</title>
      <link href="/2021/12/05/%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2021/12/05/%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>在HTML文档中元素默认是在文档流中的，在文档流中块级元素会独占一行从上至下排列，而内联元素，所谓的行内元素，指的是只占自身大小的元素，不会占用一行</p><p>行内元素有：a b span img input select strong（强调的语气）<br>块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p </p><p><strong>首先什么是高度坍塌？</strong></p><p>在文档流中，父元素的高度默认是被子元素撑开的。</p><p>也就是子元素多高，父元素多高。</p><p>但是当子元素设置浮动时，子元素会脱离文档流</p><p>此时将会导致子元素无法撑起父元素的高度造成父元素塌陷，则父元素下的所有元素都会上移这样导致页面布局混乱。</p><p>解决办法有好几种，但是某些办法有局限性。在不同浏览器中也会出现不兼容的问题</p><p>**一.**把浮动元素所在盒子的高度定死，设置一个不可变的高度。这样容易出现内容溢出的问题。造成布局混乱</p><p><strong>二</strong>、开启BFC属性<br>根据W3C的标准，在我们的页面中元素都有一个隐含的属性叫做“Block Formatting Context”，简称BFC，该属性可以设置打开或者关闭，默认是关闭的。当我们开启元素的BFC以后，元素会具有以下特性：<br>1.父元素的垂直外边距不会和子元素重叠<br>2.开启BFC的元素不会被浮动元素覆盖<br>3.开启BFC的元素可以包含浮动的子元素<br>如何开启元素的BFC：<br>1.设置元素的浮动： 这种方式开启虽然可以撑开父元素，但是会导致父元素的宽度丢失，而且这种方式也会导致下边的元素上移，不能解决问题。<br>2.设置元素的绝对定位  </p><p>3.将我们元素的overflow设置为hidden是副作用最小的开启BFC的方式。  </p><p><strong>三</strong>、可以直接在高度塌陷的父元素的最后，添加一个空白的div<br>由于添加的div并没有浮动，所以他是可以撑开父元素的高度的，再对其进行清除浮动，可以通过空白的div来撑开父元素的高度，基本没有副作用。使用这种方式，虽然可以解决问题，但是会在页面中添加多余的结构  </p><p><strong>四、</strong>通过after伪类来选中父元素的后面<br>可以通过after伪类向元素的的最后添加一个空白的块元素，然后对其清除浮动，这样做和添加div的原理一样，可以达到相同的效果，而且不会再页面中添加多余的div，最为推荐使用的方式，几乎没有副作用</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 css3 html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔记录学习</title>
      <link href="/2021/11/27/%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/11/27/%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>  今天早上没想到竟然又睡过了，我下次一定多订几个闹钟，以免过了时间。近期在学习前端知识，感觉前端的内容还挺有意思的，做出来的东西都时可见的。可以按照自己的想要的设计去设计网页，我觉得前端知识比较零散，各种各样的标签需要了解。</p><p>  学习前端有四天了，感觉没有算法要求，可能后期就有更加深的内容了吧，我看视频上介绍的前端学习的javaScript也能编写类似煜后端的内容，编写数据库；前端处于一个中间位置，既要与页面设计师协调好，也要与后端工程师协调好，所以前端工程师两边都要了解一些知识，需要学习的东西更多，</p><p>  在小组的学习感觉很好，休息时间感觉还挺多，比高中好多了高中是被迫学习自己不感兴趣的东西，整天埋头在哪里学习，十分无聊，唯一感兴趣的计算机，三年就上了3节课！！。真的是麻了，在大学刚开始的时候，感觉十分的轻松没有什么课，自己能在寝室待上一整天和心目中的大学生活不一样，大学生活应该是很丰富的，很有趣的。能够学习自己感兴趣的东西，希望在以后的时间里能够学习学习到一门手艺，编程手艺。信手拈来，想写啥就写啥。ps我也十分想学我想p我的室友哈哈。</p><h1 id="皇子yyds"><a href="#皇子yyds" class="headerlink" title="皇子yyds"></a><img src="https://img-blog.csdnimg.cn/04aafe67e48e43938f0de042d6c74295.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rqQ5YiD,size_14,color_FFFFFF,t_70,g_se,x_16"><strong>皇子yyds</strong></h1>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
