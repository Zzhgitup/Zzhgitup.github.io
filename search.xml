<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>队列,链表,集合,字典</title>
      <link href="/2022/09/17/%E9%98%9F%E5%88%97/"/>
      <url>/2022/09/17/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="用JS数组方法模拟队列"><a href="#用JS数组方法模拟队列" class="headerlink" title="用JS数组方法模拟队列"></a>用JS数组方法模拟队列</h2><p>队列实例演示视频，可以看出是先进先出</p><iframe height=419 width=745 src='https://player.youku.com/embed/XNTkwMjUzNjY2OA==' frameborder=0 'allowfullscreen'></iframe><h2 id="JS异步中的任务队列"><a href="#JS异步中的任务队列" class="headerlink" title="JS异步中的任务队列"></a>JS异步中的任务队列</h2><ul><li>JS是单线程的，无法同时处理异步中的并发任务</li><li>使用任务队列先后处理异步任务</li></ul><h2 id="链表模拟"><a href="#链表模拟" class="headerlink" title="链表模拟"></a>链表模拟</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表  模拟</span></span><br><span class="line"><span class="keyword">const</span> a=&#123;<span class="attr">val</span>:<span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> b=&#123;<span class="attr">val</span>:<span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> c=&#123;<span class="attr">val</span>:<span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> d=&#123;<span class="attr">val</span>:<span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line">a.<span class="property">next</span>=b;</span><br><span class="line">b.<span class="property">next</span>=c;</span><br><span class="line">c.<span class="property">next</span>=d;</span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="keyword">let</span> p=a;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">val</span>);</span><br><span class="line">    p=p.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入 改变next指向</span></span><br><span class="line"><span class="keyword">const</span> e=&#123;<span class="attr">val</span>:<span class="string">&quot;e&quot;</span>&#125;;</span><br><span class="line">c.<span class="property">next</span>=e;</span><br><span class="line">e.<span class="property">next</span>=d;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">val</span>);</span><br><span class="line">    p=p.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除e</span></span><br><span class="line">c.<span class="property">next</span>=d;</span><br></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//去重</span></span><br><span class="line"><span class="keyword">const</span> arr=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr2=[...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];<span class="comment">//得到一个集合</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2);</span><br><span class="line"><span class="comment">//判断元素是否在集合中</span></span><br><span class="line"><span class="keyword">const</span> set=<span class="keyword">new</span> <span class="title class_">Set</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">has</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//求交集</span></span><br><span class="line"><span class="keyword">const</span> set2=<span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> set3=<span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> set2.<span class="title function_">has</span>(item);</span><br><span class="line">&#125;))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...set3]);</span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><ul><li>与集合类似，字典也是一种储存为一只的数据结构，但他是以键值对的形式来储存<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ES6总有字典，名为Map</span></span><br><span class="line"><span class="keyword">const</span> m=<span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line"><span class="comment">//删除字典</span></span><br><span class="line">m.<span class="title function_">delete</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">m.<span class="title function_">clear</span>(); </span><br><span class="line"><span class="comment">//改</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;awdawd&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2></li><li>一种分层数据抽象模型</li><li>前端工作中常见的树包括，DOM数，级联选择,树形控件<br>js 中没有树，但是可以用Object和Array构建数</li><li>树的常用操作，深度/广度操作<ul><li>深度优先遍历<br>   1.访问根节点<br>   2.对根节点的chidren挨个进行深度优先遍历<br>就是递归的使用<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tree=&#123;</span><br><span class="line">    <span class="attr">val</span>:<span class="string">&quot;根节点&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>:[&#123;</span><br><span class="line">        <span class="attr">val</span>:<span class="string">&quot;二级节点1&quot;</span>,</span><br><span class="line">        <span class="attr">children</span>:[&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="string">&quot;三级节点1&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>:[]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="string">&quot;三级节点2&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>:[]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        <span class="attr">val</span>:<span class="string">&quot;二级节点2&quot;</span>,</span><br><span class="line">        <span class="attr">children</span>:[&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="string">&quot;三级节点3&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>:[]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="string">&quot;三级节点4&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>:[]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        <span class="attr">val</span>:<span class="string">&quot;二级节点3&quot;</span>,</span><br><span class="line">        <span class="attr">children</span>:[&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="string">&quot;三级节点5&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>:[]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="string">&quot;三级节点6&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>:[]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">dfs</span>=(<span class="params">root</span>)=&gt;&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>);</span><br><span class="line">    root.<span class="property">children</span>.<span class="title function_">forEach</span>(dfs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">dfs</span>(tree);</span><br></pre></td></tr></table></figure>执行结果<br><img src="https://s2.loli.net/2022/09/17/minX4Qz2MsVFBlJ.png" alt="执行结果"></li></ul></li><li>广度优先遍历<ul><li>新建一个队列，把根节点入队</li><li>把队头出队，并访问</li><li>把对头的children挨个入队</li><li>重读第二，三步直到队列为空<br>接续用上述的tree使用广度优先遍历实现<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bfs=<span class="keyword">function</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="comment">//拿到队头</span></span><br><span class="line">    <span class="keyword">let</span> queue=[root];</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> n=queue.<span class="title function_">shift</span>();<span class="comment">//出队并访问</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">        <span class="comment">//把队头的children挨个入队</span></span><br><span class="line">        n.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">            queue.<span class="title function_">push</span>(item);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>结果如图<br><img src="https://s2.loli.net/2022/09/17/xjUY4a9K2bX3uMT.png" alt="结果"><h3 id="解压小视频"><a href="#解压小视频" class="headerlink" title="解压小视频"></a>解压小视频</h3><iframe height=419 width=745 src='https://player.youku.com/embed/XMzMxMjE0MjY4NA==' frameborder=0 'allowfullscreen'></iframe></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈结构+一道算法</title>
      <link href="/2022/09/15/%E6%A0%88%E7%BB%93%E6%9E%84+%E7%AE%97%E6%B3%95/"/>
      <url>/2022/09/15/%E6%A0%88%E7%BB%93%E6%9E%84+%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-栈（stack）"><a href="#1-栈（stack）" class="headerlink" title="1.栈（stack）"></a>1.栈（stack）</h2><p><img src="https://s2.loli.net/2022/09/16/PSWIgxmMZ4RKpF9.png" alt="QQ截图20220916150957.png"></p><ol><li>它是一种受限制的线性表，后见先出</li></ol><ul><li>其限制是仅允许在表的一端进行插入和删除操作，这一段被称为<code>栈顶</code>相对地把另一端称为<code>栈底</code></li><li>LIFO表示就是后进入的元素，带一个弹出栈空间，类似于自动餐托盘最后放上托盘，往往先拿出去使用</li><li>向一个栈插入新元素又称作<code>进栈</code>，<code>入栈</code>，或者<code>压栈</code>，他是把新元素放到栈顶元素的上面，使之成为新的栈顶元素</li><li>从一个栈删除元素又称作<code>出栈</code>，或者<code>退栈</code>，他是把栈顶元素删掉，使其相邻的元素成为新的栈顶元素。<h2 id="2-栈结构的实现"><a href="#2-栈结构的实现" class="headerlink" title="2.栈结构的实现"></a>2.栈结构的实现</h2><img src="https://s2.loli.net/2022/09/16/TYaosZUxe2y8bIv.png" alt="QQ截图20220916173538.png"><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestValidParentheses = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxLen = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    stack.<span class="title function_">push</span>(-<span class="number">1</span>) <span class="comment">// 初始化一个参照物</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// ( 入栈   )出栈</span></span><br><span class="line">            stack.<span class="title function_">push</span>(i)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// )的情况 出栈</span></span><br><span class="line">            stack.<span class="title function_">pop</span>()</span><br><span class="line">            <span class="keyword">if</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="comment">// 每次出栈 计算下当前有效连续长度</span></span><br><span class="line">                <span class="comment">// 如何计算连续长度 当前位置 - 栈顶下标  并取值最大的有效长度</span></span><br><span class="line">                maxLen = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLen, i - stack[stack.<span class="property">length</span> - <span class="number">1</span>])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.<span class="title function_">push</span>(i) <span class="comment">//栈为空时 放入右括号参照物 表示从这个下标开始 需要重新计算长度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>利用栈结构解题</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS语言基础（一）</title>
      <link href="/2022/09/15/JS%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/09/15/JS%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-严格模式"><a href="#1-严格模式" class="headerlink" title="1.严格模式"></a>1.严格模式</h2><p>严格模式是一种不同的javascript解析和执行的模型，如果要对整个脚本开启严格模式在脚本开头加上<code>use strict</code>虽然看起来没有复制给任何变量的字符串吗，但它其实是一个预处理指令，任何支持JavaScript的引擎看到就会切换到严格模式，</p><h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h2><ul><li>var关键字</li><li>let关键字</li><li>const关键字<h2 id="3-暂时性死区"><a href="#3-暂时性死区" class="headerlink" title="3.暂时性死区"></a>3.暂时性死区</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//name会被提升</span><br><span class="line">console.log(name);//undefined</span><br><span class="line">var name=&quot;小明&quot;;</span><br><span class="line">//name不会提升</span><br><span class="line">console.log(name)//报错</span><br><span class="line">let name=&quot;小明&quot;;</span><br></pre></td></tr></table></figure>在let声明之前的执行瞬间被称为。暂时性死区，在此阶段引用任何后面声明的变量都会抛出<code>ReferenceError</code><h2 id="4-全局声明"><a href="#4-全局声明" class="headerlink" title="4.全局声明"></a>4.全局声明</h2>与var关键字不同，使用let在全局作用域中声明的变量不会成为window对象的属性（var声明的变量则会）;<h2 id="声明风格及最佳实践"><a href="#声明风格及最佳实践" class="headerlink" title="声明风格及最佳实践"></a>声明风格及最佳实践</h2></li><li>不使用var </li><li>const优先 ，let次之</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS基础复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript, </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺时针打印矩阵JS版</title>
      <link href="/2022/09/15/%E5%89%91%E6%8C%87%20Offer%2029.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5(JS%E7%89%88)/"/>
      <url>/2022/09/15/%E5%89%91%E6%8C%87%20Offer%2029.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5(JS%E7%89%88)/</url>
      
        <content type="html"><![CDATA[<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">matrix</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> spiralOrder = <span class="keyword">function</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.<span class="property">length</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(matrix[<span class="number">0</span>].<span class="property">length</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向右  获取长和宽 </span></span><br><span class="line">    <span class="keyword">let</span> height=matrix.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> width=matrix[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> result=[];</span><br><span class="line">    <span class="comment">//向右打印</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;width;i++)&#123;</span><br><span class="line">       result.<span class="title function_">push</span>(matrix[<span class="number">0</span>][i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果有向下的，则向下 不能则返回结果</span></span><br><span class="line">   <span class="keyword">if</span>(height&gt;<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> k=<span class="number">1</span>;k&lt;height;k++)&#123;</span><br><span class="line">           result.<span class="title function_">push</span>(matrix[k][width-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果能向左就向左 不能则返回结果</span></span><br><span class="line">   <span class="keyword">if</span>(width&gt;<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> i=width-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">           result.<span class="title function_">push</span>(matrix[height-<span class="number">1</span>][i]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果能向上 则向上，不能则返回结果</span></span><br><span class="line">   <span class="keyword">if</span>(height&gt;<span class="number">2</span>)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> i=height-<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">           result.<span class="title function_">push</span>(matrix[i][<span class="number">0</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//剥除里面的矩阵  (循环一次减掉两层高度)</span></span><br><span class="line">    <span class="keyword">let</span> inner=<span class="keyword">new</span> <span class="title class_">Array</span>(height-<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;height-<span class="number">2</span>;i++)&#123;</span><br><span class="line">        inner[i]=matrix[i+<span class="number">1</span>].<span class="title function_">slice</span>(<span class="number">1</span>,width-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    result=result.<span class="title function_">concat</span>(<span class="title function_">spiralOrder</span>(inner));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS基础</title>
      <link href="/2022/09/15/JS%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/09/15/JS%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="script元素"><a href="#script元素" class="headerlink" title="script元素"></a>script元素</h1><ol><li>async:可选，表示应该立即开始下载脚本，但是不能阻止其他页面动作，比如下载资源挥着等待其他脚本加载，只对外部脚本有效，</li><li>charset：可选，使用src指定的代码字符集，这个属性很少使用，大多数浏览器不在乎它的值。</li><li>corssorigin:可选，配置相关请求的cors（跨源资源共享）设置，默认不使用CORS,     crossorigin=”use-credentials”设置凭据标志，意味着出站请求会包含凭据，</li><li>defer:可选。表示在问达能解析和显示完成后，再执行脚本是没有有问题的。只对外部脚本有效，</li><li>integrity:可选允许比对接收到的资源和指定的加密协议以验证子资源的完整性，如果接受到的资源的签名，与这个属性指定的签名不匹配则页面报错,脚本不会执行，这个属性可以用与确保内容分发网络不会提供恶意内容</li><li>src:可选。表示要执行的代码的外部文件</li><li>type:可选，用于指定代码块中的语言类型，按照管理，这个始终都是“text/JavaScript”。如果这个值时“module”则代码会被当成ES6模块，<br>包含在script标签里的内容，会从上至下解释，在&lt;\script&gt;元素中的代码被执行完毕之前，页面的其余内容不会被加载，也不会被显示，就形成了阻塞<br>在使用行内&lt;\script&gt;代码时，注意代码中崩出现字符串&lt;\script&gt;。比如以下代码，<br>会导致浏览器报错，浏览器解析行内脚本会将其当乘结束的&lt;\script&gt;的&lt;\script&gt;标签，想避免这个问题，只需要转义字符\即可<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span>  <span class="title function_">msg</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&quot;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>这样修改之后就可以被浏览器完全解释，不会导致任何错误，</li><li>在解释外还不JavaScript文件时页面也会阻塞，（阻塞时间包括文件的下载时间，）在XHTML可以忽略结束标签，</li><li>另外使用了src属性的&lt;\script&gt;的元素不应该在其内部写入代码，如果两种方式都使用的话，则浏览器只会下载执行脚本，而忽略内部代码，</li><li>&lt;\script&gt;最为强大，同时也备受争议的特性时，它可以包含来自外部域的JavaScript代码，与img的src很像<br>“&lt;\script src=’<a href="http://www.baidu.com&/#39;&gt;">www.baidu.com&#39;&gt;</a>&lt;\script&gt;”</li></ol><p>浏览器在计息这个资源时，会向SRC指定的地址发送一个get请求，以取得相应资源，这个初始的请求不受浏览器同源策略限制，但返回被执行的JS代码则受限制，当然请求仍然收父页面HTTP/HTTPS协议的限制</p><p>这就可能收到恶意的攻击，如果引用了别人服务器上的JS文件，就要格外小心，因为恶意的程序员，随时可能替换这个文件，在百翰外部与的JS文件时，要确保该域是自己所有的，或者该域是一个可靠的来源，&lt;\script&gt;时防范这种问题的一个武器，但是不是所有的浏览器都支持，这个属性，</p><p>不管包含的是什么代码，浏览器都会按照&lt;\script&gt;在页面中出现的顺序依次去解析他们，前提是他们没有使用defer和async属性，第二个&lt;\script&gt;代码会在第一个&lt;\script&gt;执行完毕之后进行，第三个会在第二个执行完毕之后进行，依次类推。</p><h1 id="标签位置"><a href="#标签位置" class="headerlink" title="标签位置"></a>标签位置</h1><ol><li>过去所有的&lt;\script&gt;元素都放在head标签内部，如下面的例子，<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">   <span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">HTML</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">title</span>&gt;</span>案例1<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">               这是页面内容</span><br><span class="line">            <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">HTML</span>&gt;</span></span><br><span class="line">```   </span><br><span class="line">这种做法的主要目的，就是把外部的CSS和JavaScript文件都集中到一起，不过把所有JavaScript文件都放在头部，也就意味着必须把所有的JavaScript文件都加载完毕才会开始渲染页面，对于需要很多JavaScript文件的页面这回导致，渲染时间明显变长，在此期间页面窗口完全空白，为解决这个问题，现代web应用程序将所有的Javascript引用放到了&lt;\body&gt;元素中的页面内容之后，如下</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">   <span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">HTML</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">title</span>&gt;</span>案例1<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">               这是页面内容</span><br><span class="line">            <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">HTML</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>推迟执行脚本<br>defer属性，这个属性表示这个脚本在执行的时候不会改变页面结构，完全可以等到整个页面解析完成以后，再运行，这个属性会告诉浏览器，应该立即下载，但执行会延迟，会等待html标签执行完毕之后，再执行</li><li>异步执行脚本<br>async   async与defer相似，都只是用与外部脚本，都会告诉浏览器立即开始下载，不过与defer不同的是，async并不能保证能按照出现的顺序执行，<br>给脚本添加async的目的是告诉浏览器 ，不必等待脚本下载和执行完毕再加载页面，同样也不必等待脚本下载执行完毕。再去执行其他脚本，正因为如此异步脚本不应该在加载期间修改DOM</li></ol><p>4.动态加载脚本</p><p>这个方式不推荐，很影响性能，而且会造成混乱。</p><p>5.行内代码，与外部文件</p><p>这两种方式，比较推荐外部文件，有以下优点</p><p>一.可维护性</p><p>二.缓存，如果两个html文件用到相同的JS文件，浏览器会根据缓存机制，只加载一次。意味着网页的加载速度更快</p><p>三.适应未来，</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>websocket基础</title>
      <link href="/2022/09/10/websocket%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/09/10/websocket%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1-传统的是HTTP模式，"><a href="#1-传统的是HTTP模式，" class="headerlink" title="1.传统的是HTTP模式，"></a>1.传统的是HTTP模式，</h1><p>因为 HTTP 协议有一个缺陷：通信只能由客户端发起 一个request对应一个respond<br>通信是单向的，请求==响应<br>没有请求就没有响应，举个例子：就比如我需要查询天气，只能是从客户端发送请求，接受查询结果。HTTP做不到主动向客户端推送信息，这种单向的请求的特点，注定如果服务器有连续的状态变化，客户端想要及时了解就很不方便，只能通过轮询的方式实现，这样是非常浪费资源的因为需要不停的连接,所以发明了websocket </p><h1 id="2-websocket"><a href="#2-websocket" class="headerlink" title="2.websocket"></a>2.websocket</h1><p>websocket 是一种网络传输协议，可在单个TCP连接进行全双工通信，位于OSI模型的应用层<br>最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话<br>特点：</p><ol><li>TCP连接，与HTTP协议兼容</li><li>双向通信，主动推送（服务端向客户端）</li><li>无同源限制，协议标识符是WS（加密wss）</li></ol><p>应用场景：</p><ul><li><input checked="" disabled="" type="checkbox"> 聊天，消息，点赞，</li><li><input checked="" disabled="" type="checkbox"> 直播弹幕</li><li><input checked="" disabled="" type="checkbox"> 游戏，协同编辑，基于位置的应用</li></ul><h1 id="原生websocket-的简单使用案例"><a href="#原生websocket-的简单使用案例" class="headerlink" title="原生websocket 的简单使用案例"></a>原生websocket 的简单使用案例</h1><p>我使用的node.js平台做的一个服务端，开启websocket服务<br>在sever.js文件中 ,建立服务先安装ws模块<br><code>npm i ws</code><br>在sever.js中</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">WebSocket</span>=<span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);<span class="comment">//引入模块</span></span><br><span class="line"><span class="keyword">const</span> wss=<span class="keyword">new</span> <span class="title class_">WebSocket</span>.<span class="title class_">Server</span>(&#123;<span class="attr">port</span>:<span class="number">3000</span>&#125;);<span class="comment">//监听本地3000端口</span></span><br><span class="line">wss.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>,<span class="function">(<span class="params">ws</span>)=&gt;</span>&#123;<span class="comment">//对连接进行监听</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;监听到服务&quot;</span>);</span><br><span class="line">    ws.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>,<span class="function">(<span class="params">msg</span>)=&gt;</span>&#123;<span class="comment">//同时接受客户端发送的信息</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">    &#125;)</span><br><span class="line">    ws.<span class="title function_">send</span>(<span class="string">&#x27;我是服务端&#x27;</span>);<span class="comment">//向客户端发送的信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>服务端建立好之后接下载，看客户端<br>新建一个HTML文件</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// WebSocket通信测试网址</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> ws=<span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;http://127.0.0.1:3000&#x27;</span>);<span class="comment">//连接本地测试地址</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//实例对象的onopen属性，用于指定连接成功后的回调函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//如果要指定多个回调函数，可以使用addEventListener方法。</span></span></span><br><span class="line"><span class="language-javascript">        ws.<span class="property">onopen</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">lgo</span>(<span class="string">&quot;连接建立成功！&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//建立成功之后 可以使用这个连接对象进行通信发送消息</span></span></span><br><span class="line"><span class="language-javascript">           ws.<span class="title function_">send</span>(<span class="string">&#x27;我是客户端&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        ws.<span class="property">onmessage</span>=<span class="keyword">function</span>(<span class="params">msg</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(msg.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来在控制台输入<code>node sever.js</code>来启动服务<br>在浏览器控制台可以看到<br><img src="https://img-blog.csdnimg.cn/bf21920e35cb4b79ab4f4d5275dd9698.png#pic_center" alt="客户端结果"><br>连接成功，并接收到服务端发来的消息<br>websocket有很多API </p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器(iterator)原理</title>
      <link href="/2022/09/03/%E8%BF%AD%E4%BB%A3%E5%99%A8(iterator)%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/03/%E8%BF%AD%E4%BB%A3%E5%99%A8(iterator)%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><strong>目录</strong></p><p><a href="#1.iterator%E4%BB%8B%E7%BB%8D%C2%A0%20%C2%A0">1.iterator介绍   </a></p><p><a href="#2.itertor%E4%BD%9C%E7%94%A8%C2%A0%20%C2%A0%20%C2%A0%C2%A0">2.itertor作用      </a></p><p><a href="#3.iterator%E7%9A%84%E9%81%8D%E5%8E%86%E5%8E%9F%E7%90%86">3.iterator的遍历原理</a></p><hr><h2 id="1-iterator介绍"><a href="#1-iterator介绍" class="headerlink" title="1.iterator介绍"></a>1.iterator介绍</h2><p>iterator是一种接口，为各种不同数据结构提供一种统一的访问机制，任何数据只要部署iterator接口，就可以完成遍历操作，</p><h2 id="2-itertor作用"><a href="#2-itertor作用" class="headerlink" title="2.itertor作用"></a><strong>2.itertor作用</strong></h2><p> iterator的作用有三个：一是为各种数据结构，提供一个统一的，简便的访问接口；二是使得数据结构的成员能够按照某种次序排列，三是ES6创造了一种新的遍历命令for···of循环，iterator接口主要供for···of消费</p><h2 id="3-iterator的遍历原理"><a href="#3-iterator的遍历原理" class="headerlink" title="3.iterator的遍历原理"></a>3.iterator的遍历原理</h2><p>(1) 创建一个指针对象，指向当前数据结构的起始位置，也就是说，遍历器本质上是一个指针对象</p><p>(2) 第一次调用指针对象的next 方法   可以将指针指向数据结构的第一个成员</p><p>(3) 第二次调用指针对象的next方法   指针对象将指向数据结构的第二个成员</p><p>(4) 不断调用指针对象的next方法， 直到它指向数据结构的结束位置，每一次调用next方法，都会返回数据结构的当前成员信息，具体来说就是返回一个包含value和done  两个属性的对象其中value是当前成员的值，done属性是一个布尔值  ，表示遍历是否结束</p><p><strong>模拟例子</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> it = <span class="title function_">makeIterator</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]);</span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;a&quot;, done: false &#125;</span></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;b&quot;, done: false &#125;</span></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeIterator</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.<span class="property">length</span> ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">        &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>makeIterator是一个迭代器生成函数，作用就是返回一个遍历器对象，对数组[‘a’,’b’]  执行这个函数</p><p>返回该数组的迭代器对象（即指针对象）</p><p> 2021字节跳动web工程师笔试题</p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><blockquote><p>[<br>{num: 12, city: ‘beijing’},<br>{num: 56, city: ‘shanghai’},<br>{num: 167, city: ‘guangzhou’},<br>{num: 23, city: ‘shenzhen’},<br>{num: 45, city: ‘caoxian’}<br>]<br>写一个方法实现把上面的数组转换成下面这种格式：<br>{beijing: 12, shanghai: 56,…}</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = [</span><br><span class="line">           &#123;<span class="attr">num</span>: <span class="number">12</span>, <span class="attr">city</span>: <span class="string">&#x27;beijing&#x27;</span>&#125;,</span><br><span class="line">           &#123;<span class="attr">num</span>: <span class="number">56</span>, <span class="attr">city</span>: <span class="string">&#x27;shanghai&#x27;</span>&#125;,</span><br><span class="line">           &#123;<span class="attr">num</span>: <span class="number">167</span>, <span class="attr">city</span>: <span class="string">&#x27;guangzhou&#x27;</span>&#125;,</span><br><span class="line">           &#123;<span class="attr">num</span>: <span class="number">23</span>, <span class="attr">city</span>: <span class="string">&#x27;shenzhen&#x27;</span>&#125;,</span><br><span class="line">           &#123;<span class="attr">num</span>: <span class="number">45</span>, <span class="attr">city</span>: <span class="string">&#x27;caoxian&#x27;</span>&#125;</span><br><span class="line">               ]</span><br><span class="line">           <span class="keyword">let</span> res=&#123;&#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;obj.<span class="property">length</span>;i++)&#123;</span><br><span class="line">               res[obj[i].<span class="property">city</span>]=obj[i].<span class="property">num</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure><p>遍历数组添加到对象就行了</p><p>        本周主要进行了复习，对JS基础  JS高级  ES6进行了回顾  剩余时间在学习Vue  加油！</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回顾express</title>
      <link href="/2022/08/14/%E5%9B%9E%E9%A1%BEexpress/"/>
      <url>/2022/08/14/%E5%9B%9E%E9%A1%BEexpress/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="1-express-是什么"><a href="#1-express-是什么" class="headerlink" title="1.express 是什么"></a>1.express 是什么</h2><p>Express 是一个基于 <a href="https://so.csdn.net/so/search?q=Node&spm=1001.2101.3001.7020" title="Node">Node</a>平台的Web应用开发框架，它提供了一系列的强大特性，帮助你创建各种Web应用。</p><h2 id="2-Express-框架特性"><a href="#2-Express-框架特性" class="headerlink" title="2 .Express 框架特性"></a>2 .Express 框架特性</h2><ul><li>提供了<strong>简洁的路由定义</strong>方式</li><li>对获取 http <strong>请求参数</strong>进行了<strong>简化处理</strong></li><li>对<strong>模板引擎支持程度高</strong>，方便渲染动态HTML页面</li><li>拥有<strong>中间件</strong>机制有效<strong>控制 HTTP 请求</strong></li><li>拥有大量第三方中间件对功能进行扩展</li></ul><h2 id="3-原生-node-js-与-Express-框架对比"><a href="#3-原生-node-js-与-Express-框架对比" class="headerlink" title="3 .原生 node.js 与 Express 框架对比"></a>3 .原生 node.js 与 Express 框架对比</h2><p><img src="https://img-blog.csdnimg.cn/422f6da8b6d34336ae69e70859163419.png" alt="422f6da8b6d34336ae69e70859163419.png"></p><p><img src="https://img-blog.csdnimg.cn/e9c435389c0542b5b5da8e592be66431.png" alt="e9c435389c0542b5b5da8e592be66431.png"> </p><h2 id="4-中间件"><a href="#4-中间件" class="headerlink" title="4.中间件"></a>4.中间件</h2><p> </p><p><img src="https://img-blog.csdnimg.cn/55bd7475882742339b921dc03a8d95e8.png" alt="55bd7475882742339b921dc03a8d95e8.png"></p><p><img src="https://img-blog.csdnimg.cn/647096f6d82246239deb7a99732285b2.png" alt="647096f6d82246239deb7a99732285b2.png"> </p><p><img src="https://img-blog.csdnimg.cn/27cf49b6412f40669e23658c0d81748b.png" alt="27cf49b6412f40669e23658c0d81748b.png"> </p><h2 id="5-中间件应用"><a href="#5-中间件应用" class="headerlink" title="5  中间件应用"></a>5  中间件应用</h2><h3 id="路由保护："><a href="#路由保护：" class="headerlink" title="路由保护："></a>路由保护：</h3><p>客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。</p><p>错误处理中间件</p><p>  本周还是对项目的完善，使之更加严谨可用，</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓展运算符是深拷贝还是浅拷贝</title>
      <link href="/2022/08/07/%E6%8B%93%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%BF%98%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2022/08/07/%E6%8B%93%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%BF%98%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>对于拓展运算符是深拷贝还是浅拷贝网上怎么说的都有，我就说一下我的理解。</p><p><strong>什么是深拷贝？什么是浅拷贝？</strong></p><p>假如B复制了A，修改A的时候，看B是否发生变化：</p><p>如果B也跟着<strong>变</strong>了，说明是浅拷贝，拿别人手段！</p><p>如果B<strong>没有改变</strong>，说明是深拷贝，自食其力！</p><p><strong>怎么判断拓展运算符是什么拷贝呢？</strong></p><p>看一下下面的例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"> <span class="keyword">let</span> b = [...a];</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//[1,2,3]</span></span><br><span class="line"> a[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//[1,4,3]</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure><p>结合浅拷贝和深拷贝的概念，那拓展运算符是不是深拷贝？别急看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> peoples = [&#123;<span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">sex</span>:<span class="string">&quot;男&quot;</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&#x27;ls&#x27;</span>,<span class="attr">age</span>:<span class="number">16</span>,<span class="attr">sex</span>:<span class="string">&quot;女&quot;</span>&#125;];</span><br><span class="line">  <span class="keyword">let</span> peoplesTwo = [...peoples];</span><br><span class="line">  peoples[<span class="number">0</span>].<span class="property">age</span> = <span class="number">22</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(peoples);<span class="comment">//[&#123;name:&#x27;zs&#x27;,age:22,sex:&quot;男&quot;&#125;,&#123;name:&#x27;ls&#x27;,age:16,sex:&quot;女&quot;&#125;]</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(peoplesTwo);<span class="comment">//[&#123;name:&#x27;zs&#x27;,age:22,sex:&quot;男&quot;&#125;,&#123;name:&#x27;ls&#x27;,age:16,sex:&quot;女&quot;&#125;]</span></span><br></pre></td></tr></table></figure><p>结合浅拷贝和深拷贝的概念，那拓展运算符是不是浅拷贝？</p><p>所以结合上面两个例子得出一个结论，拓展运算符是深拷贝还是浅拷贝是看具体拷贝内容的，当拷贝的内容只有一层时是深拷贝，层数很多时时浅拷贝，如果还是不太理解可以先看深拷贝和浅拷贝的定义然后自己手敲一下代码，</p><p>        加油</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript vue.js 开发语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目总结篇</title>
      <link href="/2022/07/31/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E7%AF%87/"/>
      <url>/2022/07/31/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>        从开始项目到现在也快40天了，在这个过程中不得不说，交流真的很重要，要是交流多一点，项目估计早就完成了，找bug也找的差不多了，项目现在还有些功能不太完善，学分认证系统功能应该朝着实用性，和安全性出发，这是最重要的，还有交互体验很重要，能够简单明了的一眼看出网站的使用规则，而不是功能隐藏起来，轻松上手，快速使用。</p><p>        项目bug正在修复，代码嵌入，功能失效·······啥的，正在改,还有交互体验上，各种信息的提示需要做出来，给用户足够的反馈信息。明白咋回事，</p><p>        学习方面，主要还是项目经验吧，还有各种第三方工具的使用，接下来继续努力，加油</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 java html 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS通过文件URL路径下载文件</title>
      <link href="/2022/07/24/JS%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6URL%E8%B7%AF%E5%BE%84%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/"/>
      <url>/2022/07/24/JS%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6URL%E8%B7%AF%E5%BE%84%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">exportFile</span> <span class="operator">=</span> (data, fileName, _this)=&gt;&#123;</span><br><span class="line">　<span class="comment">// 地址不存在时，禁止操作</span></span><br><span class="line">  <span class="keyword">if</span>(!data)<span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 下载文件并保存到本地</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">callback</span> <span class="operator">=</span> (data)=&gt;&#123;</span><br><span class="line">　　 <span class="comment">// 创建a标签，使用 html5 download 属性下载，</span></span><br><span class="line">    <span class="type">const</span> <span class="variable">link</span> <span class="operator">=</span> document.createElement(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">　　 <span class="comment">// 创建url对象</span></span><br><span class="line">    <span class="type">const</span> <span class="variable">objectUrl</span> <span class="operator">=</span> window.URL.createObjectURL(<span class="keyword">new</span> <span class="title class_">Blob</span>([data]));</span><br><span class="line">    link.style.display=<span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    link.href=objectUrl;</span><br><span class="line">　　 <span class="comment">// 自定义文件名称， fileName</span></span><br><span class="line">　　 link.download = fileName; </span><br><span class="line">　　 document.body.appendChild(link); </span><br><span class="line">　　 link.click();</span><br><span class="line">　　 <span class="comment">// 适当释放url</span></span><br><span class="line">    window.URL.revokeObjectURL(objectUrl);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 把接口返回的url地址转换为 blob</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">xhr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.open(<span class="string">&#x27;get&#x27;</span>, data, <span class="literal">true</span>);</span><br><span class="line">  xhr.responseType = <span class="string">&#x27;blob&#x27;</span>;</span><br><span class="line">  xhr.onload = ()=&gt; &#123;</span><br><span class="line">　　 <span class="comment">// 返回文件流，进行下载处理</span></span><br><span class="line">    callback(xhr.response);</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.send(); <span class="comment">// 不要忘记发送</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ie和浏览器兼容模式会有问题，可以用下面代码调试。</span></span><br><span class="line">　<span class="keyword">try</span>&#123;</span><br><span class="line">    exportFile(); <span class="comment">// 调用方式</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="comment">// 兼容模式下，IE</span></span><br><span class="line">    <span class="type">const</span> <span class="variable">exportBlob</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Blob</span>([data]);</span><br><span class="line">    <span class="keyword">if</span> (navigator.userAgent.indexOf(<span class="string">&#x27;Trident&#x27;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      window.navigator.msSaveBlob(data, fileName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      exportFile(); <span class="comment">// 调用方式</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>调用方式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">exportFile</span>(<span class="string">&#x27;https://reading.oss.iyougu.com/uploads/mp/opus/1c5a8b6a391742cf93595d0a506b2d43.mp3&#x27;</span>, <span class="string">&#x27;测试.mp3&#x27;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript 前端 开发语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="/2022/07/17/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/17/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><strong>一、基本命令</strong><br>1.1 关机和重启<br>关机<br>    shutdown -h now        立刻关机<br>    shutdown -h 5        5分钟后关机<br>    poweroff            立刻关机<br>重启<br>    shutdown -r now        立刻重启<br>    shutdown -r 5        5分钟后重启<br>    reboot                立刻重启</p><h2 id="1-2-帮助命令"><a href="#1-2-帮助命令" class="headerlink" title="1.2 帮助命令"></a>1.2 帮助命令</h2><p>--help命令<br>  shutdown --help：<br>  ifconfig  --help：查看网卡信息<br> <br>man命令（命令说明书） <br>  man shutdown<br>  注意：man shutdown打开命令说明书之后，使用按键q退出</p><p><strong>二、目录操作命令</strong><br>2.1 目录切换 cd<br>命令：cd 目录</p><p>cd /        切换到根目录<br>cd /usr        切换到根目录下的usr目录<br>cd ../        切换到上一级目录 或者  cd ..<br>cd ~        切换到home目录<br>cd -        切换到上次访问的目录</p><p><strong>2.2 目录查看 ls [-al]</strong><br>命令：ls [-al]</p><p>ls                查看当前目录下的所有目录和文件<br>ls -a            查看当前目录下的所有目录和文件（包括隐藏的文件）<br>ls -l 或 ll       列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）<br>ls /dir            查看指定目录下的所有目录和文件   如：ls /usr</p><p><strong>2.3 目录操作【增，删，改，查】</strong><br>2.3.1 创建目录【增】 mkdir<br>命令：mkdir 目录</p><p>mkdir    aaa            在当前目录下创建一个名为aaa的目录<br>mkdir    /usr/aaa    在指定目录下创建一个名为aaa的目录</p><p><strong>2.3.2 删除目录或文件【删】rm</strong><br>命令：rm [-rf] 目录</p><p>删除文件：<br>rm 文件        删除当前目录下的文件<br>rm -f 文件    删除当前目录的的文件（不询问）</p><p>删除目录：<br>rm -r aaa    递归删除当前目录下的aaa目录<br>rm -rf aaa    递归删除当前目录下的aaa目录（不询问）</p><p>全部删除：<br>rm -rf *    将当前目录下的所有目录和文件全部删除<br>rm -rf /*    【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除</p><p>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录/文件/压缩包   </p><p>正在学习，，，</p><p>本周呢，还是以项目为主又完成了一些功能，马上就能做完了，加油</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本周学习总结</title>
      <link href="/2022/07/03/%E6%9C%AC%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/03/%E6%9C%AC%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>        </p><h2 id="1使用-Bootstrap-构建快速、响应式布局的网站"><a href="#1使用-Bootstrap-构建快速、响应式布局的网站" class="headerlink" title="1使用 Bootstrap 构建快速、响应式布局的网站"></a><strong>1使用 Bootstrap 构建快速、响应式布局的网站</strong></h2><p><a href="https://so.csdn.net/so/search?q=Bootstrap&spm=1001.2101.3001.7020" title="Bootstrap">Bootstrap</a> 是全球最流行的前端开源工具包，它支持 Sass 变量和 mixins、响应式网格系统、大量的预建组件和强大的 JavaScript 插件，助你快速设计和自定义响应式、移动设备优先的站点。</p><h2 id="2-布局容器"><a href="#2-布局容器" class="headerlink" title="** 2.布局容器**"></a>** 2.布局容器**</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span><br><span class="line">.<span class="property">container</span>-<span class="attr">fluid</span>:横跨视口的全宽度的容器。</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    .container：有最大固定宽度的容器。最大固定宽度依据于视口（viewport）的断点（breakpoints）而不同。</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="3-网格系统"><a href="#3-网格系统" class="headerlink" title="3.网格系统"></a>3.网格系统</h2><p>Bootstrap 4 网格系统有以下 5 个类:</p><p>.col- 针对所有设备<br>.col-sm- 平板 - 屏幕宽度等于或大于 576px<br>.col-md- 桌面显示器 - 屏幕宽度等于或大于 768px)<br>.col-lg- 大桌面显示器 - 屏幕宽度等于或大于 992px)<br>.col-xl- 超大桌面显示器 - 屏幕宽度等于或大于 1200px)<br>        这周主要就是学习使用了<strong>Bootstrap5</strong> 写网页，学习了使用axios 对第三方接口进行请求，统一配置请求头，请求拦截器，响应拦截器，对错误代码同意管理，接下来就是尽量熟练的使用axios,完成交互任务，��数据做点什么<br>    return response;<br>  }, function (error) {<br>    // 对响应错误做点什么<br>    return Promise.reject(error);<br>  });<br>```</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本周学习笔记</title>
      <link href="/2022/06/26/%E6%9C%AC%E5%91%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/06/26/%E6%9C%AC%E5%91%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>一、node.js简介</p><p> </p><p>1.Node.js是一个能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境。</p><p>2.Node采用Google开发的V8引擎运行js代码，使用事件驱动、非阻塞和异步I/O模型等技术来提高性能，可优化应用程序的传输量和规模。</p><p>3.Node大部分基本模块都用JavaScript编写。在Node出现之前，JS通常作为客户端程序设计语言使用，以JS写出的程序常在用户的浏览器上运行。</p><p>3.目前，Node已被IBM、Microsoft、Yahoo!、Walmart、Groupon、SAP、 LinkedIn、Rakuten、PayPal、Voxer和GoDaddy等企业采用</p><p>4.Node主要用于编写像Web服务器一样的网络应用，这和PHP和Python是类似的。</p><p>但是Node与其他语言最大的不同之处在于，PHP等语言是阻塞的而Node是非阻塞的。</p><p>Node是事件驱动的。开发者可以在不使用线程的情况下开发出一个能够承载高并发的服务器。其他服务器端语言难以开发高并发应用，而且即使开发出来，性能也不尽人意。</p><p>Node正是在这个前提下被创造出来。</p><p>Node把JS的易学易用和Unix网络编程的强大结合到了一起。</p><p>5.Node.js允许通过JS和一系列模块来编写服务器端应用和网络相关的应用。</p><p>6.核心模块包括文件系统I/O、网络（HTTP、TCP、UDP、DNS、TLS/SSL等）、二进制数据流、加密算法、数据流等等。Node模块的API形式简单，降低了编程的复杂度。</p><p>7.使用框架可以加速开发。常用的框架有Express.js、Socket.IO和Connect等。Node.js的程序可以在Microsoft Windows、Linux、Unix、Mac OS X等服务器上运行。</p><p>8.Node.js也可以使用CoffeeScript、TypeScript、Dart语言，以及其他能够编译成JavaScript的语言编程。</p><p>二.Node.Js用途</p><p> </p><p>1.Web服务API，比如REST</p><p>实时多人游戏</p><p>2.后端的Web服务，例如跨域、服务器端的请求</p><p>3.基于Web的应用</p><p>多客户端的通信，如即时通信</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 javascript node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一周学习总结</title>
      <link href="/2022/06/19/%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2022/06/19/%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>这一周，按照学习计划学习了node.js及相关的内容，学习了一个简单的数据库，我感觉真的要是精通node.js那真的是非常厉害，几乎是想做什么就做什么，接下来我将会进行实践练习，加深理解，更加熟练的运用，该与对于项目结构的规范都要进行实践练习，</p><p>        这段时间的学习，感觉到挺充实的，相比整天在家玩耍好得多，每天按时规律起床,晚上出去跑个步，其余时间用来敲代码我感觉还是很好的，我的许多同学都外出打工了，确实能挣到很多钱，但是他们的能力在原地踏步，不羡慕他们，加油提升自己更重要</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PS学习总结</title>
      <link href="/2022/06/11/PS%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2022/06/11/PS%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>        这周对PS进行了基础的学习，简单的操作，抠图，蒙版的使用，调色，各种工具的使用都应经学会了，其实PS大有可学，因为我不是专业的，仅仅学习了PS的一点皮毛，这些皮毛就已经够我用的了，这是用来找新做东西用的，希望我能够为招新做点什么，让宣传海报更加具有吸引力，</p><p>        这周呢，在家学习感到是时间很是充足，想学什么都有时间，下一阶段要学习node.js这是一个用js做后端的一个基于V8的一个运行环境，感觉学完这个就能够自己做一整个项目了，既有前端，又有后端，我会更加努力的，这个的学习是对JS的基础的考验，平时会多看看红宝书，加强自己的基础知识，巩固一下，学好node.js,就想做什么就做什么了，自己一个人就能完成前后端的工作,加油，不过最近要把考试课复习一下，还有一场考试加油！</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目继续进行</title>
      <link href="/2022/05/15/%E9%A1%B9%E7%9B%AE%E7%BB%A7%E7%BB%AD%E8%BF%9B%E8%A1%8C/"/>
      <url>/2022/05/15/%E9%A1%B9%E7%9B%AE%E7%BB%A7%E7%BB%AD%E8%BF%9B%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>  这次的考核内容的完善项目，我准备把项目进行进一步的完善，改一改bug，这次新加的内容全部使用原生JS，除了ajax 用JQ其他的都使用原生的，本次后端使用了spring boot 这就要求我们要使用th前几天我对th进行了学习，现在项目到了后期阶段，想要全换成th是不太可能的，再写的内容尽量使用th，我会吸取上次的教训，把学长们提出的问题进行修复，使得页面看起来更加合理，各种内容的分页处理，增删改查，美食网站，我尽量让它看起来像美食网站，</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美食项目考核总结</title>
      <link href="/2022/05/08/%E7%BE%8E%E9%A3%9F%E9%A1%B9%E7%9B%AE%E8%80%83%E6%A0%B8%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/08/%E7%BE%8E%E9%A3%9F%E9%A1%B9%E7%9B%AE%E8%80%83%E6%A0%B8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>从项目开始到结束，经过了差不多一个月，项目功能基本实现，考核中，才知道自己原来还有很多问题没有考虑周到，这次之后我会格外注意，各种漏洞，要尽可能去想用户会怎么操作做这个页面，应对多种情况，防止一些操作直接使得网页崩溃，这次考核中出现的很多问题，例如用户界面的关注，收藏什么的没有做成分页的形式，导致内容很多的时候浏览器压力很大，导致崩溃，项目后续会进行完善，增加功能，同时修改原先的bug,增加更加人性化的操作，还有在css动画效果上，我会尽量使用原生的js,css去写动画效果，JQ只用一个ajax就够了，锻炼自己的能力，项目上我负责的是网站前台部分。整个部分的结构不复杂，应用的技术不是不是很难，这次主要锻炼一下使用promise的能力。才知道，promise的状态只能改变一次，要不就重新返回一个new promise</p><p>我们项目组三个人，两个前端，一个后端，合作起来还算可以，进度基本能够相互配合，这次考核学到很多东西，有了做项目的经验，团队合作，分工好，才能更高效的完成任务，前后端交流好,互相说明一下需求，交互起来更加容易，得心应手。这次的评论我做的不好，评论的回复，子评论的回复后显示，直接刷新整个评论，这样确实更简单了，但是确实多流量的浪费，如果评论有很多那么就会非常浪费资源，接下来我会尽量改进这个评论功能；</p><p>        考核中没有使用thymeleaf,这是应该会的，但是我不太会用，所以从一开始就没有用，到了中期再用也比较麻烦。下次有机会一定会用的，这个方法,thymeleaf的话，是在服务器渲染页面，而直接ajax是再客户端渲染页面，</p><p>        下一阶段，我计划加强自己的代码规范，尽量原生JS写所有的内容，加油</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 css3 html 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目最后总结</title>
      <link href="/2022/04/30/%E9%A1%B9%E7%9B%AE%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93/"/>
      <url>/2022/04/30/%E9%A1%B9%E7%9B%AE%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>        这次项目就快要结束了，项目希望这几天能够做完，做好，保质保量， 最后会进行bug测试，尽量使得项目能够像一个正常的网站能够正常使用，在这一周的的过程中，发现项目还是有点不够人性化，希望让用户用着舒服，不追求功能多么厉害，但是要好用，评论还差点，希望我能够顺利完成，之后会进行拓展功能的实现，后台希望能够尽快与网页主体实现正常功能。</p><p>其他也没什么说的</p><p>把我项目的工具库函数发出来吧</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getStyle</span>(<span class="params">obj, name</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">getComputedStyle</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">getComputedStyle</span>(obj, <span class="literal">null</span>)[name];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> obj.<span class="property">currentStyle</span>[name];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">imgup</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> file = obj.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line"><span class="keyword">let</span> name1 = obj.<span class="property">parentNode</span>.<span class="property">children</span>[<span class="number">0</span>];</span><br><span class="line">reader.<span class="title function_">readAsDataURL</span>(file);</span><br><span class="line">reader.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span><br><span class="line"><span class="comment">/*  $(name).attr(&quot;src&quot;, ev.target.result); */</span></span><br><span class="line">name1.<span class="title function_">setAttribute</span>(<span class="string">&quot;src&quot;</span>, ev.<span class="property">target</span>.<span class="property">result</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outdifficulty</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> text = obj.<span class="property">innerText</span>;</span><br><span class="line">$(<span class="string">&quot;.pr-inner-xz:eq(0)&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;value&quot;</span>, text);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outdifficulty2</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> text = obj.<span class="property">innerText</span>;</span><br><span class="line">$(<span class="string">&quot;.pr-inner-xz:eq(1)&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;value&quot;</span>, text);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除功能</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">del</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> a = obj.<span class="property">parentNode</span>;</span><br><span class="line">a.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">del1</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> a = obj.<span class="property">parentNode</span>.<span class="property">parentNode</span>;</span><br><span class="line">a.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">userkouweitext</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> text = obj.<span class="property">innerText</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span><br><span class="line">$(<span class="string">&quot;.kouweiinput&quot;</span>).<span class="title function_">val</span>(text);</span><br><span class="line">$(<span class="string">&quot;.kouweilist&quot;</span>).<span class="title function_">fadeOut</span>(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pushcode</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line"><span class="attr">async</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="attr">dataType</span>:<span class="string">&quot;json&quot;</span>,</span><br><span class="line"><span class="attr">type</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line"><span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/user/getSession&quot;</span>,</span><br><span class="line"><span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">date</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (date.<span class="property">data</span> == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">obj.<span class="property">src</span> = <span class="string">&quot;http://localhost:8080/recipe/getCode?id=&quot;</span> +date.<span class="property">data</span>.<span class="property">id</span>+ <span class="string">&quot;&amp;&quot;</span> + <span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pushcode2</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line"><span class="attr">async</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="attr">dataType</span>:<span class="string">&quot;json&quot;</span>,</span><br><span class="line"><span class="attr">type</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line"><span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/user/getSession&quot;</span>,</span><br><span class="line"><span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">date</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (date.<span class="property">data</span> == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">obj.<span class="property">src</span> = <span class="string">&quot;http://localhost:8080/menu/getCode?id=&quot;</span> +date.<span class="property">data</span>.<span class="property">id</span>+ <span class="string">&quot;&amp;&quot;</span> + <span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outlogin</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> userimgtab = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;userimgmodel&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> longin = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;longin&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">userimgtab.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">longin.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">$.<span class="title function_">get</span>(<span class="string">&quot;http://localhost:8080/user/exist&quot;</span>,</span><br><span class="line">&#123;&#125;,</span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">assign</span>(<span class="string">&#x27;./home-page.html&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logintest</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> userimgtab = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;userimgmodel&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> admin=<span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;userimgtab&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> longin = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;longin&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line"><span class="attr">async</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="attr">dataType</span>:<span class="string">&quot;json&quot;</span>,</span><br><span class="line"><span class="attr">type</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line"><span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/user/getSession&quot;</span>,</span><br><span class="line"><span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">date</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (date.<span class="property">data</span> == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">userimgtab.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">longin.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">userimgtab.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">longin.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(date.<span class="property">data</span>.<span class="property">sign</span>==<span class="number">1</span>)&#123;</span><br><span class="line">$(admin.<span class="property">children</span>[<span class="number">0</span>]).<span class="title function_">append</span>(<span class="string">`&lt;li&gt;&lt;a href=&quot;./back-html/background.html&quot;&gt;进入后台&lt;/a&gt;&lt;/li&gt;`</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;普通用户&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">upmsg</span>(<span class="params">param</span>) &#123;</span><br><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line"><span class="attr">async</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="attr">dataType</span>:<span class="string">&quot;json&quot;</span>,</span><br><span class="line"><span class="attr">type</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line"><span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/user/getSession&quot;</span>,</span><br><span class="line"><span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">date</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (date.<span class="property">data</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">$.<span class="title function_">get</span>(<span class="string">&quot;http://localhost:8080/user/getUser&quot;</span>,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;id&quot;</span>: date.<span class="property">data</span>.<span class="property">id</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">function</span> (<span class="params">date</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> userimgmodel = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;userimgmodel&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">$(userimgmodel.<span class="property">children</span>[<span class="number">0</span>].<span class="property">children</span>[<span class="number">0</span>]).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>, date.<span class="property">data</span>.<span class="property">userInfo</span>.<span class="property">photo</span>);</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取URL传递的参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getQueryVariable</span>(<span class="params">variable</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> query = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>.<span class="title function_">substring</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> vars = query.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vars.<span class="property">length</span>; i++) &#123;</span><br><span class="line"><span class="keyword">var</span> pair = vars[i].<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pair[<span class="number">0</span>] == variable) &#123; <span class="keyword">return</span> pair[<span class="number">1</span>]; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getQueryVariable2</span>(<span class="params">variable, url</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> query = url.<span class="title function_">substring</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> vars = query.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vars.<span class="property">length</span>; i++) &#123;</span><br><span class="line"><span class="keyword">var</span> pair = vars[i].<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pair[<span class="number">0</span>] == variable) &#123; <span class="keyword">return</span> pair[<span class="number">1</span>]; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasclass</span>(<span class="params">obj, join</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;\\b&quot;</span> + join + <span class="string">&quot;\\b&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> reg.<span class="title function_">test</span>(obj.<span class="property">className</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addClass</span>(<span class="params">obj, join</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_">hasclass</span>(obj, join)) &#123;</span><br><span class="line">obj.<span class="property">className</span> += <span class="string">&quot; &quot;</span> + join;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deleteclass</span>(<span class="params">obj, join</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;\\b&quot;</span> + join + <span class="string">&quot;\\b&quot;</span>);</span><br><span class="line">obj.<span class="property">className</span> = obj.<span class="property">className</span>.<span class="title function_">replace</span>(reg, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">statuswitch</span>(<span class="params">i</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> type1 = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;type-head&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="title function_">deleteclass</span>(type1.<span class="property">children</span>[i], <span class="string">&quot;active&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;.state:eq(&quot;</span> + (i + <span class="number">2</span>) + <span class="string">&quot;)&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;#020202&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">$(<span class="string">&quot;.state:eq(&quot;</span> + (i + <span class="number">2</span>) + <span class="string">&quot;)&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;rgb(255,197,82)&quot;</span>);</span><br><span class="line"><span class="title function_">addClass</span>(type1.<span class="property">children</span>[i], <span class="string">&quot;active&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;.content2&quot;</span>).<span class="title function_">empty</span>();</span><br><span class="line"><span class="comment">//清空后用根据选择的项目进行ajax请求获取对应数据</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------</span></span><br><span class="line"><span class="comment">//收藏内部的加载</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">$(<span class="string">&quot;.recipe-head&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;display&quot;</span>, <span class="string">&quot;block&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;.content2&quot;</span>).<span class="title function_">empty</span>();</span><br><span class="line"><span class="comment">//ajax请求收藏菜谱的数据！！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">$(<span class="string">&quot;.recipe-head&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;display&quot;</span>, <span class="string">&quot;none&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">search</span>(<span class="params">param</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> tabsearchcontent = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;tabsearchcontent&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tabsearchcontent.<span class="property">value</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">assign</span>(<span class="string">`searchpage.html?name=<span class="subst">$&#123;tabsearchcontent.value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>  <span class="title function_">zuiresousuo</span>(<span class="params">obj</span>) &#123; </span><br><span class="line"><span class="keyword">let</span> url=<span class="built_in">encodeURI</span>(<span class="string">`searchpage.html?name=<span class="subst">$&#123;obj.children[<span class="number">0</span>].innerText&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">assign</span>(url);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">search1</span>(<span class="params">param</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> tabsearchcontent = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;tabsearchcontent&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tabsearchcontent.<span class="property">value</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">assign</span>(<span class="string">`../searchpage.html?name=<span class="subst">$&#123;tabsearchcontent.value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fenlei</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> url=<span class="built_in">encodeURI</span>(<span class="string">`../searchpage.html?name=<span class="subst">$&#123;obj.innerText&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">assign</span>(url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fenlei1</span>(<span class="params">obj</span>) &#123;  </span><br><span class="line"><span class="keyword">let</span> url=<span class="built_in">encodeURI</span>(<span class="string">`./searchpage.html?name=<span class="subst">$&#123;obj.innerText&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">assign</span>(url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">textnums</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">value</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">200</span>-obj.<span class="property">value</span>.<span class="property">lenght</span>&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">obj.<span class="property">value</span>.<span class="property">lenght</span>=<span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"> $(<span class="string">&quot;.talknums&quot;</span>).<span class="title function_">text</span>(<span class="string">`还可以输入<span class="subst">$&#123;<span class="number">200</span>-obj.value.length&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">zitinums</span>(<span class="params">obj</span>)&#123;</span><br><span class="line"><span class="keyword">let</span> obj1=obj.<span class="property">parentNode</span>;</span><br><span class="line"><span class="keyword">let</span> kuang=obj1.<span class="property">children</span>[<span class="number">1</span>].<span class="property">children</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="number">200</span>-obj.<span class="property">value</span>.<span class="property">lenght</span>&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">obj.<span class="property">value</span>.<span class="property">lenght</span>=<span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">$(kuang).<span class="title function_">text</span>(<span class="string">`还可以输入<span class="subst">$&#123;<span class="number">200</span>-obj.value.length&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有注释，因为也就我一个人看😎</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本周项目总结</title>
      <link href="/2022/04/23/%E6%9C%AC%E5%91%A8%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2022/04/23/%E6%9C%AC%E5%91%A8%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>这周我们组后端接口提供的差不多了，压力来到了我们前端，这周完成了主页面的热门菜谱显示，菜单的上传，用户界面的中，菜谱菜单的显示，及菜谱的删除功能，菜谱详情页的展示，关注和收藏，对登录注册页面的重写，美化了用户界面，判断更加严谨，</p><p>在交互中遇到了很多问题，不过都是些小问题，只要交流好都不是问题，这周的交互中，主要是对以前不合理的地方进行修改，代码更加具有普适性，可以搬运，减少重复性劳动，JS中还是要注意规范，不然一个小错误，可能会浪费大量的时间,很难发现</p><p>下周，我计划把网站主体所有功能全部实现，当然评论功能不在其中，因为想要实现一个好的评论功能，可能需要大量的时间，等把主要功能做的差不多了，再去做评论，还有就是上传数据的前端判断，下周把上传相关的判断给完善一下，防止错误数据和空数据的上传，还有界面的美化，感觉还是主要在我们前端，各种交互，需要总结一下经验，如果还有时间，会继续增加功能，</p><p>最后分享一个正则表达式</p><p>是用来检测邮箱的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^[0-9a-zA-Z_.-]+[@][0-9a-zA-Z_.-]+([.][a-zA-Z]+)&#123;1,2&#125;$/</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周总结关于项目</title>
      <link href="/2022/04/16/%E5%91%A8%E6%80%BB%E7%BB%93%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE/"/>
      <url>/2022/04/16/%E5%91%A8%E6%80%BB%E7%BB%93%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>这周静态页面基本已经完工，没剩几个页面了，</p><p>在交互方面实现了，用户的登录注册，账户信息的修改，菜谱步骤的上传（实现了一半），这周的交互我发现前后端传收数据，需要确定好发送的格式，需要与后端讨论好如何去存储一些信息，此次的图片上传中，学会了使用JS原生的FormData来传输文件，传输文件时要使用$.ajax而不能直接使用$.post因为需要调整一些参数的类型，</p><p>如下是一个例子</p><p>我使用$.ajax传输一个图片文件</p><p>其中把</p><p>contentType设置成了false</p><p>processData设置成了false</p><p>就时不对我所发送的数据做处理；直接发送</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">userimg2</span>(<span class="params">param</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> file=param.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">let</span> senddata = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">   senddata.<span class="title function_">append</span>(<span class="string">&quot;file&quot;</span>,file);</span><br><span class="line">   senddata.<span class="title function_">append</span>(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">let</span> ready = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">   $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&quot;http://10.102.241.171:8080/user/insertUserPhoto&quot;</span>,</span><br><span class="line">      <span class="attr">data</span>: senddata,</span><br><span class="line">      <span class="attr">contentType</span>:<span class="literal">false</span>,</span><br><span class="line">      <span class="attr">processData</span>:<span class="literal">false</span>,</span><br><span class="line">      <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span>(response.<span class="property">msg</span>==<span class="string">&quot;插入成功！&quot;</span>)&#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">msg</span>);</span><br><span class="line">            <span class="keyword">let</span> name1 = param.<span class="property">parentNode</span>.<span class="property">parentNode</span>.<span class="property">children</span>[<span class="number">0</span>];</span><br><span class="line">            ready.<span class="title function_">readAsDataURL</span>(file);</span><br><span class="line">            ready.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span><br><span class="line">               name1.<span class="title function_">setAttribute</span>(<span class="string">&quot;src&quot;</span>,ev.<span class="property">target</span>.<span class="property">result</span>);</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">error</span>:<span class="keyword">function</span> (<span class="params">param</span>) &#123;</span><br><span class="line">         <span class="title function_">alert</span>(<span class="string">&quot;失败了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有就是，插入图片的直接显示</p><p>如下传入一个类型为file的input </p><p>通过readAsDataUrl把文件转为base64格式直接赋给img的src属性就能显示了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">imgup</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> file=obj.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> reader = <span class="keyword">new</span>  <span class="title class_">FileReader</span>();</span><br><span class="line"><span class="keyword">let</span> name1=obj.<span class="property">parentNode</span>.<span class="property">children</span>[<span class="number">0</span>];</span><br><span class="line">     reader.<span class="title function_">readAsDataURL</span>(file);</span><br><span class="line">     reader.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span><br><span class="line">        <span class="comment">/*  $(name).attr(&quot;src&quot;, ev.target.result); */</span></span><br><span class="line"> name1.<span class="title function_">setAttribute</span>(<span class="string">&quot;src&quot;</span>,ev.<span class="property">target</span>.<span class="property">result</span>)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thymeleaf</title>
      <link href="/2022/04/10/Thymeleaf/"/>
      <url>/2022/04/10/Thymeleaf/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p> 1. Thymeleaf概述</p><p>Thymeleaf是一个Java模板引擎，支持html、xml、text、javascript、css、raw这几种模型。 </p><p>使用Thymeleaf首先需要引入命名空间</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html  <span class="attr">xmlns</span>:th=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>2. 基本使用方法</p><p>1⃣️引用web静态资源 </p><p>Thymeleaf通过”@{}”来引用web静态资源，例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script <span class="attr">th</span>:src=<span class="string">&quot;@&#123;bootstrap/js/boostrap.min.js&#125;&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>2⃣️访问model模型中的数据，例如访问一个user对象的name属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;span <span class="attr">th</span>:text=<span class="string">&quot;$&#123;user.name&#125;&quot;</span>&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>3⃣️在Javascript中访问model模型数据</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script <span class="attr">th</span>:inline=<span class="string">&quot;javascript&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> user = [[$&#123;user&#125;]]</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span> + <span class="string">&quot;\t&quot;</span> + user.<span class="property">age</span>);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>  这一段时间，感觉自己学习的还是太少，不会的很多，学无止境，各种模版都需要学习，现在开始了前后端交互，怎么合作，怎么合作好是现在我面临的问题，第一次交互，我觉得能后收获很多东西，希望能够顺利完成这次的任务。</p><p>之后会继续写静态页面，等后端接口能用了，在进行下一步</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS引擎的执行机制</title>
      <link href="/2022/04/02/JS%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/04/02/JS%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><em><strong>1.首先JS是单线程的</strong></em></p><p><strong><em>2.JS的Event Loop是JS的执行机制。深入了解JS的执行,就等于深入了解JS里的event loop</em></strong></p><p>Event loop事件循环</p><p>先看一个例子如下:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个例子的执行输出顺序是1 3 2；</p><p>也就是说,setTimeout里的函数并没有立即执行,而是延迟了一段时间,满足一定条件后,才去执行的,这类代码,我们叫异步代码。</p><p>JS中有两类任务，一类是同步任务，一类是异步任务</p><p>按照这种分类方式:JS的执行机制是</p><blockquote><p><strong>Event Table</strong> 就是个注册站：调用栈让Event Table注册一个函数，该函数会在达到条件后被调用。当指定的事情发生时，Event Table会将这个函数移到Event Queue。<strong>Event Queue</strong>其实就是个缓冲区域，这里的函数等着被调用并移到调用栈。</p></blockquote><ul><li>首先判断JS是同步还是异步,同步就进入主线程,异步就进入event table</li><li>异步任务在event table中注册函数,当满足触发条件后,被推入event queue</li><li>同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主线程中</li></ul><p>以上三步循环执行,这就是event loop；</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">​</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)<span class="comment">//同步任务进入主线程；直接输出</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="comment">/*异步任务进入event table(注册站)等待0秒后被放入event queue(缓冲区)中；待主线程行完成后在去缓冲区中看看有没有任务，再执行*/</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)<span class="comment">//同步任务进入主线程直接输出；</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>还有一种情况，假如在一个程序中，有许多个异步任务，那么先执行哪一个呢？；在异步任务中并不是按照进入事件队列的先后顺序去执行的；而是另有规定；</p><p>再举一个例子：如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定时器开始啦&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;马上执行for循环啦&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">        i == <span class="number">99</span> &amp;&amp; <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行then函数啦&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;代码执行结束&#x27;</span>);</span><br><span class="line">   </span><br></pre></td></tr></table></figure><blockquote><p> 这段代码中；第一个定时器是异步任务会被放到event  table中；</p><p>new Promise 是同步任务，会被放到主线程中直l接执行打印</p><p>.then里的函数是异步任务，被放到event table</p><p>console.log(‘代码执行结束’)；是同步代码被放到主线程中；直接执行；</p></blockquote><p> 结果是：      马上执行for循环啦 -– 代码执行结束 -– 执行then函数啦 -– 定时器开始啦</p><p><strong>如果仅仅按照异步同步去判断执行流程是不足够的，不够准确,</strong></p><p>像上面的这个代码.then   和   setTimeout都是异步的，但是执行结果并没有按照进入事件队列的顺序执行的，</p><p>而准确的划分方式是按照<strong>宏任务</strong>和<strong>微任务</strong>划分的</p><p>macro-task(宏任务)：包括整体代码script，setTimeout,setInterval</p><p>micro-task(微任务)：promise，process,nextTick;</p><p><img src="https://img-blog.csdnimg.cn/b93c9dddfb2246af9f5960c0edf540bd.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rqQ5YiD,size_20,color_FFFFFF,t_70,g_se,x_16"></p><blockquote><p>首先执行script下的宏任务,遇到setTimeout,将其放到宏任务的【队列】里（这个在下一个事件循环的宏任务里添加，不是在当前宏任务中添加的）</p><p>遇到 new Promise直接执行,打印”马上执行for循环啦”</p><p>遇到then方法,是微任务,将其放到微任务的【队列里】</p><p>打印 “代码执行结束”</p><p>本轮宏任务执行完毕,查看本轮的微任务,发现有一个then方法里的函数, 打印”执行then函数啦”</p><p>到此,本轮的event loop 全部完成。</p></blockquote><p>下一轮的循环里,先执行一个宏任务,发现宏任务的【队列】里有一个 setTimeout里的函数,执行打印”定时器开始啦了；</p><p><a href="https://segmentfault.com/a/1190000012806637" title="原内容地址，感谢博主的精心讲解！">原内容地址，感谢博主的精心讲解！</a></p><p>周总结：</p><p>这周在学习js高级的内容；内容可以说很多，可以学习的知识很深，我现在只是浅浅的明白一些内容；红宝书的内容很多；这周学习总体上理论上的东西比较多；接下来我会进行实践，实际操作一下更深层次的理解；闭包，对象创建模式；继承都没有进行实践操作过；也不太清楚什么时候会用</p><p>希望能够尽快进行前后端交互;让我多一些实战经验；实际操作可比看书能学到的多的多；这周感觉挺累的，需要稍稍调整一下，马上就要有新成员进来了；我们的压力大了一些，可不能让他们超越了已经学了几个月的我们，要不然就感觉我们学习效率很低；</p><p>加油继续努力（卷）；</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS对象创建模式</title>
      <link href="/2022/03/27/JS%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/03/27/JS%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>对象创建模式有以下几种：</p><p><strong>1.工厂模式</strong></p><p><strong>2.构造函数模式</strong></p><p><strong>3.原型模式</strong></p><p><strong>4.组合使用构造函数模式和原型模式</strong></p><p><strong>5.动态原型模式</strong></p><p><strong>6.寄生构造函数模式</strong></p><p><strong>7.稳妥构造函数模式</strong></p><p>1.<strong>工厂模式</strong> 一种函数用函数来封装以特定接口创建对象的细节</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line"> <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line"> o.<span class="property">name</span> = name; </span><br><span class="line"> o.<span class="property">age</span> = age; </span><br><span class="line"> o.<span class="property">job</span> = job; </span><br><span class="line"> o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="keyword">return</span> o; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="title function_">createPerson</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="title function_">createPerson</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure><p>函数 createPerson()能够根据接受的参数来构建一个包含所有必要信息的 Person 对象。可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建 多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。随着 JavaScript 的发展，又一个新模式出现了。</p><p>2.<strong>构造函数模式</strong></p><p>构造函数可以用来创建特定类型的对象，像object 和Array这样的原生构造函数，可以自定义构造函数，从而定义对象的类型的属性和方法；还是上面的例子用构造函数重写如下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">job</span> = job; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125;; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样对象的类型就能够知道对象的类型</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(person1.<span class="property">constructor</span> == <span class="title class_">Person</span>); <span class="comment">//true </span></span><br><span class="line"><span class="title function_">alert</span>(person2.<span class="property">constructor</span> == <span class="title class_">Person</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>对象的 constructor 属性最初是用来标识对象类型的。但是，提到检测对象类型，还是 instanceof 操作符要更可靠一些。我们在这个例子中创建的所有对象既是 Object 的实例，同时也是 Person 的实例，这一点通过 instanceof 操作符可以得到验证。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">//true </span></span><br><span class="line"><span class="title function_">alert</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">//true </span></span><br><span class="line"><span class="title function_">alert</span>(person2 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">//true </span></span><br><span class="line"><span class="title function_">alert</span>(person2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式 胜过工厂模式的地方</p><p>3.<strong>原型模式</strong></p><p>我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象， 而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那 么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以 让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是 可以将这些信息直接添加到原型对象中，如下面的例子所示。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">//&quot;Nicholas&quot; </span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">//&quot;Nicholas&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">sayName</span> == person2.<span class="property">sayName</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>原型的内容在上一篇博客种已经说过；</p><p>4.<strong>组合使用构造函数模式和原型模式</strong></p><p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实 例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本， 但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参 数；可谓是集两种模式之长。下面的代码重写了前面的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">job</span> = job; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123; </span><br><span class="line"> constructor : <span class="title class_">Person</span>, </span><br><span class="line"> sayName : <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); </span><br><span class="line">person1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Van&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">friends</span>); <span class="comment">//&quot;Shelby,Count,Van&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(person2.<span class="property">friends</span>); <span class="comment">//&quot;Shelby,Count&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">friends</span> === person2.<span class="property">friends</span>); <span class="comment">//false </span></span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">sayName</span> === person2.<span class="property">sayName</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性 constructor 和方 法 sayName()则是在原型中定义的。而修改了 person1.friends（向其中添加一个新字符串），并不 会影响到 person2.friends，因为它们分别引用了不同的数组</p><p>5.<strong>动态原型模式</strong></p><p>可以通过 检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line"> <span class="comment">//属性</span></span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">job</span> = job; </span><br><span class="line"> <span class="comment">//方法</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span>.<span class="property">sayName</span> != <span class="string">&quot;function&quot;</span>)&#123; </span><br><span class="line"> <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125;; </span><br><span class="line"> </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line">friend.<span class="title function_">sayName</span>(); </span><br></pre></td></tr></table></figure><p><strong>使用动态原型模式时，不能使用对象字面量重写原型，如果 在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。</strong></p><p>6.<strong>寄生构造函数模式</strong></p><p>这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊 数组。由于不能直接修改 Array 构造函数，因此可以使用这个模式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SpecialArray</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="comment">//创建数组</span></span><br><span class="line"> <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="title class_">Array</span>(); </span><br><span class="line"> <span class="comment">//添加值</span></span><br><span class="line"> values.<span class="property">push</span>.<span class="title function_">apply</span>(values, <span class="variable language_">arguments</span>); </span><br><span class="line"> <span class="comment">//添加方法</span></span><br><span class="line"> values.<span class="property">toPipedString</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">join</span>(<span class="string">&quot;|&quot;</span>); </span><br><span class="line"> &#125;; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//返回数组</span></span><br><span class="line"> <span class="keyword">return</span> values; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="title class_">SpecialArray</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">toPipedString</span>()); <span class="comment">//&quot;red|blue|green&quot; </span></span><br></pre></td></tr></table></figure><p>关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属 性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此， 不能依赖 instanceof 操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情 况下，不要使用这种模式。</p><p>6.<strong>稳妥构造函数模式</strong></p><p>道格拉斯·克罗克福德（Douglas Crockford）发明了 JavaScript 中的稳妥对象（durable objects）这 个概念。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。稳妥对象最适合在 一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其他应用程序（如 Mashup 程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的 实例方法不引用 this；二是不使用 new 操作符调用构造函数。按照稳妥构造函数的要求，可以将前面 的 Person 构造函数重写如下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line"> <span class="comment">//创建要返回的对象</span></span><br><span class="line"> <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line"> <span class="comment">//可以在这里定义私有变量和函数</span></span><br><span class="line"> <span class="comment">//添加方法</span></span><br><span class="line"> o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="title function_">alert</span>(name); </span><br><span class="line"> &#125;; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//返回对象</span></span><br><span class="line"> <span class="keyword">return</span> o; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也 没有什么关系，因此 instanceof 操作符对这种对象也没有意义。</p><blockquote><p>《Javascript高级程序设计》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型链prototype和__proto__</title>
      <link href="/2022/03/19/%E5%8E%9F%E5%9E%8B%E9%93%BEprototype%E5%92%8C__proto__/"/>
      <url>/2022/03/19/%E5%8E%9F%E5%9E%8B%E9%93%BEprototype%E5%92%8C__proto__/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>所有的 JavaScript 对象都会从一个 prototype（原型对象）中继承属性和方法。</p><p>显示原型和隐式原型；构造函数的显示原型用来存放函数对象，而实例对象的隐式原型等同于构函数的显示原型。所有对象的原型最终都指向object对象，object是原型链的顶端；</p><p><img src="https://img-blog.csdnimg.cn/e4eb068bd2ff4832b6263231b504ec99.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rqQ5YiD,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p><p>function的构造函数也是function，隐式原型指向function的原型对象；</p><p>而function的隐式原型指向object对象的显示原型，object没有隐式原型。object就是最顶层的对象；</p><p>当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它的’_ _ proto_ _‘属性(也就是它的构造函数的’prototype’属性)中去寻找，如果他的构造函数的prototype中没有这个属性就会去object中去寻找。再找不到就没有了；</p><p>首先，fn的构造函数是Foo()。所以：<br>fn._ _ proto _ _=== Foo.prototype<br>又因为Foo.prototype是一个普通的对象，它的构造函数是Object，所以：<br>Foo.prototype._ _ proto _ _=== Object.prototype<br>通过上面的代码，我们知道这个toString()方法是在Object.prototype里面的，当调用这个对象的本身并不存在的方法时，它会一层一层地往上去找，一直到null为止。   </p><p><img src="https://img-blog.csdnimg.cn/cd57f2c5e51949c49e12a3fc957a9ec1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rqQ5YiD,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>暂时的理解，后续会改</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 prototype </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise解决回调函数嵌套</title>
      <link href="/2022/03/13/promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97/"/>
      <url>/2022/03/13/promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件，这就解决了，我上次写的ajax的异步造成的问题，还要在回调函数中去绑定事件，有了promise这些都不是事，有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p><p>promise对象代表一个异步操作，有三种状态pending(进行中)，fulfilled(已成功)，rejected(“已失败”)，异步操作的结果决定这个对象的状态，</p><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p><p>基本用法</p><p>创建一个promise对象，</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行了promise&quot;</span>)</span><br><span class="line">           <span class="title function_">reject</span>(<span class="string">&quot;执行成功返回的数据像接口数据啥的&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       ,<span class="number">1000</span>)</span><br><span class="line">     &#125;)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/f003286678cc48fd81dfb73761b53b1a.png"></p><p> 这我只是创建了一个对promise对象但是却执行了，Promise 新建后就会立即执行。</p><p>所以应该把promise对象放在函数了，比如单击事件函数，单机之后才会新建promise对象然后执行，</p><p>其中两个参数，resolve   reject是两个函数，是由js引擎提供的，不需要自己写</p><p>resolve函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定resolved状态和<code>Promise</code>状态的回调函数。</p><p>promise对象的then方法，可以将两个回调函数作为参数，第一个会回调函数就是当promise的状态为resolve的时候调用的并且可以接受传来的数据。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">       <span class="comment">//成功之后</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/e76bc85121e2457a96cb4dc58ba1de38.png"></p><p> 状态变为resolve之后就会执行then方法的第一个回调函数，并且把数据也传了过来，在进行操作就行了，类似于这样在Ajax中请求成功就把返回数据用resolve函数传递，就会执行then方法的第一个回调函数，在回调函数中也可以再return  promise对象，进行回调函数的执行，形成链式，如果不用promise，在Ajax的回调函数中写就会形成多层嵌套，代码一直往右延申，不利于观察，用promise链式，可以代码让代码看起来更有条理，</p><p>这就我现在的理解，可能有错误，后续会改</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript 前端 react.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AJAX相关问题的解决</title>
      <link href="/2022/03/06/AJAX%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
      <url>/2022/03/06/AJAX%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>AJAX是一默认是异步的程序，AJAX执行的时候是没有顺序性的，就在第一个接口还没有把返回的数据传入dom时，就已经执行其他代码了，如果在这完成之前去用js去获取用ajax加入dom的元素，是获取不到的，但是在一些小型的请求可通过把ajax中的async=flase，设置成同步，就能够在ajax完全执行完成之后，在进行之后的代码，就能够用js获取到动态添加的内容了。</p><p>但是这不是一个好方法，只能满足小型请求是不行的 ，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止，也可以在开启异步时，在ajax的回调函数中去对动态添加的元素进行获取；绑定事件。这是一个挺好用的方法，</p><p>        还有一个方法，这不是一个好方法，但是我觉得还挺有意思，在js中设置一个定时器，把对动态添加的内容执行的函数放到里面，这样无论什么时候ajax加载完成，定时器在反复的寻找需要绑定函数的内容，找到了，就绑定；（感觉有bug，可能和网速有关系。尽量不用）</p><p>        之后继续学习es6的规则；应用到代码中，再深入了解了解ajax，还有jq工具库。</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 ajax javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于git</title>
      <link href="/2022/02/27/%E5%85%B3%E4%BA%8Egit/"/>
      <url>/2022/02/27/%E5%85%B3%E4%BA%8Egit/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>git是一种版本控制器，git的安装非常简单，下一步就行了。</p><p>git的基本操作；</p><p>在需要记录版本的文件夹中用，git init创建本地库</p><p>首次使用需要配置一下个人的用户名和电子邮件地址，输入一下两行代码</p><p>$ git config --global user.name “用户名”</p><p>$git config --global user.email 邮箱</p><p>可以输入一下代码查看是否配置成功</p><p>$git config --list</p><p>git有三个部分，工作区，暂存区，本地库，也可以上传至远程库</p><p>git的基本操作；</p><p>git init 初始化操作</p><p>git add 添加文件到暂存区</p><p>git commit 将暂存区的内容添加到本地仓库中；</p><p>git status 查看仓库当前状态</p><p>git diff 比较暂存区和工作区的差异</p><p>git reset 版本号 回退版本；</p><p>git rm 删除工作区文件</p><p>git mv 移动或重命名工作区文件。</p><p>git log 查看历史提交记录</p><p>git blame&lt;file&gt;以列表形式查看指定文件的历史修改记录</p><p>git remote 远程仓库操作</p><p>git fetch 从远程库获取代码库</p><p>git pull 下载远程代码并合并</p><p>git push 上传远程代码并合并</p><p>其中git pull git fetch git cloned的区别</p><p>git pull相当于是从远程获取最新版本并merge（合并）到本地 git pull = git fetch + git merge</p><p><strong>git fetch</strong> 命令用于从远程获取代码库，该命令执行完后需要执行 git merge 远程分支到你所在的分支。</p><p>git clone 拷贝一个git仓库到本地，本地无需初始化仓库也能拷贝，这是完全拷贝，连历代记录都进行了拷贝，历代版本信息也有，</p><p>2.分支管理</p><p>git branch -v 可以查看分支</p><p>git branch 分支名      可以创建分支，</p><p>git checkout 分支名       可以切换分支</p><p>git merge 分支名      可以合并分支到当前分支；</p><p>git其实还可以用来保存游戏存档的历代版本，当打游戏材料消耗完了，这个时候只需要回退版本，就能恢复存档。</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习记录2</title>
      <link href="/2022/01/23/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/"/>
      <url>/2022/01/23/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>        做考核页面也有三四天了，进展很慢，前一部分的内容很细，有好多小地方需要处理；今天我做到了那个轮播图左边的功能栏的地方了，自我感觉这个地方是最不好做的，希望明天之前能够完成，后面的就好做了。这个地方中，当鼠标放上时，一整排图标上移并且弹出内容栏，肯定要用到动画，也能用JS来写，我尽量能用CSS就不用JS，虽然JS很好用，可以操作基本所有东西，但是还是尽量用基本的写，我的思路就是，先给图标开启定位，当鼠标放上时，让其上移，还有一个同步触发的事件，让该弹出的内容由高度为零变成预定高度，这个过程加一个过渡动画，内容区再用JS去写页面左右切换；现在只是这样想，希望能够实现。希望不要花费太多时间，</p><p>        还有7天就要过年了，希望能够在过年之前写好页面，好好过年，最近学习写页面总感觉时间过的很快，还没有写多少就一天过去了，希望能够提升效率，注意力集中，上午去写一些逻辑性的东西，晚上把文字内容填一填。规划好时间，加油，上班不摸鱼。希望和同学们一起进步，争取突破一下。成为肝帝！！</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 html 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回顾CSS内容</title>
      <link href="/2022/01/16/%E5%9B%9E%E9%A1%BECSS%E5%86%85%E5%AE%B9/"/>
      <url>/2022/01/16/%E5%9B%9E%E9%A1%BECSS%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><strong>目录</strong></p><p><a href="#1.%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90">1.弹性盒子</a></p><p><a href="#2.%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE">2.文本标签</a></p><p><a href="#3.%E5%AE%9A%E4%BD%8D">3.定位</a></p><hr><h2 id="1-弹性盒子"><a href="#1-弹性盒子" class="headerlink" title="1.弹性盒子"></a>1.弹性盒子</h2><p>flex</p><p>flex-direction 指定容器中弹性元素的排列方式；</p><p>主轴由flex的设置的方向决定；</p><p>flex-grow指定弹性元素伸展的系数默认值是零；</p><p>当父元素有多余的空间时子元素如何伸展，0就是不伸展，</p><p>要是把flex-grow写入子元素，则子元素按照flex-grow的比值被分配剩余空白部分</p><p>flex-shrink表示收缩系数。当父元素不足以容纳子元素时对子元素进行收缩</p><p>当值为零的时候就是不收缩，当外面的框小的时候内容会溢出</p><p>这时使用flex-wrap：wrap；多出的部分会沿着辅轴方向排列</p><p>flex-flow是简写属性</p><p>justify-content</p><p>如何分配空白区域</p><p>flex-start 元素沿着主轴起边排列</p><p>flex-end 元素沿着主轴终边排列</p><p>center 元素居中排列</p><p>sparce-between 空白均匀分布到元素间</p><p>spare-around 空白分布到元素两侧。</p><p>在纵向上align-item</p><p>中stretch属性把元素的长度设置为相同的值；</p><p>指的是行与行之间的高度</p><p>flex-start：元素不会拉伸，沿着辅轴起边方向对齐</p><p>flex-end：沿着辅轴终边对齐</p><p>flex-baseline：沿着基线对齐就是文字底边的基线。</p><p>在纵轴上分配空白空间</p><p>用align-conent：</p><p>和横着的一样。</p><p>设置弹性元素的属性</p><p>flex-basic:可以设置弹性元素的基础长度；</p><p>如果主轴是纵向的则设置的是高度；</p><h2 id="2-文本标签"><a href="#2-文本标签" class="headerlink" title="2.文本标签"></a>2.文本标签</h2><p>html格式化标签粗体表示重要性（内容的重要性）或者斜体表示着重点（语气上的强调）表示你要呈现的文章时重要的所以要突出显示 一个粗体，一个斜体</p><p>与是定义粗体或斜体文本与上面的那两个是不一样的</p><p>cite标签：网站中所有加书名号的内容都可以使用cite标签</p><p>《XXX》</p><p>短引用标签的内容浏览器会默认给他加上一个“”</p><p>blockquote长引用（块级引用不能放在中）</p><p>独占一行</p><p>sup标签用来表示一个上标；</p><p>sub标签用来表示一个下标；</p><p>del标签用来表示一个删除的内容画一个横线</p><p>ins表示插入一个内容插入的内容有下划线</p><p>pre标签时预格式标签保留了格式；</p><p>code专门用来表示代码的标签</p><h2 id="3-定位"><a href="#3-定位" class="headerlink" title="3.定位"></a>3.定位</h2><p>通过position属性</p><p>relative是相对定位</p><p>当开启元素相对定位时，而不设置偏移量。和没有设置一样</p><p>2：开启后可以通过，left right top bottom 四个属性设置元素的偏移量。</p><p>是相对与原来位置移动的。</p><p>3：相对定位的元素不会脱离文档流。原来的位置虽然是空的但还占位置。</p><p>4：相对定位会使元素提升一个层级。会覆盖其他元素。</p><p>通常偏移量使用两个就可以对一个元素进行定位。</p><p>相对定位，不会该改变元素的性质，块还是块，内联还是内联</p><p>绝对定位absolute</p><p>开启绝对定位后脱离文档流</p><p>开启绝对定位后</p><p>而且是相对于浏览器窗口定位的</p><p>3：绝对定位是相对于离他最近的的开启了定位的祖先元素定位的</p><p>（一般情况开启子元素的绝对定位，也会开启祖先元素的绝对定位。）</p><p>4：如果所有的祖先元素都未开启定位，则会相对于浏览器窗口定位。</p><p>5：绝对定位会使元素提升一个层级</p><p>6：定位会改变元素的性质</p><p>内联元素变成块元素，块元素的宽度和高度默认被内容撑开</p><p>固定定位fixed</p><p>position也是一种绝对定位</p><p>它的大部分特点都和绝对定位一样</p><p>不同的是：</p><p>固定定位永远会相对于浏览器窗口进行定位</p><p>固定定位会固定在浏览器窗口的某个位置，不会随滚顶条滚动</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 css 前端 html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近期学习随笔</title>
      <link href="/2021/12/29/%E8%BF%91%E6%9C%9F%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/"/>
      <url>/2021/12/29/%E8%BF%91%E6%9C%9F%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>前些天闭组了，虽然闭组了，但是我还是每天坚持来小组学习，开始认真学习专业课程，闭组第一天我早上睡到了九点多，睡了个懒觉，起来之后神清气爽，非常有精神，带上书包就去小组学习了，小组的人很少，没有了往日的热闹和紧张的氛围，但是在这的人还是非常认真的在学习，坐到这里才有学习的动力，在寝室老是想玩游戏，不能很好的学习效率很低，所以我每天还是来小组学习，养成一个好习惯，闭组这段时间我每天晚上都是十点回去，没有像往常一样十点四十回去，毕竟还是想放轻松一下，现在是大一觉得不应该那么卷，还是想轻松一点，适度学习，适度躺平。</p><p>  马上就要放假了，回家每天学习点JS，我觉得应该能够把那个一百多集的视频看完，并学会。希望小组的任务能够轻松一些，每天肝个几个小时就能完成的那种。我们家那边疫情比较严重，只能在家，任务应该都能完成。希望寒假不会延期开学，希望明年疫情消退，让我们大一的出去玩玩吧。寒假我也出不去，我们周口疫情挺严重的，家周围都封闭了，回去还要隔离七天，只有电脑陪我了。期末加油！</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端考核感想</title>
      <link href="/2021/12/13/%E5%89%8D%E7%AB%AF%E8%80%83%E6%A0%B8%E6%84%9F%E6%83%B3/"/>
      <url>/2021/12/13/%E5%89%8D%E7%AB%AF%E8%80%83%E6%A0%B8%E6%84%9F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>        这次前端考核时间很充裕但是我并没有好好利用做的时候有点莽，刚开始先写的整体框架内容填完之后，而且动画还有特效都做好了，才发现一缩小布局是乱的，虽然下边没有出现滚动条，但是我的内容全部都被压缩了，我的内容区的盒子宽度是按照百分比写的，而且使用的是绝对定位，没有响应式布局，直到了最后一天，我才进行改动把所有内容区的宽度改成了固定像素值，并且设置了媒体查询，缩小的页面进行布局。把本来变形的布局改了回来，当然这也不能改变大框架的弄错带来的问题，以后再写就明白怎么去写了，先想明白再去动手不然之后再去修改会很麻烦，总体来说前端做出来的效果事可以看到的，成就感比较强，自己脑海中所想的能够做出来，</p><p>        这一阶段结束之后就要分前后端学习了，两个方向都不容易，都挺好，所以现在我以我的兴趣为导向进行选择，我打算选择前端，我觉得前端我有学下去的动力，我想象力很好，我觉得对前端的学习有所帮助。这马上就要期末考试了，要注意课程的学习，不能挂科，尽量安排好自己的时间，小组学习和正常课程，都要弄好，</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 html asp.net </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高度塌陷问题的解决办法</title>
      <link href="/2021/12/05/%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2021/12/05/%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>在HTML文档中元素默认是在文档流中的，在文档流中块级元素会独占一行从上至下排列，而内联元素，所谓的行内元素，指的是只占自身大小的元素，不会占用一行</p><p>行内元素有：a b span img input select strong（强调的语气）<br>块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p </p><p><strong>首先什么是高度坍塌？</strong></p><p>在文档流中，父元素的高度默认是被子元素撑开的。</p><p>也就是子元素多高，父元素多高。</p><p>但是当子元素设置浮动时，子元素会脱离文档流</p><p>此时将会导致子元素无法撑起父元素的高度造成父元素塌陷，则父元素下的所有元素都会上移这样导致页面布局混乱。</p><p>解决办法有好几种，但是某些办法有局限性。在不同浏览器中也会出现不兼容的问题</p><p>**一.**把浮动元素所在盒子的高度定死，设置一个不可变的高度。这样容易出现内容溢出的问题。造成布局混乱</p><p><strong>二</strong>、开启BFC属性<br>根据W3C的标准，在我们的页面中元素都有一个隐含的属性叫做“Block Formatting Context”，简称BFC，该属性可以设置打开或者关闭，默认是关闭的。当我们开启元素的BFC以后，元素会具有以下特性：<br>1.父元素的垂直外边距不会和子元素重叠<br>2.开启BFC的元素不会被浮动元素覆盖<br>3.开启BFC的元素可以包含浮动的子元素<br>如何开启元素的BFC：<br>1.设置元素的浮动： 这种方式开启虽然可以撑开父元素，但是会导致父元素的宽度丢失，而且这种方式也会导致下边的元素上移，不能解决问题。<br>2.设置元素的绝对定位  </p><p>3.将我们元素的overflow设置为hidden是副作用最小的开启BFC的方式。  </p><p><strong>三</strong>、可以直接在高度塌陷的父元素的最后，添加一个空白的div<br>由于添加的div并没有浮动，所以他是可以撑开父元素的高度的，再对其进行清除浮动，可以通过空白的div来撑开父元素的高度，基本没有副作用。使用这种方式，虽然可以解决问题，但是会在页面中添加多余的结构  </p><p><strong>四、</strong>通过after伪类来选中父元素的后面<br>可以通过after伪类向元素的的最后添加一个空白的块元素，然后对其清除浮动，这样做和添加div的原理一样，可以达到相同的效果，而且不会再页面中添加多余的div，最为推荐使用的方式，几乎没有副作用</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 css3 html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔记录学习</title>
      <link href="/2021/11/27/%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/11/27/%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>  今天早上没想到竟然又睡过了，我下次一定多订几个闹钟，以免过了时间。近期在学习前端知识，感觉前端的内容还挺有意思的，做出来的东西都时可见的。可以按照自己的想要的设计去设计网页，我觉得前端知识比较零散，各种各样的标签需要了解。</p><p>  学习前端有四天了，感觉没有算法要求，可能后期就有更加深的内容了吧，我看视频上介绍的前端学习的javaScript也能编写类似煜后端的内容，编写数据库；前端处于一个中间位置，既要与页面设计师协调好，也要与后端工程师协调好，所以前端工程师两边都要了解一些知识，需要学习的东西更多，</p><p>  在小组的学习感觉很好，休息时间感觉还挺多，比高中好多了高中是被迫学习自己不感兴趣的东西，整天埋头在哪里学习，十分无聊，唯一感兴趣的计算机，三年就上了3节课！！。真的是麻了，在大学刚开始的时候，感觉十分的轻松没有什么课，自己能在寝室待上一整天和心目中的大学生活不一样，大学生活应该是很丰富的，很有趣的。能够学习自己感兴趣的东西，希望在以后的时间里能够学习学习到一门手艺，编程手艺。信手拈来，想写啥就写啥。ps我也十分想学我想p我的室友哈哈。</p><h1 id="皇子yyds"><a href="#皇子yyds" class="headerlink" title="皇子yyds"></a><img src="https://img-blog.csdnimg.cn/04aafe67e48e43938f0de042d6c74295.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rqQ5YiD,size_14,color_FFFFFF,t_70,g_se,x_16"><strong>皇子yyds</strong></h1>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
