<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>错误日志1</title>
      <link href="/2023/02/13/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"/>
      <url>/2023/02/13/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="vue2中axios请求遇到的问题"><a href="#vue2中axios请求遇到的问题" class="headerlink" title="vue2中axios请求遇到的问题"></a>vue2中axios请求遇到的问题</h2><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20230213091759.png"><br>当请求是报出如图上错误时，有两种情况</p><ol><li>就是错误的把axios当作插件在全局注册</li><li>就是我范的错误，<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20230213170505.png"><br><code>把axios的配置项写错了也会造成这样的结果</code></li></ol><p>虽然是个小问题，但是耽误了我几个小时，写代码一定要规范起来</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 javascript node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本周学习笔记</title>
      <link href="/2023/02/13/%E5%81%87%E6%9C%9F%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2023/02/13/%E5%81%87%E6%9C%9F%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="假期总结"><a href="#假期总结" class="headerlink" title="假期总结"></a>假期总结</h2><ol><li>复习了Vue2的内容，然后做了一个半的项目，总得来说Vue2确实不错，相比Vue3还是差点意思，Vue3性能几乎翻倍，各种优化的非常好，但是Vue3毕竟出的时间不久，还是先从Vue2开始学习，弄懂vue2之后再进行vue3的学习，vue3在用法上与2做了少许改变， 学习周期短，</li><li>完成了小组招新，我是第九组，怎么说呢，真希望他们坚持久一点，小组真的是一个学习的好地方，机会只有一次，大一的学习热情非常浓厚，我应该向他们学习，我现在大二了，激情有点褪去了，加油，自己感兴趣的东西，努力不留遗憾</li></ol><h2 id="下阶段学习计划"><a href="#下阶段学习计划" class="headerlink" title="下阶段学习计划"></a>下阶段学习计划</h2><ol><li>还是以项目为主，多实践，然后使用vue3做点项目，提高自己的学习热情，加油</li></ol><h2 id="反思与总结，"><a href="#反思与总结，" class="headerlink" title="反思与总结，"></a>反思与总结，</h2><p>   多抓紧时间，</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 javascript node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git命令</title>
      <link href="/2023/02/05/git%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/02/05/git%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="导航-—-跳到之前的分支"><a href="#导航-—-跳到之前的分支" class="headerlink" title="导航 — 跳到之前的分支"></a>导航 — 跳到之前的分支</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git checkout -</span><br></pre></td></tr></table></figure><h2 id="查看历史"><a href="#查看历史" class="headerlink" title="查看历史"></a>查看历史</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 每个提交在一行内显示</span><br><span class="line">git log --oneline</span><br><span class="line"></span><br><span class="line"># 在所有提交日志中搜索包含「homepage」的提交</span><br><span class="line">git log --all --grep=<span class="string">&#x27;homepage&#x27;</span></span><br><span class="line"></span><br><span class="line"># 获取某人的提交日志</span><br><span class="line">git log --author=<span class="string">&quot;Maxence&quot;</span></span><br></pre></td></tr></table></figure><h3 id="回退操作"><a href="#回退操作" class="headerlink" title="回退操作"></a>回退操作</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 获取所有操作历史</span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line"># 重置到相应提交</span><br><span class="line">git reset <span class="variable constant_">HEAD</span>@&#123;<span class="number">4</span>&#125;</span><br><span class="line"># ……或者……</span><br><span class="line">git reset --hard &lt;提交的哈希值&gt;</span><br></pre></td></tr></table></figure><h3 id="清理仓库"><a href="#清理仓库" class="headerlink" title="清理仓库"></a>清理仓库</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git checkout master</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure><h3 id="查看我的分支与master的不同"><a href="#查看我的分支与master的不同" class="headerlink" title="查看我的分支与master的不同"></a>查看我的分支与master的不同</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git diff master..<span class="property">my</span>-branch</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写干净的JavaScript</title>
      <link href="/2023/01/16/%E7%BC%96%E5%86%99%E5%B9%B2%E5%87%80JavaScript/"/>
      <url>/2023/01/16/%E7%BC%96%E5%86%99%E5%B9%B2%E5%87%80JavaScript/</url>
      
        <content type="html"><![CDATA[<p>我们应该编写不言自明、易于理解、易于修改或易于扩展新功能的代码。因为代码常常需要被阅读，这就是为什么如此强调干净代码的原因。</p><p>我们的源代码可读性越强，则：</p><p>越容易维护<br>新开发人员理解代码所需的时间越少<br>越容易发现哪些代码可以重用<br>在这篇文章中，我将分享一些通用的干净编码原则以及一些特定于JavaScript的干净编码实践。</p><ol><li>命名<br>不要把命名变成猜谜游戏。变量和函数的名称最好能够揭示最初创建的意图。<br>如此一来，即使有新的开发人员加入团队，也不至于需要像看天书一样艰难地理解代码。<br>Bad 👎<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">30</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (y - x &gt;<span class="number">1990</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>Good 👍<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> userAge = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentYear = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (userAge &gt; <span class="number">30</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (currentYear - userAge &gt;<span class="number">1990</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>另外，不要在变量名或函数名中添加多余的不必要的字母。<br>Bad 👎</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nameValue;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">theProduct</span>(<span class="params"></span>);</span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">product</span>(<span class="params"></span>);</span><br></pre></td></tr></table></figure><ol><li>条件句<br>避免否定条件语句。否定语句通常比肯定语句更难理解。</li></ol><p>Bad 👎</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title function_">userExist</span>(user)) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">userExist</span>(user)) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>函数应该专注做单一一件事<br>函数的平均行数不应超过30行（不包括空格和注释）。函数越小，则越容易理解和重构。你可以用函数修改或查询某些内容，但不能同时修改或查询。</p></li><li><p>使用默认参数<br>使用默认参数而不是短路或条件语句。</p></li></ol><p>默认参数通常比短路更干净。请记住，在你使用默认参数的时候，函数将只为未定义的参数提供默认值。其他虚假值，例如 ‘’、””、false、null、0和NaN，不会被默认值替换。</p><p>Bad 👎</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getUserData</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> userName = userName || <span class="string">&quot;Patrick Collision&quot;</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getUserData</span>(<span class="params">name = <span class="string">&quot;Patrick Collision&quot;</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>单级抽象（SLA）<br>在编写函数时，如果你有多个抽象级别，那么函数通常会做不止一件事情。将一个大的函数分成多个函数会使其更具可重用性，并且测试起来更容易。</li></ol><p>Bad 👎</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkSomething</span>(<span class="params">statement</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">REGEXES</span> = [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> statements = statement.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> tokens = [];</span><br><span class="line">  <span class="variable constant_">REGEXES</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">REGEX</span> =&gt;</span> &#123;</span><br><span class="line">    statements.<span class="title function_">forEach</span>(<span class="function"><span class="params">statement</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> names= [];</span><br><span class="line">  tokens.<span class="title function_">forEach</span>(<span class="function"><span class="params">token</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// lex...</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  names.<span class="title function_">forEach</span>(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// parse...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkSomething</span>(<span class="params">statement</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> tokens = <span class="title function_">tokenize</span>(statement);</span><br><span class="line">  <span class="keyword">const</span> syntaxTree = <span class="title function_">parse</span>(tokens);</span><br><span class="line">  syntaxTree.<span class="title function_">forEach</span>(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// parse...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tokenize</span>(<span class="params">code</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">REGEXES</span> = [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> statements = code.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> tokens = [];</span><br><span class="line">  <span class="variable constant_">REGEXES</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">REGEX</span> =&gt;</span> &#123;</span><br><span class="line">    statements.<span class="title function_">forEach</span>(<span class="function"><span class="params">statement</span> =&gt;</span> &#123;</span><br><span class="line">      tokens.<span class="title function_">push</span>(<span class="comment">/* ... */</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">parse</span>(<span class="params">tokens</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> syntaxTree = [];</span><br><span class="line">  tokens.<span class="title function_">forEach</span>(<span class="function"><span class="params">token</span> =&gt;</span> &#123;</span><br><span class="line">    syntaxTree.<span class="title function_">push</span>(<span class="comment">/* ... */</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> syntaxTree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>不要忽略被捕获的异常<br>对捕获的异常错误不采取任何措施，即意味着不修复特定的错误也不对其做出反应。</li></ol><p>将错误记录到控制台(console.log)并没有好多少，因为记录经常会在控制台的其他内容中丢失。</p><p>如果你在try/catch中包装了哪怕一点点代码，也意味着你认为那里可能会发生错误，因此你应该对何时发生错误有一个计划。</p><p>Bad 👎</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">functionThatMightThrow</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">functionThatMightThrow</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="title function_">notifyUserOfError</span>(error);   </span><br><span class="line">  <span class="title function_">reportErrorToService</span>(error);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>尽量减少注释<br>仅注释具有业务逻辑复杂性的代码部分。</li></ol><p>注释不是必需的。好的代码大多数可以自我说明。</p><p>Bad 👎</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hashing</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// The hash</span></span><br><span class="line">  <span class="keyword">let</span> hash = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Length of string</span></span><br><span class="line">  <span class="keyword">const</span> length = data.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Loop through every character in data</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">// Get character code.</span></span><br><span class="line">    <span class="keyword">const</span> char = data.<span class="title function_">charCodeAt</span>(i);</span><br><span class="line">    <span class="comment">// Make the hash</span></span><br><span class="line">    hash = (hash &lt;&lt; <span class="number">5</span>) - hash + char;</span><br><span class="line">    <span class="comment">// Convert to 32-bit integer</span></span><br><span class="line">    hash &amp;= hash;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hashing</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> hash = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> length = data.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> char = data.<span class="title function_">charCodeAt</span>(i);</span><br><span class="line">    hash = (hash &lt;&lt; <span class="number">5</span>) - hash + char;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert to 32-bit integer</span></span><br><span class="line">    hash &amp;= hash;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>“多余的注释就是谎言和错误信息的垃圾桶。” ——Robert C. Martin</code><br>7. 移除注释掉的代码<br>不要在代码库中留下注释掉的代码，版本控制的存在是有原因的。将旧代码留在历史记录中。如果你需要的话，再从git历史记录中获取。</p><p>Bad 👎</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">doSomething</span>();</span><br><span class="line"><span class="comment">// doOtherStuff();</span></span><br><span class="line"><span class="comment">// doSomeMoreStuff();</span></span><br><span class="line"><span class="comment">// doSoMuchStuff();</span></span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">doSomething</span>();</span><br></pre></td></tr></table></figure><ol start="8"><li>只导入你需要的<br>ES6引入了解构。它可以将数组中的值或对象中的属性解包为不同的变量。你可以将其用于任何类型的对象或模块。</li></ol><p>例如，如果你只需要另一个模块中的add()和subtract()函数：<br>Bad 👎</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> calculate = <span class="built_in">require</span>(<span class="string">&#x27;./calculations&#x27;</span>)</span><br><span class="line"></span><br><span class="line">calculate.<span class="title function_">add</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line">calculate.<span class="title function_">subtract</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; add, subtract &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./calculations&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line"><span class="title function_">subtract</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>只导入需要在文件中使用的函数而不是整个模块，然后从中访问特定函数是有意义的。<br>9. 保持函数参数不超过3个（理想情况下）<br>限制函数参数的数量非常重要，因为这样可以更轻松地测试函数。参数超过3个会导致需要测试大量不同的情况。</p><p>1-3个参数是最理想的情况，正常情况下，参数数量应避免任何超出此范围。</p><p>通常，如果你有三个以上的参数，那么说明函数要做的事情太多了，违反SRP（单一职责原则）。<br>10. 使用数组展开来复制数组<br>Bad 👎</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> len = items.<span class="property">length</span>;</span><br><span class="line"><span class="keyword">const</span> itemsCopy = [];</span><br><span class="line"><span class="keyword">let</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i += <span class="number">1</span>) &#123;</span><br><span class="line">  itemsCopy[i] = items[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> itemsCopy = [...items];</span><br></pre></td></tr></table></figure><ol start="11"><li>写线性代码<br>嵌套的代码很难理解。所以我们应该尽可能地编写线性代码，这样的代码简单、干净、易于阅读和维护，使开发人员的工作更轻松。</li></ol><p>例如，在回调上使用promise可以大大提高可读性。<br>12. 使用ESLint和Prettier<br>始终使用ESLint和Prettier来强制跨团队和开发人员使用通用的编码风格。</p><p>还可以尝试使用JavaScript的最新功能来编写代码，例如解构、展开运算符、异步等待、模板字面量、可选链等等。<br>13. 适当使用括号<br>使用运算符时，请将它们括在括号中。唯一的例外是标准算术运算符：+、- 和 *<em>，因为它们的优先级被广泛理解。强烈建议将 /、</em> 和 % 括在括号中，因为当它们一起使用时，其优先级可能会引起困惑。</p><p>这不但提高了可读性，而且阐明了开发人员的意图。</p><p>Bad 👎</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = a &amp;&amp; b &lt; <span class="number">0</span> || c &gt; <span class="number">0</span> || d + <span class="number">1</span> === <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a || b &amp;&amp; c) &#123;</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = (a &amp;&amp; b &lt; <span class="number">0</span>) || c &gt; <span class="number">0</span> || (d + <span class="number">1</span> === <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a || (b &amp;&amp; c)) &#123;</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>14.早早地从函数中返回<br>为避免if语句的深层嵌套，始终尽可能早地返回函数的值。</p><p>Bad 👎</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPercentage</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (val &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; <span class="number">100</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good 👍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPercentage</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (val &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个特殊的例子甚至可以进一步改进：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPercentage</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> isInRange = (val &gt;= <span class="number">0</span> &amp;&amp; val &lt;= <span class="number">100</span>);</span><br><span class="line">  <span class="keyword">return</span> isInRange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，同样的事情也可以应用于循环。</p><p>大的循环肯定会消耗大量时间。这就是为什么你应该尽可能早地跳出循环。</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域问题</title>
      <link href="/2022/12/11/CORS/"/>
      <url>/2022/12/11/CORS/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h3><p>浏览器有一个重要的安全策略，称之为[同源策略]<br>其中，源=协议+主机+端口源=协议+主机+端口源=协议+主机+端口，两个源相同，称之为同源，两个源不同，称之为跨源或跨域。</p><p>比如：<br>|  源 1   | 源 2  | 是否同源 |<br>|  —-  | —-  |—-|<br>| <a href="http://www.baidu.com/">www.baidu.com</a>  | <a href="http://www.baidu.com/news">www.baidu.com/news</a> | 是  |<br>| <a href="http://www.baidu.com/">http://www.baidu.com</a>  | <a href="https://www.baidu.com/">https://www.baidu.com</a> | 否   |<br>| <a href="http://localhost:5000/">http://localhost:5000</a>  | <a href="http://localhost:7000/">http://localhost:7000</a> | 否   |<br>| <a href="http://localhost:5000/">http://localhost:5000</a>  | <a href="http://127.0.0.1:5000/">http://127.0.0.1:5000</a> | 否   |<br>| <a href="http://www.baidu.com/">www.baidu.com</a>  | baidu.com | 否   |<br>同源策略是指，若页面的源和页面运行过程中加载的源不一致时，出于安全考虑，浏览器会对跨域的资源访问进行一些限制<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221211093517.jpg"><br>同源策略对 ajax 的跨域限制的最为_凶狠_，默认情况下，它不允许 ajax 访问跨域资源<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221211093619.jpg"><br>所以，我们通常所说的跨域问题，就是同源策略对 ajax 产生的影响<br>有多种方式解决跨域问题，常见的有：</p><ul><li>代理，常用</li><li>CORS，常用</li><li>JSONP<br>无论使用哪一种方式，都是要让浏览器知道，我这次跨域请求的是自己人，就不要拦截了。<h3 id="跨域解决办法1-代理"><a href="#跨域解决办法1-代理" class="headerlink" title="跨域解决办法1-代理"></a>跨域解决办法1-代理</h3>对于前端开发而言，大部分的跨域问题，都是通过代理解决的</li></ul><p>代理适用的场景是：生产环境不发生跨域，但开发环境发生跨域</p><p>因此，只需要在开发环境使用代理解决跨域即可，这种代理又称之为开发代理<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221211093737.jpg"></p><p>在实际开发中，只需要对开发服务器稍加配置即可完成</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue 的开发服务器代理配置</span></span><br><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123; <span class="comment">// 配置开发服务器</span></span><br><span class="line">    <span class="attr">proxy</span>: &#123; <span class="comment">// 配置代理</span></span><br><span class="line">      <span class="string">&quot;/api&quot;</span>: &#123; <span class="comment">// 若请求路径以 /api 开头</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&quot;http://dev.taobao.com&quot;</span>, <span class="comment">// 将其转发到 http://dev.taobao.com</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解决跨域问题方法2-JSONP"><a href="#解决跨域问题方法2-JSONP" class="headerlink" title="解决跨域问题方法2-JSONP"></a>解决跨域问题方法2-JSONP</h3><p>在CORS出现之前，人们想了一种奇妙的办法来实现跨域，这就是JSONP。<br>要实现JSONP，需要浏览器和服务器来一个天衣无缝的绝妙配合。<br>JSONP的做法是：当需要跨域请求时，不使用AJAX，转而生成一个script元素去请求服务器，由于浏览器并不阻止script元素的请求，这样请求可以到达服务器。服务器拿到请求后，响应一段JS代码，这段代码实际上是一个函数调用，调用的是客户端预先生成好的函数，并把浏览器需要的数据作为参数传递到函数中，从而间接的把数据传递给客户端</p><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221211094003.jpg"></p><h3 id="跨域解决方法3-CORS"><a href="#跨域解决方法3-CORS" class="headerlink" title="跨域解决方法3-CORS"></a>跨域解决方法3-CORS</h3><p>CORS是基于http1.1的一种跨域解决方案，它的全称是Cross-Origin Resource Sharing，跨域资源共享。<br>它的总体思路是：如果浏览器要跨域访问服务器的资源，需要获得服务器的允许<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221211094034.jpg"><br>而要知道，一个请求可以附带很多信息，从而会对服务器造成不同程度的影响</p><p>比如有的请求只是获取一些新闻，有的请求会改动服务器的数据</p><p>针对不同的请求，CORS 规定了三种不同的交互模式，分别是：</p><ul><li>简单请求</li><li>需要预检的请求</li><li>附带身份凭证的请求<br>这三种模式从上到下层层递进，请求可以做的事越来越多，要求也越来越严格。<br>下面分别说明三种请求模式的具体规范。</li></ul><p><code>简单请求</code><br>当浏览器端运行了一段 ajax 代码（无论是使用 XMLHttpRequest 还是 fetch api），浏览器会首先判断它属于哪一种请求模式</p><h3 id="简单请求的判定"><a href="#简单请求的判定" class="headerlink" title="简单请求的判定"></a>简单请求的判定</h3><p>当请求同时满足以下条件时，浏览器会认为它是一个简单请求：</p><ol><li>求方法属于下面的一种：</li></ol><ul><li>get</li><li>post</li><li>head</li></ul><ol start="2"><li>请求头仅包含安全的字段，常见的安全字段如下：</li></ol><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type</li><li>DPR</li><li>DownLink</li><li>Save-Data</li><li>Viewport-Width</li><li>Width</li></ul><ol start="3"><li>请求头如果包含Content-Type，仅限下面的值之一：</li></ol><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded<br><code>如果以上三个条件同时满足，浏览器判定为简单请求。</code><h3 id="简单请求的交互规范"><a href="#简单请求的交互规范" class="headerlink" title="简单请求的交互规范"></a>简单请求的交互规范</h3>当浏览器判定某个ajax 跨域请求是简单请求时，会发生以下的事情</li></ul><ol><li>求头中会自动添加Origin字段<br>比如，在页面<code>http://my.com/index.html</code>中有以下代码造成了跨域<br>fetch(‘<a href="http://crossdomain.com/api/news&#39;">http://crossdomain.com/api/news&#39;</a>);<br>请求发出后，请求头会是下面的格式：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /api/news/ <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: crossdomain.<span class="property">com</span></span><br><span class="line"><span class="title class_">Connection</span>: keep-alive</span><br><span class="line">...</span><br><span class="line"><span class="title class_">Referer</span>: <span class="attr">http</span>:<span class="comment">//my.com/index.html</span></span><br><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//my.com</span></span><br></pre></td></tr></table></figure>看到最后一行没，Origin字段会告诉服务器，是哪个源地址在跨域请求</li><li>服务器响应头中应包含Access-Control-Allow-Origin<br>当服务器收到请求后，如果允许该请求跨域访问，需要在响应头中添加Access-Control-Allow-Origin字段<br>该字段的值可以是：</li></ol><ul><li>*：表示我很开放，什么人我都允许访问</li><li>具体的源：比如<a href="http://my.com,表示我就允许你访问/">http://my.com，表示我就允许你访问</a><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实际上，这两个值对于客户端http://my.com而言，都一样，因为客户端才不会管其他源服务器允不允许，就关心自己是否被允许</span><br><span class="line"></span><br><span class="line">当然，服务器也可以维护一个可被允许的源列表，如果请求的Origin命中该列表，才响应*或具体的源</span><br><span class="line"></span><br><span class="line">为了避免后续的麻烦，强烈推荐响应具体的源</span><br></pre></td></tr></table></figure>假设服务器做出了以下的响应：<br>``HTTP/1.1 200 OK<br>Date: Tue, 21 Apr 2020 08:03:35 GMT<br>…<br>Access-Control-Allow-Origin: <a href="http://my.com/">http://my.com</a><br>…</li></ul><p>消息体中的数据<br><code>当浏览器看到服务器允许自己访问后，高兴的像一个两百斤的孩子，于是，它就把响应顺利的交给 js，以完成后续的操作 下图简述了整个交互过程 ![](https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/微信图片_20221211094943.jpg)</code>简单的请求对服务器的威胁不大，所以允许使用上述的简单交互即可完成。``<br>但是，如果浏览器不认为这是一种简单请求，就会按照下面的流程进行：</p><ul><li>浏览器发送预检请求，询问服务器是否允许</li><li>服务器允许</li><li>浏览器发送真实请求</li><li>服务器完成真实的响应<br>比如，在页面<code>http://my.com/index.html</code>中有以下代码造成了跨域<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://crossdomain.com/api/user&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="comment">// post 请求</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;袁小进&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;), <span class="comment">// 设置请求体</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>浏览器发现它不是一个简单请求，则会按照下面的流程与服务器交互</p><ol><li><strong>浏览器发送预检请求，询问服务器是否允许</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPTIONS /api/user HTTP/1.1</span><br><span class="line">Host: crossdomain.com</span><br><span class="line">...</span><br><span class="line">Origin: http://my.com</span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: a, b, content-type</span><br></pre></td></tr></table></figure><p>可以看出，这并非我们想要发出的真实请求，请求中不包含我们的请求头，也没有消息体。</p><p>这是一个预检请求，它的目的是询问服务器，是否允许后续的真实请求。</p><p>预检请求没有请求体，它包含了后续真实请求要做的事情<br>预检请求有以下特征：</p><ul><li>请求方法为OPTIONS</li><li>没有请求体</li><li>请求头中包含<ul><li>请求方法为OPTIONS<br>没有请求体<br>请求头中包含</li><li>Access-Control-Request-Method：后续的真实请求将使用的请求方法</li><li>Access-Control-Request-Headers：后续的真实请求会改动的请求头</li></ul></li></ul><ol start="2"><li>服务器允许<br>服务器收到预检请求后，可以检查预检请求中包含的信息，如果允许这样的请求，需要响应下面的消息格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 21 Apr 2020 08:03:35 GMT</span><br><span class="line">...</span><br><span class="line">Access-Control-Allow-Origin: http://my.com</span><br><span class="line">Access-Control-Allow-Methods: POST</span><br><span class="line">Access-Control-Allow-Headers: a, b, content-type</span><br><span class="line">Access-Control-Max-Age: 86400</span><br><span class="line">...</span><br></pre></td></tr></table></figure>对于预检请求，不需要响应任何的消息体，只需要在响应头中添加：</li></ol><ul><li>Access-Control-Allow-Origin：和简单请求一样，表示允许的源</li><li>Access-Control-Allow-Methods：表示允许的后续真实的请求方法</li><li>Access-Control-Allow-Headers：表示允许改动的请求头</li><li>Access-Control-Max-Age：告诉浏览器，多少秒内，对于同样的请求源、方法、头，都不需要再发送预检请求了</li></ul><ol start="3"><li>浏览器发送真实请求<br>预检被服务器允许后，浏览器就会发送真实请求了，上面的代码会发生下面的请求数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /api/user HTTP/1.1</span><br><span class="line">Host: crossdomain.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">...</span><br><span class="line">Referer: http://my.com/index.html</span><br><span class="line">Origin: http://my.com</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;: &quot;xiaoming&quot;, &quot;age&quot;: 18 &#125;</span><br></pre></td></tr></table></figure></li><li>服务器响应真实请求<figure class="highlight plaintext"><figcaption><span>200 OK</span></figcaption><table><tr><td class="code"><pre><span class="line">Date: Tue, 21 Apr 2020 08:03:35 GMT</span><br><span class="line">...</span><br><span class="line">Access-Control-Allow-Origin: http://my.com</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">添加用户成功</span><br></pre></td></tr></table></figure></li></ol><p>可以看出，当完成预检之后，后续的处理与简单请求相同<br>下图简述了整个交互过程<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221211095559.jpg"></p><p><code>一个额外的补充</code><br>在跨域访问时，JS 只能拿到一些最基本的响应头，如：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。<br><code>Access-Control-Expose-Headers</code>头让服务器把允许浏览器访问的头放入白名单，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access-Control-Expose-Headers: authorization, a, b</span><br></pre></td></tr></table></figure><h3 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h3><p>本周主要还是以考试复习为重，学习了CORS关于跨域的产生和解决办法</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七个JavaScript的简写方法</title>
      <link href="/2022/12/03/%E4%B8%83%E4%B8%AAJavascript%E7%9A%84%E7%AE%80%E5%86%99%E6%96%B9%E6%B3%95/"/>
      <url>/2022/12/03/%E4%B8%83%E4%B8%AAJavascript%E7%9A%84%E7%AE%80%E5%86%99%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="多字符串检查"><a href="#多字符串检查" class="headerlink" title="多字符串检查"></a>多字符串检查</h3><p>通常，如果我们需要检查字符串是否等于多个值中的一个，往往很快就会觉得疲惫不堪，性欲的是，JavaScript有一个内置方法帮助你解决这个问题</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isVowel</span> = (<span class="params">letter</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    letter === <span class="string">&quot;a&quot;</span> ||</span><br><span class="line">    letter === <span class="string">&quot;e&quot;</span> ||</span><br><span class="line">    letter === <span class="string">&quot;i&quot;</span> ||</span><br><span class="line">    letter === <span class="string">&quot;o&quot;</span> ||</span><br><span class="line">    letter === <span class="string">&quot;u&quot;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写方法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isVowel</span> = (<span class="params">letter</span>) =&gt;</span><br><span class="line">  [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;u&quot;</span>].<span class="title function_">includes</span>(letter);</span><br></pre></td></tr></table></figure><h3 id="For-of和For-in循环"><a href="#For-of和For-in循环" class="headerlink" title="For-of和For-in循环"></a>For-of和For-in循环</h3><p>For-of和For-in循环是迭代array或object的好方法，因为无需手动跟踪object键的索引。</p><ol><li>For-of<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> element = arr[i];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写方法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>For-in<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> key = keys[i];</span><br><span class="line">  <span class="keyword">const</span> value = obj[key];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写方法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="keyword">const</span> value = obj[key];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Falsey（假值）检查<br>如果要检查变量是null、undefined、0、false、NaN还是空string，可以使用逻辑非 (!)运算符一次检查所有变量，而无需编写多个条件。这使得检查变量是否包含有效数据变得相对容易多了。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isFalsey</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    value === <span class="literal">null</span> ||</span><br><span class="line">    value === <span class="literal">undefined</span> ||</span><br><span class="line">    value === <span class="number">0</span> ||</span><br><span class="line">    value === <span class="literal">false</span> ||</span><br><span class="line">    value === <span class="title class_">NaN</span> ||</span><br><span class="line">    value === <span class="string">&quot;&quot;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写方法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isFalsey</span> = (<span class="params">value</span>) =&gt; !value;</span><br></pre></td></tr></table></figure><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3>作为JavaScript开发人员，你一定遇到过三元运算符。这是编写简洁if-else语句的好方法。但是，也可用来编写简洁的代码，甚至将它们链接起来来检查多个条件。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 普通写法</span><br><span class="line">let info;</span><br><span class="line">if (value &lt; minValue) &#123;</span><br><span class="line">  info = &quot;Value is too small&quot;;</span><br><span class="line">&#125; else if (value &gt; maxValue) &#123;</span><br><span class="line">  info = &quot;Value is too large&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  info = &quot;Value is in range&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 简写方法</span><br><span class="line">const info =</span><br><span class="line">  value &lt; minValue</span><br><span class="line">    ? &quot;Value is too small&quot;</span><br><span class="line">    : value &gt; maxValue ? &quot;Value is too large&quot; : &quot;Value is in range&quot;;</span><br></pre></td></tr></table></figure><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3>在三元运算符的帮助下，你还可以根据条件确定要调用哪个函数。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="title function_">f1</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="title function_">f2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写方法</span></span><br><span class="line">(condition ? f1 : f2)();</span><br></pre></td></tr></table></figure><h3 id="Switch简写"><a href="#Switch简写" class="headerlink" title="Switch简写"></a>Switch简写</h3>通常我们可以使用以键作为switch条件并将值作为返回值的对象来优化长switch语句。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dayNumber = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getDay</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="keyword">let</span> day;</span><br><span class="line"><span class="keyword">switch</span> (dayNumber) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    day = <span class="string">&quot;Sunday&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    day = <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    day = <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    day = <span class="string">&quot;Wednesday&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    day = <span class="string">&quot;Thursday&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    day = <span class="string">&quot;Friday&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    day = <span class="string">&quot;Saturday&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写方法</span></span><br><span class="line"><span class="keyword">const</span> days = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;Sunday&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;Monday&quot;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&quot;Tuesday&quot;</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">  <span class="number">4</span>: <span class="string">&quot;Thursday&quot;</span>,</span><br><span class="line">  <span class="number">5</span>: <span class="string">&quot;Friday&quot;</span>,</span><br><span class="line">  <span class="number">6</span>: <span class="string">&quot;Saturday&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> day = days[dayNumber];</span><br></pre></td></tr></table></figure><h3 id="回退值"><a href="#回退值" class="headerlink" title="回退值"></a>回退值</h3>||运算符可以为变量设置回退值。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="keyword">let</span> name;</span><br><span class="line"><span class="keyword">if</span> (user?.<span class="property">name</span>) &#123;</span><br><span class="line">  name = user.<span class="property">name</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;Anonymous&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写方法</span></span><br><span class="line"><span class="keyword">const</span> name = user?.<span class="property">name</span> || <span class="string">&quot;Anonymous&quot;</span>;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS对象复制</title>
      <link href="/2022/11/27/JS%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6/"/>
      <url>/2022/11/27/JS%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>我们知道，赋值运算符不会创建对象的副本，只会分配对它的引用，请看以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> copy = obj;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">a</span> = <span class="number">5</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy.<span class="property">a</span>);</span><br><span class="line"><span class="comment">// Result </span></span><br><span class="line"><span class="comment">// a = 5;</span></span><br></pre></td></tr></table></figure><p>obj变量是初始化的新对象的容器。copy变量指向同一个对象，并且是该对象的引用。所以基本上这个{ a: 1, b: 2, }对象是在说现在有两种方法可以访问我：通过obj变量或copy变量以任何一种方式传递给我，并且你通过这些方式对我所做的任何操作都会影响我。</p><p>此方法消除了任何形式的不变性，如果原始对象被代码的另一部分使用，可能会导致bug。</p><h2 id="复制对象的简单方法"><a href="#复制对象的简单方法" class="headerlink" title="复制对象的简单方法"></a>复制对象的简单方法</h2><p>复制对象的简单方法是遍历原始对象并一个接一个地复制每个属性。让我们看一下这段代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">copy</span>(<span class="params">mainObj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> objCopy = &#123;&#125;; <span class="comment">// objCopy will store a copy of the mainObj</span></span><br><span class="line">  <span class="keyword">let</span> key;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> mainObj) &#123;</span><br><span class="line">    objCopy[key] = mainObj[key]; <span class="comment">// copies each property to the objCopy object</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> objCopy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mainObj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">c</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">7</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">4</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">copy</span>(mainObj));</span><br></pre></td></tr></table></figure><p>但这里有几个问题：</p><ol><li>objCopy对象有一个新的Object.prototype方法，不同于mainObj对象的原型方法，这不是我们想要的。我们想要的是原始对象的精确副本。</li><li>不复制属性描述符。值设置为false的“可写”描述符在objCopy对象中将为true。<br>上面的代码只复制了mainObj的可枚举属性。</li><li>如果原始对象中的属性之一是对象本身，那么它将在副本和原始对象之间共享，使它们各自的属性指向同一个对象。<h2 id="浅拷贝对象"><a href="#浅拷贝对象" class="headerlink" title="浅拷贝对象"></a>浅拷贝对象</h2>当源顶层属性在没有任何引用的情况下被复制并且存在一个值为对象并被复制为引用的源属性时，就称该对象为浅拷贝。如果源值是对对象的引用，那么它只会将该引用值复制到目标对象。</li></ol><p>浅拷贝将复制顶层属性，但嵌套对象在原始（源）和副本（目标）之间共享.</p><h2 id="使用Object-assign-方法"><a href="#使用Object-assign-方法" class="headerlink" title="使用Object.assign()方法"></a>使用Object.assign()方法</h2><p>Object.assign()方法用于将所有可枚举自身属性的值从一个或多个源对象复制到目标对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> objCopy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objCopy);</span><br><span class="line"><span class="comment">// Result - &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure><p>到目前为止，我们制作了obj的副本。现在让我们看看是否存在不可变性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> objCopy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objCopy); <span class="comment">// result - &#123; a: 1, b: 2 &#125;</span></span><br><span class="line">objCopy.<span class="property">b</span> = <span class="number">89</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objCopy); <span class="comment">// result - &#123; a: 1, b: 89 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// result - &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure><p>上面的代码将objCopy对象中的属性b的值更改为89，当我们在控制台中记录修改后的objCopy对象时，更改仅应用于objCopy。最后一行代码检查obj对象是否仍然完整且未曾更改。如果是的话，意味着我们已经成功地创建了源对象的副本，而没有对其进行任何引用。</p><h3 id="Object-assign-的陷阱"><a href="#Object-assign-的陷阱" class="headerlink" title="Object.assign()的陷阱"></a>Object.assign()的陷阱</h3><p>虽然我们成功创建了副本，并且一切似乎都运行良好，但还记得我们讨论过浅拷贝吗？看一个例子：<br>let obj = {<br>  a: 1,<br>  b: {<br>    c: 2,<br>  },<br>}</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj); <span class="comment">// &#123; a: 1, b: &#123; c: 2&#125; &#125;</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">a</span> = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; a: 10, b: &#123; c: 2&#125; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj); <span class="comment">// &#123; a: 1, b: &#123; c: 2&#125; &#125;</span></span><br><span class="line"></span><br><span class="line">newObj.<span class="property">a</span> = <span class="number">20</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; a: 10, b: &#123; c: 2&#125; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj); <span class="comment">// &#123; a: 20, b: &#123; c: 2&#125; &#125;</span></span><br><span class="line"></span><br><span class="line">newObj.<span class="property">b</span>.<span class="property">c</span> = <span class="number">30</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; a: 10, b: &#123; c: 30&#125; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj); <span class="comment">// &#123; a: 20, b: &#123; c: 30&#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: newObj.b.c = 30; Read why..</span></span><br></pre></td></tr></table></figure><p>为什么obj.b.c = 30？<br>嗯，这是Object.assign()的一个陷阱。Object.assign只制作浅拷贝。newObj.b和obj.b两者共享对同一个对象的相同引用，因为没有制作单独的副本，而是复制了对同一个对象的引用。对那个对象的任何属性所做的任何更改都适用于使用该对象的所有引用。<br><code>注意：不能复制原型链上的属性和不可枚举的属性。</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someObj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(someObj, &#123; </span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">2</span>,  </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">c</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,  </span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objCopy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objCopy); <span class="comment">// &#123; c: 3 &#125;</span></span><br></pre></td></tr></table></figure><ol><li>someObj在obj的原型链上，所以它不会被复制。</li><li>属性b是不可枚举的属性。</li><li>属性c有一个可枚举的属性描述符，允许其成为可枚举。这就是属性c被复制的原因</li></ol><h3 id="深度拷贝对象"><a href="#深度拷贝对象" class="headerlink" title="深度拷贝对象"></a>深度拷贝对象</h3><p>深拷贝将复制它遇到的每个对象。副本和原始对象不会共享任何内容。下面是使用Object.assign()遇到的问题的解决方法。</p><h3 id="使用JSON-parse-JSON-stringify-object"><a href="#使用JSON-parse-JSON-stringify-object" class="headerlink" title="使用JSON.parse(JSON.stringify(object));"></a>使用JSON.parse(JSON.stringify(object));</h3><p>这解决了我们之前遇到的问题。现在newObj.b有一个副本而不是引用！这是一种深度复制对象的方法。请看例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; </span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123; </span><br><span class="line">    <span class="attr">c</span>: <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line"></span><br><span class="line">obj.<span class="property">b</span>.<span class="property">c</span> = <span class="number">20</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; a: 1, b: &#123; c: 20 &#125; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj); <span class="comment">// &#123; a: 1, b: &#123; c: 2 &#125; &#125; (New Object Intact!)</span></span><br></pre></td></tr></table></figure><p>陷阱<br>不幸的是，此方法不能用于复制用户定义的对象方法。</p><h3 id="复制对象方法"><a href="#复制对象方法" class="headerlink" title="复制对象方法"></a>复制对象方法</h3><p>到目前为止的示例中，我们还不能复制对象的方法。现在让我们尝试一下，如何来复制对象的方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;scotch.io&#x27;</span>,</span><br><span class="line">  <span class="attr">exec</span>: <span class="keyword">function</span> <span class="title function_">exec</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> method1 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"><span class="keyword">let</span> method2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(method1); <span class="comment">//Object.assign(&#123;&#125;, obj)</span></span><br><span class="line"><span class="comment">/* result</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  exec: function exec() &#123;</span></span><br><span class="line"><span class="comment">    return true;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  name: &quot;scotch.io&quot;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(method2); <span class="comment">// JSON.parse(JSON.stringify(obj))</span></span><br><span class="line"><span class="comment">/* result</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  name: &quot;scotch.io&quot;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>结果表明Object.assign()可以用来复制对象方法，而JSON.parse(JSON.stringify(obj))却不能。</p><h3 id="复制circular对象"><a href="#复制circular对象" class="headerlink" title="复制circular对象"></a>复制circular对象</h3><p>circular对象是具有引用自身属性的对象。让我们使用复制对象的方法来复制circular对象，看看它是否有效。</p><h3 id="使用JSON-parse-JSON-stringify-object-1"><a href="#使用JSON-parse-JSON-stringify-object-1" class="headerlink" title="使用JSON.parse(JSON.stringify(object))"></a>使用JSON.parse(JSON.stringify(object))</h3><p>先试试JSON.parse(JSON.stringify(object))：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// circular object</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; </span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123; </span><br><span class="line">    <span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">d</span>: <span class="string">&#x27;d&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">c</span> = obj.<span class="property">b</span>;</span><br><span class="line">obj.<span class="property">e</span> = obj.<span class="property">a</span>;</span><br><span class="line">obj.<span class="property">b</span>.<span class="property">c</span> = obj.<span class="property">c</span>;</span><br><span class="line">obj.<span class="property">b</span>.<span class="property">d</span> = obj.<span class="property">b</span>;</span><br><span class="line">obj.<span class="property">b</span>.<span class="property">e</span> = obj.<span class="property">b</span>.<span class="property">c</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj); </span><br></pre></td></tr></table></figure><p>结果：<br><code>JSON.parse(JSON.stringify(obj))</code>显然不适用于<code>circular</code>对象。</p><h3 id="使用Object-assign"><a href="#使用Object-assign" class="headerlink" title="使用Object.assign()"></a>使用Object.assign()</h3><p>再试试Object.assign()：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// circular object</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; </span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123; </span><br><span class="line">    <span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">d</span>: <span class="string">&#x27;d&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">c</span> = obj.<span class="property">b</span>;</span><br><span class="line">obj.<span class="property">e</span> = obj.<span class="property">a</span>;</span><br><span class="line">obj.<span class="property">b</span>.<span class="property">c</span> = obj.<span class="property">c</span>;</span><br><span class="line">obj.<span class="property">b</span>.<span class="property">d</span> = obj.<span class="property">b</span>;</span><br><span class="line">obj.<span class="property">b</span>.<span class="property">e</span> = obj.<span class="property">b</span>.<span class="property">c</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newObj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj2); </span><br></pre></td></tr></table></figure><p>结果：</p><p><code>Object.assign()</code>适用于浅拷贝<code>circular</code>对象，但不适用于深拷贝。</p><h3 id="使用展开运算符-…"><a href="#使用展开运算符-…" class="headerlink" title="使用展开运算符(…)"></a>使用展开运算符(…)</h3><p>ES6已经实现了用于数组解构赋值的rest元素和用于数组字面量的展开运算符。数组的展开运算符实现如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [</span><br><span class="line">  <span class="string">&quot;a&quot;</span>,</span><br><span class="line">  <span class="string">&quot;c&quot;</span>,</span><br><span class="line">  <span class="string">&quot;d&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">four</span>: <span class="number">4</span></span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> newArray = [...array];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArray);</span><br><span class="line"><span class="comment">// Result </span></span><br><span class="line"><span class="comment">// [&quot;a&quot;, &quot;c&quot;, &quot;d&quot;, &#123; four: 4 &#125;]</span></span><br></pre></td></tr></table></figure><p>对象初始值设定项中的扩展属性将自己的可枚举属性从源对象复制到目标对象。如果ECMAScript的Stage 3提案接受的话，那么复制对象变得非常容易：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">one</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">two</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newObj = &#123; ...obj &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; one: 1, two: 2 &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯云_宝塔面板部署hexo</title>
      <link href="/2022/11/20/hexo%E9%83%A8%E7%BD%B2/"/>
      <url>/2022/11/20/hexo%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul><li>已经搭建好hexo博客，并将hexo 部署到GitHub</li><li>已经购买好云服务器</li><li>已经购买好域名（没有的也可以用IP 地址访问）<h2 id="安装宝塔面板"><a href="#安装宝塔面板" class="headerlink" title="安装宝塔面板"></a>安装宝塔面板</h2></li><li>可以在服务器预装系统选择 宝塔面板</li><li>或者对服务器进行重装系统<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20221120095748.png"><br>重装完成建议 重置一下服务器登录密码<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20221120100041.png"><h2 id="进入腾讯云的控制台"><a href="#进入腾讯云的控制台" class="headerlink" title="进入腾讯云的控制台"></a>进入腾讯云的控制台</h2><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20221120100225.png"><br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20221120100345.png"><br>输入 <code>sudo /etc/init.d/bt default</code> 可以查看宝塔控制面板地址，<br>下方有账号密码，最好记录下来</li></ul><p>进入宝塔 登录输入刚刚的账号密码<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20221120100753.png"><br>进入之后 直接点击一键安装默认推荐的软件<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/9b27621822492f5e864a38f1a14a4cfa.png"></p><h2 id="安装并配置git仓库"><a href="#安装并配置git仓库" class="headerlink" title="安装并配置git仓库"></a>安装并配置git仓库</h2><p>在远程服务器上配置好 Git 仓库后，才能将本地的 hexo push 到远端。</p><ol><li><p>打开服务器控制台<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20221120101422.png"><br>若当前账号不是root 则通过<code>sudo su root</code>命令切换到root</p></li><li><p>安装git<br><code>yum install git</code></p></li><li><p>创建Git账户</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adduser git</span><br><span class="line">chmod 740 /etc/sudoers</span><br></pre></td></tr></table></figure></li><li><p>编辑/etc/sudoers文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/sudoers</span><br></pre></td></tr></table></figure></li><li><p>按<code>i</code>键进入编辑模式, 找到root ALL=(ALL)   ALL 在其下方加入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git     ALL=(ALL)     ALL</span><br></pre></td></tr></table></figure><p><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20221120101955.png"><br>输入完成后按<code>esc</code>，再输入<code>:wq</code>，保存退出</p></li><li><p>更变/etc/sudoers权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 400 /etc/sudoers</span><br></pre></td></tr></table></figure></li><li><p>设置git账户密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo passwd git</span><br></pre></td></tr></table></figure><p>注意:<code>输入密码，输入的时候是看不到任何显示的，输完回车即可</code>。</p></li><li><p>切换至 <code>git 用户</code>，创建<code>~/.ssh</code>文件夹和<code>~/.ssh/authorized_keys</code>文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su git</span><br><span class="line">mkdir ~/.ssh</span><br><span class="line">vim ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>同样i进入编辑模式，把之前本地准备的id_rsa.pub文件中的公钥复制进去，按esc后，输入:wq保存。</p></li><li><p>更改权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 600 /home/git/.ssh/authorized_keys</span><br><span class="line">chmod 700 /home/git/.ssh</span><br></pre></td></tr></table></figure><p>配置完成之后 接下来创建Git仓库</p></li></ol><h2 id="创建Git-仓库"><a href="#创建Git-仓库" class="headerlink" title="创建Git 仓库"></a>创建Git 仓库</h2><p>在服务端控制台进行操作</p><ol><li>切换<code>root</code>用户<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su root</span><br></pre></td></tr></table></figure></li><li>创建repo作为仓库目录，并加权限<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /var/repo</span><br><span class="line">chown -R git:git /var/repo</span><br><span class="line">chmod -R 755 /var/repo</span><br></pre></td></tr></table></figure></li><li>创建 hexo 目录作为网站根目录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /www/wwwroot/hexo</span><br><span class="line">chown -R git:git /www/wwwroot/hexo</span><br><span class="line">chmod -R 755 /www/wwwroot/hexo</span><br></pre></td></tr></table></figure></li><li>创建一个空白的 git 仓库<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /var/repo</span><br><span class="line">git init --bare hexo.git</span><br></pre></td></tr></table></figure></li><li>编辑一个 Git 钩子<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /var/repo/hexo.git/hooks/post-receive</span><br></pre></td></tr></table></figure>按<code>i</code>进入编辑模式，添加下面的代码，按<code>esc</code>输入<code>:wq</code> 保存<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">git --work-tree=/var/hexo --git-dir=/var/repo/hexo.git checkout -f</span><br></pre></td></tr></table></figure></li><li>更改权限<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown -R git:git /var/repo/hexo.git/hooks/post-receive</span><br><span class="line">chmod +x /var/repo/hexo.git/hooks/post-receive</span><br></pre></td></tr></table></figure><h2 id="宝塔网站配置"><a href="#宝塔网站配置" class="headerlink" title="宝塔网站配置"></a>宝塔网站配置</h2>点击添加站点<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20221120103418.png"><br>配置<br><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/QQ%E6%88%AA%E5%9B%BE20221120103313.png"><br>根目录 选择刚刚创建的hexo文件夹<br>点击提交</li></ol><h2 id="本地推送"><a href="#本地推送" class="headerlink" title="本地推送"></a>本地推送</h2><p>在博客目录中配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@服务器ip或域名:/var/repo/hexo.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>配置完成后，可直接hexo三连到自己的服务器。简单快捷。</p><p>之后就能通过服务器IP地址，访问博客了 默认是80端口<br>所以直接输入服务器IP 就能访问了</p>]]></content>
      
      
      <categories>
          
          <category> 记录&#39; </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2 笔记</title>
      <link href="/2022/11/08/Vue%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/08/Vue%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h2><pre><code>├── node_modules ├── public│   ├── favicon.ico: 页签图标│   └── index.html: 主页面├── src│   ├── assets: 存放静态资源│   │   └── logo.png│   │── component: 存放组件│   │   └── HelloWorld.vue│   │── App.vue: 汇总所有组件│   │── main.js: 入口文件├── .gitignore: git版本管制忽略的配置├── babel.config.js: babel的配置文件├── package.json: 应用包配置文件 ├── README.md: 应用描述文件├── package-lock.json：包版本控制文件</code></pre><h2 id="关于不同版本的Vue"><a href="#关于不同版本的Vue" class="headerlink" title="关于不同版本的Vue"></a>关于不同版本的Vue</h2><ol><li>vue.js与vue.runtime.xxx.js的区别：<ol><li>vue.js是完整版的Vue，包含：核心功能 + 模板解析器。</li><li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</li></ol></li><li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。</li></ol><h2 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a>vue.config.js配置文件</h2><ol><li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li><li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></li></ol><h2 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h2><ol><li>被用来给元素或子组件注册引用信息（id的替代者）</li><li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li><li>使用方式：<ol><li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li><li>获取：<code>this.$refs.xxx</code></li></ol></li></ol><h2 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h2><ol><li><p>功能：让组件接收外部传过来的数据</p></li><li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p></li><li><p>接收数据：</p><ol><li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p></li><li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p></li><li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>:&#123;</span><br><span class="line"><span class="attr">name</span>:&#123;</span><br><span class="line"><span class="attr">type</span>:<span class="title class_">String</span>, <span class="comment">//类型</span></span><br><span class="line"><span class="attr">required</span>:<span class="literal">true</span>, <span class="comment">//必要性</span></span><br><span class="line"><span class="attr">default</span>:<span class="string">&#x27;老王&#x27;</span> <span class="comment">//默认值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p></blockquote></li></ol><h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a>mixin(混入)</h2><ol><li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p></li><li><p>使用方式：</p><p> 第一步定义混合：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    data()&#123;....&#125;,</span><br><span class="line">    methods:&#123;....&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第二步使用混入：</p><p> ​    全局混入：<code>Vue.mixin(xxx)</code><br> ​    局部混入：<code>mixins:[&#39;xxx&#39;]    </code></p></li></ol><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ol><li><p>功能：用于增强Vue</p></li><li><p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p></li><li><p>定义插件：</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue, options</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 添加全局过滤器</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">filter</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 添加全局指令</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">directive</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 配置全局混入(合)</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;...&#125;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myProperty</span> = xxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用插件：<code>Vue.use()</code></p></li></ol><h2 id="scoped样式"><a href="#scoped样式" class="headerlink" title="scoped样式"></a>scoped样式</h2><ol><li>作用：让样式在局部生效，防止冲突。</li><li>写法：<code>&lt;style scoped&gt;</code></li></ol><h2 id="总结TodoList案例"><a href="#总结TodoList案例" class="headerlink" title="总结TodoList案例"></a>总结TodoList案例</h2><ol><li><p>组件化编码流程：</p><p> ​    (1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。</p><p> ​    (2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p><p> ​            1).一个组件在用：放在组件自身即可。</p><p> ​            2). 一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。</p><p> ​    (3).实现交互：从绑定事件开始。</p></li><li><p>props适用于：</p><p> ​    (1).父组件 ==&gt; 子组件 通信</p><p> ​    (2).子组件 ==&gt; 父组件 通信（要求父先给子一个函数）</p></li><li><p>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p></li><li><p>props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。</p></li></ol><h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><ol><li><p>存储内容大小一般支持5MB左右（不同浏览器可能还不一样）</p></li><li><p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p></li><li><p>相关API：</p><ol><li><p><code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);</code></p><pre><code>             该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</code></pre></li><li><p><code>xxxxxStorage.getItem(&#39;person&#39;);</code></p><p> ​        该方法接受一个键名作为参数，返回键名对应的值。</p></li><li><p><code>xxxxxStorage.removeItem(&#39;key&#39;);</code></p><p> ​        该方法接受一个键名作为参数，并把该键名从存储中删除。</p></li><li><p><code> xxxxxStorage.clear()</code></p><p> ​        该方法会清空存储中的所有数据。</p></li></ol></li><li><p>备注：</p><ol><li>SessionStorage存储的内容会随着浏览器窗口关闭而消失。</li><li>LocalStorage存储的内容，需要手动清除才会消失。</li><li><code>xxxxxStorage.getItem(xxx)</code>如果xxx对应的value获取不到，那么getItem的返回值是null。</li><li><code>JSON.parse(null)</code>的结果依然是null。</li></ol></li></ol><h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><ol><li><p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 ===&gt; 父组件</strong></p></li><li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。</p></li><li><p>绑定自定义事件：</p><ol><li><p>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code>  或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></p></li><li><p>第二种方式，在父组件中：</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Demo</span> ref=<span class="string">&quot;demo&quot;</span>/&gt;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">xxx</span>.$on(<span class="string">&#x27;atguigu&#x27;</span>,<span class="variable language_">this</span>.<span class="property">test</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p></li></ol></li><li><p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,数据)</code>        </p></li><li><p>解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code></p></li><li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p></li><li><p>注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！</p></li></ol><h2 id="全局事件总线（GlobalEventBus）"><a href="#全局事件总线（GlobalEventBus）" class="headerlink" title="全局事件总线（GlobalEventBus）"></a>全局事件总线（GlobalEventBus）</h2><ol><li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p></li><li><p>安装全局事件总线：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span> <span class="comment">//安装全局事件总线，$bus就是当前应用的vm</span></span><br><span class="line">&#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure></li><li><p>使用事件总线：</p><ol><li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&#x27;xxxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p></li></ol></li><li><p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。</p></li></ol><h2 id="消息订阅与发布（pubsub）"><a href="#消息订阅与发布（pubsub）" class="headerlink" title="消息订阅与发布（pubsub）"></a>消息订阅与发布（pubsub）</h2><ol><li><p>  一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p></li><li><p>使用步骤：</p><ol><li><p>安装pubsub：<code>npm i pubsub-js</code></p></li><li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p></li><li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pid</span> = pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;xxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>) <span class="comment">//订阅消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p></li><li><p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p></li></ol></li></ol><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><ol><li>语法：<code>this.$nextTick(回调函数)</code></li><li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li><li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li></ol><h2 id="Vue封装的过度与动画"><a href="#Vue封装的过度与动画" class="headerlink" title="Vue封装的过度与动画"></a>Vue封装的过度与动画</h2><ol><li><p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p></li><li><p>图示：<img src="https://img04.sogoucdn.com/app/a/100520146/5990c1dff7dc7a8fb3b34b4462bd0105" style="width:60%" /></p></li><li><p>写法：</p><ol><li><p>准备好样式：</p><ul><li>元素进入的样式：<ol><li>v-enter：进入的起点</li><li>v-enter-active：进入过程中</li><li>v-enter-to：进入的终点</li></ol></li><li>元素离开的样式：<ol><li>v-leave：离开的起点</li><li>v-leave-active：离开过程中</li><li>v-leave-to：离开的终点</li></ol></li></ul></li><li><p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;transition name=&quot;hello&quot;&gt;</span><br><span class="line">&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></li><li><p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p></li></ol></li></ol><h2 id="vue脚手架配置代理"><a href="#vue脚手架配置代理" class="headerlink" title="vue脚手架配置代理"></a>vue脚手架配置代理</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​    在vue.config.js中添加如下配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>:&#123;</span><br><span class="line">  <span class="attr">proxy</span>:<span class="string">&quot;http://localhost:5000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li><li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li><li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​    编写vue.config.js配置具体代理规则：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">      <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api1&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api1&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api1&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;/api2&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api2&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5001&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api2&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class="line"><span class="comment">   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080</span></span><br><span class="line"><span class="comment">   changeOrigin默认值为true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li><li>缺点：配置略微繁琐，请求资源时必须加前缀。</li></ol><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><ol><li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 ===&gt; 子组件</strong> 。</p></li><li><p>分类：默认插槽、具名插槽、作用域插槽</p></li><li><p>使用方式：</p><ol><li><p>默认插槽：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">           &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure></li><li><p>具名插槽：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">            &lt;template slot=&quot;center&quot;&gt;</span><br><span class="line">              &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">            &lt;template v-slot:footer&gt;</span><br><span class="line">               &lt;div&gt;html结构2&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure></li><li><p>作用域插槽：</p><ol><li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;template scope=&quot;scopeData&quot;&gt;</span><br><span class="line">&lt;!-- 生成的是ul列表 --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;template slot-scope=&quot;scopeData&quot;&gt;</span><br><span class="line">&lt;!-- 生成的是h4标题 --&gt;</span><br><span class="line">&lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            export default &#123;</span><br><span class="line">                name:&#x27;Category&#x27;,</span><br><span class="line">                props:[&#x27;title&#x27;],</span><br><span class="line">                //数据在子组件自身</span><br><span class="line">                data() &#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>​        在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p><h3 id="2-何时使用？"><a href="#2-何时使用？" class="headerlink" title="2.何时使用？"></a>2.何时使用？</h3><p>​        多个组件需要共享数据时</p><h3 id="3-搭建vuex环境"><a href="#3-搭建vuex环境" class="headerlink" title="3.搭建vuex环境"></a>3.搭建vuex环境</h3><ol><li><p>创建文件：<code>src/store/index.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//应用Vuex插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions对象——响应组件中用户的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;&#125;</span><br><span class="line"><span class="comment">//准备mutations对象——修改state中的数据</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;&#125;</span><br><span class="line"><span class="comment">//准备state对象——保存具体的数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">actions,</span><br><span class="line">mutations,</span><br><span class="line">state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">//引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vm</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line"><span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line"><span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-基本使用"><a href="#4-基本使用" class="headerlink" title="4.基本使用"></a>4.基本使用</h3><ol><li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//引用Vuex</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    <span class="comment">//响应组件中加的动作</span></span><br><span class="line"><span class="title function_">jia</span>(<span class="params">context,value</span>)&#123;</span><br><span class="line"><span class="comment">// console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value)</span></span><br><span class="line">context.<span class="title function_">commit</span>(<span class="string">&#x27;JIA&#x27;</span>,value)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    <span class="comment">//执行加</span></span><br><span class="line"><span class="title function_">JIA</span>(<span class="params">state,value</span>)&#123;</span><br><span class="line"><span class="comment">// console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value)</span></span><br><span class="line">state.<span class="property">sum</span> += value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">   <span class="attr">sum</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">actions,</span><br><span class="line">mutations,</span><br><span class="line">state,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p></li><li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p><blockquote><p> 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p></blockquote></li></ol><h3 id="5-getters的使用"><a href="#5-getters的使用" class="headerlink" title="5.getters的使用"></a>5.getters的使用</h3><ol><li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p></li><li><p>在<code>store.js</code>中追加<code>getters</code>配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line"><span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">......</span><br><span class="line">getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件中读取数据：<code>$store.getters.bigSum</code></p></li></ol><h3 id="6-四个map方法的使用"><a href="#6-四个map方法的使用" class="headerlink" title="6.四个map方法的使用"></a>6.四个map方法的使用</h3><ol><li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（对象写法）</span></span><br><span class="line">     ...<span class="title function_">mapState</span>(&#123;<span class="attr">sum</span>:<span class="string">&#x27;sum&#x27;</span>,<span class="attr">school</span>:<span class="string">&#x27;school&#x27;</span>,<span class="attr">subject</span>:<span class="string">&#x27;subject&#x27;</span>&#125;),</span><br><span class="line">         </span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapState</span>([<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（对象写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>(&#123;<span class="attr">bigSum</span>:<span class="string">&#x27;bigSum&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>([<span class="string">&#x27;bigSum&#x27;</span>])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>(&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（数组形式）</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>([<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="string">&#x27;jiaWait&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：increment、decrement（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>(&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//靠mapMutations生成：JIA、JIAN（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;JIA&#x27;</span>,<span class="string">&#x27;JIAN&#x27;</span>]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p></blockquote><h3 id="7-模块化-命名空间"><a href="#7-模块化-命名空间" class="headerlink" title="7.模块化+命名空间"></a>7.模块化+命名空间</h3><ol><li><p>目的：让代码更好维护，让多种数据分类更加明确。</p></li><li><p>修改<code>store.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> countAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    countAbout,</span><br><span class="line">    personAbout</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中读取state数据：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">personAbout</span>.<span class="property">list</span></span><br><span class="line"><span class="comment">//方式二：借助mapState读取：</span></span><br><span class="line">...<span class="title function_">mapState</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中读取getters数据：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">&#x27;personAbout/firstPersonName&#x27;</span>]</span><br><span class="line"><span class="comment">//方式二：借助mapGetters读取：</span></span><br><span class="line">...<span class="title function_">mapGetters</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;bigSum&#x27;</span>])</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中调用dispatch</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接dispatch</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;personAbout/addPersonWang&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapActions：</span></span><br><span class="line">...<span class="title function_">mapActions</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中调用commit</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接commit</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;personAbout/ADD_PERSON&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapMutations：</span></span><br><span class="line">...<span class="title function_">mapMutations</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br></pre></td></tr></table></figure></li></ol><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol><li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li><li>前端路由：key是路径，value是组件。</li></ol><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><ol><li><p>安装vue-router，命令：<code>npm i vue-router</code></p></li><li><p>应用插件：<code>Vue.use(VueRouter)</code></p></li><li><p>编写router配置项:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入VueRouter</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//引入Luyou 组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../components/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Home&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建router实例对象，去管理一组一组的路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露router</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure></li><li><p>实现切换（active-class可配置高亮样式）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li><li><p>指定展示位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-几个注意点"><a href="#2-几个注意点" class="headerlink" title="2.几个注意点"></a>2.几个注意点</h3><ol><li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li><li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li><li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li><li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li></ol><h3 id="3-多级路由（多级路由）"><a href="#3-多级路由（多级路由）" class="headerlink" title="3.多级路由（多级路由）"></a>3.多级路由（多级路由）</h3><ol><li><p>配置路由规则，使用children配置项：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">About</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line"><span class="attr">children</span>:[ <span class="comment">//通过children配置子级路由</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>, <span class="comment">//此处一定不要写：/news</span></span><br><span class="line"><span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;message&#x27;</span>,<span class="comment">//此处一定不要写：/message</span></span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Message</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>跳转（要写完整路径）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-路由的query参数"><a href="#4-路由的query参数" class="headerlink" title="4.路由的query参数"></a>4.路由的query参数</h3><ol><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">:to=&quot;&#123;</span><br><span class="line">path:&#x27;/home/message/detail&#x27;,</span><br><span class="line">query:&#123;</span><br><span class="line">   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$route.<span class="property">query</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">query</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="5-命名路由"><a href="#5-命名路由" class="headerlink" title="5.命名路由"></a>5.命名路由</h3><ol><li><p>作用：可以简化路由的跳转。</p></li><li><p>如何使用</p><ol><li><p>给路由命名：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/demo&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Demo</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Test</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line">                      <span class="attr">name</span>:<span class="string">&#x27;hello&#x27;</span> <span class="comment">//给路由命名</span></span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;welcome&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Hello</span>,</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>简化跳转：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--简化前，需要写完整的路径 --&gt;</span><br><span class="line">&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化后，直接通过名字跳转 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化写法配合传递参数 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">:to=&quot;&#123;</span><br><span class="line">name:&#x27;hello&#x27;,</span><br><span class="line">query:&#123;</span><br><span class="line">   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="6-路由的params参数"><a href="#6-路由的params参数" class="headerlink" title="6.路由的params参数"></a>6.路由的params参数</h3><ol><li><p>配置路由，声明接收params参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Message</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title&#x27;</span>, <span class="comment">//使用占位符声明接收params参数</span></span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Detail</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">:to=&quot;&#123;</span><br><span class="line">name:&#x27;xiangqing&#x27;,</span><br><span class="line">params:&#123;</span><br><span class="line">   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><blockquote><p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p></blockquote></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$route.<span class="property">params</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">params</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="7-路由的props配置"><a href="#7-路由的props配置" class="headerlink" title="7.路由的props配置"></a>7.路由的props配置</h3><p>​    作用：让路由组件更方便的收到参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;detail/:id&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Detail</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span></span><br><span class="line"><span class="comment">// props:&#123;a:900&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span></span><br><span class="line"><span class="comment">// props:true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span></span><br><span class="line"><span class="title function_">props</span>(<span class="params">route</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">id</span>:route.<span class="property">query</span>.<span class="property">id</span>,</span><br><span class="line"><span class="attr">title</span>:route.<span class="property">query</span>.<span class="property">title</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-lt-router-link-gt-的replace属性"><a href="#8-lt-router-link-gt-的replace属性" class="headerlink" title="8.&lt;router-link&gt;的replace属性"></a>8.<code>&lt;router-link&gt;</code>的replace属性</h3><ol><li>作用：控制路由跳转时操作浏览器历史记录的模式</li><li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li><li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li></ol><h3 id="9-编程式路由导航"><a href="#9-编程式路由导航" class="headerlink" title="9.编程式路由导航"></a>9.编程式路由导航</h3><ol><li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p></li><li><p>具体编码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//$router的两个API</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">params</span>:&#123;</span><br><span class="line"><span class="attr">id</span>:xxx,</span><br><span class="line"><span class="attr">title</span>:xxx</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">params</span>:&#123;</span><br><span class="line"><span class="attr">id</span>:xxx,</span><br><span class="line"><span class="attr">title</span>:xxx</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">forward</span>() <span class="comment">//前进</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>() <span class="comment">//后退</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>() <span class="comment">//可前进也可后退</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="10-缓存路由组件"><a href="#10-缓存路由组件" class="headerlink" title="10.缓存路由组件"></a>10.缓存路由组件</h3><ol><li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;News&quot;&gt; </span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="11-两个新的生命周期钩子"><a href="#11-两个新的生命周期钩子" class="headerlink" title="11.两个新的生命周期钩子"></a>11.两个新的生命周期钩子</h3><ol><li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li><li>具体名字：<ol><li><code>activated</code>路由组件被激活时触发。</li><li><code>deactivated</code>路由组件失活时触发。</li></ol></li></ol><h3 id="12-路由守卫"><a href="#12-路由守卫" class="headerlink" title="12.路由守卫"></a>12.路由守卫</h3><ol><li><p>作用：对路由进行权限控制</p></li><li><p>分类：全局守卫、独享守卫、组件内守卫</p></li><li><p>全局守卫:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局前置守卫：初始化时执行、每次路由切换前执行</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEach&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line"><span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123; <span class="comment">//权限控制的具体规则</span></span><br><span class="line"><span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line"><span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局后置守卫：初始化时执行、每次路由切换后执行</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;afterEach&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line"><span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">title</span>)&#123; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">title</span> = to.<span class="property">meta</span>.<span class="property">title</span> <span class="comment">//修改网页的title</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;vue_test&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>独享守卫:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">beforeEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEnter&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line"><span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line"><span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>组件内守卫：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入守卫：通过路由规则，进入该组件时被调用</span></span><br><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//离开守卫：通过路由规则，离开该组件时被调用</span></span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="13-路由器的两种工作模式"><a href="#13-路由器的两种工作模式" class="headerlink" title="13.路由器的两种工作模式"></a>13.路由器的两种工作模式</h3><ol><li>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</li><li>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</li><li>hash模式：<ol><li>地址中永远带着#号，不美观 。</li><li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li><li>兼容性较好。</li></ol></li><li>history模式：<ol><li>地址干净，美观 。</li><li>兼容性和hash模式相比略差。</li><li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise.all() 的小技巧</title>
      <link href="/2022/11/06/Promise.all()%20%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/11/06/Promise.all()%20%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>Promise 在处理异步操作时很有用。<br>JavaScript 提供了一个辅助函数Promise.all(promisesArrayOrIterable)来同时并行处理多个 promise，并在单个聚合数组中获取结果。让我们看看它是如何工作的。</p><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p>Promise.all() 接受一组 promises（或通常是一个可迭代的）。该函数返回一个 promise：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> allPromise = <span class="title class_">Promise</span>.<span class="title function_">all</span>([promise1, promise2, ...]);</span><br></pre></td></tr></table></figure><p>然后您可以使用 then-able 语法提取 Promise 解析的值：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">allPromise.<span class="title function_">then</span>(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  values; <span class="comment">// [valueOfPromise1, valueOfPromise2, ...]</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  error;  <span class="comment">// rejectReason of any first rejected promise</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>或 async/await语法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> values = <span class="keyword">await</span> allPromise;</span><br><span class="line">  values; <span class="comment">// [valueOfPromise1, valueOfPromise2, ...]</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  error;  <span class="comment">// rejectReason of any first rejected promise</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="所有的-Promise-fulfilled"><a href="#所有的-Promise-fulfilled" class="headerlink" title="所有的 Promise fulfilled"></a>所有的 Promise fulfilled</h2><p>为了研究如何 Promise.all() 工作，我将使用 2 个助手 -resolveTimeout(value, delay)和rejectTimeout(reason, delay).</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolveTimeout</span>(<span class="params">value, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(</span><br><span class="line">    <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(value), delay)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">rejectTimeout</span>(<span class="params">reason, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(</span><br><span class="line">    <span class="function">(<span class="params">r, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(reason), delay)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> allPromise = <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">  <span class="title function_">resolveTimeout</span>([<span class="string">&#x27;potatoes&#x27;</span>, <span class="string">&#x27;tomatoes&#x27;</span>], <span class="number">1000</span>),</span><br><span class="line">  <span class="title function_">resolveTimeout</span>([<span class="string">&#x27;oranges&#x27;</span>, <span class="string">&#x27;apples&#x27;</span>], <span class="number">1000</span>)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait...</span></span><br><span class="line"><span class="keyword">const</span> lists = <span class="keyword">await</span> allPromise;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after 1 second</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lists); </span><br><span class="line"><span class="comment">// [[&#x27;potatoes&#x27;, &#x27;tomatoes&#x27;], [&#x27;oranges&#x27;, &#x27;apples&#x27;]]</span></span><br></pre></td></tr></table></figure><p>promises 数组的顺序直接影响结果的顺序。</p><h3 id="一个-Promise-rejects"><a href="#一个-Promise-rejects" class="headerlink" title="一个 Promise rejects"></a>一个 Promise rejects</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> allPromise = <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">  <span class="title function_">resolveTimeout</span>([<span class="string">&#x27;potatoes&#x27;</span>, <span class="string">&#x27;tomatoes&#x27;</span>], <span class="number">1000</span>),</span><br><span class="line">  <span class="title function_">rejectTimeout</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Out of fruits!&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// wait...</span></span><br><span class="line">  <span class="keyword">const</span> lists = <span class="keyword">await</span> allPromise;</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="comment">// after 1 second</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error.<span class="property">message</span>); <span class="comment">// &#x27;Out of fruits!&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种行为Promise.all([…])被命名为fail-fast。如果 promises 数组中至少有一个 promise 拒绝，则allPromise = Promise.all([…])rejects返回的promise也会被拒绝。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Promise.all() 方法接收一个promise的iterable类型（注：Array，Map，Set都属于ES6的iterable类型）的输入，并且只返回一个Promise实例， 那个输入的所有promise的resolve回调的结果是一个数组。这个Promise的resolve回调执行是在所有输入的promise的resolve回调都结束，或者输入的iterable里没有promise了的时候。它的reject回调执行是，只要任何一个输入的promise的reject回调执行或者输入不合法的promise就会立即抛出错误，并且reject的是第一个抛出的错误信息。</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法题</title>
      <link href="/2022/10/29/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2022/10/29/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>输入一个字符串，打印出该字符串中字符的所有排列。<br>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。<br><code>输入：s = &quot;abc&quot; 输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string[]</span>&#125;</span></span><br><span class="line"><span class="comment"> * 全排列算法:</span></span><br><span class="line"><span class="comment"> *   固定位置依次递归交换位置穷举出所有的可能性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permutation = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> char = s.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> dsf = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="comment">// 递归的出口,如果是遍历到最后一个位置此方法就解了</span></span><br><span class="line">    <span class="keyword">if</span>( n === char.<span class="property">length</span>) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(char.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> catSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = n ;i &lt; char.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//如果有相同的交换，则不需要处理枝减。</span></span><br><span class="line">      <span class="keyword">if</span>(catSet.<span class="title function_">has</span>(char[i])) <span class="keyword">continue</span>;</span><br><span class="line">      catSet.<span class="title function_">add</span>(char[i]);</span><br><span class="line">      <span class="comment">// 被固定的位置和其他位置依次交换位置</span></span><br><span class="line">      &#123; <span class="keyword">const</span> t = char[n]; char[n] = char[i]; char[i] = t &#125;</span><br><span class="line">      <span class="comment">// 递归下一个位置  </span></span><br><span class="line">      <span class="title function_">dsf</span>(n + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 被交换的位置需要回溯归位。</span></span><br><span class="line">      &#123; <span class="keyword">const</span> t = char[n]; char[n] = char[i]; char[i] = t &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">dsf</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">sort</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 ajax javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html的小技巧</title>
      <link href="/2022/10/23/html%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/10/23/html%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="使用capture属性打开设备摄像头"><a href="#使用capture属性打开设备摄像头" class="headerlink" title="使用capture属性打开设备摄像头"></a>使用capture属性打开设备摄像头</h3><p>正如input标签具有email、text和password属性一样，我们也可以通过一些属性打开移动设备的摄像头以捕获图像。<br>那就是capture属性，属性值有两个：</p><ul><li>user用于前置摄像头</li><li>environment用于后置摄像头<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">capture</span>=<span class="string">&quot;user&quot;</span> <span class="attr">accept</span>=<span class="string">&quot;image/*&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="网站自动刷新"><a href="#网站自动刷新" class="headerlink" title="网站自动刷新"></a>网站自动刷新</h3>你可以在head标签中将网站设置为定时刷新！<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="激活拼写检查"><a href="#激活拼写检查" class="headerlink" title="激活拼写检查"></a>激活拼写检查</h3>你可以使用HTML的spellcheck属性并将其设置为true以激活拼写检查。使用lang属性指定待检查的语言。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">spellcheck</span>=<span class="string">&quot;true&quot;</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="指定要上传的文件类型"><a href="#指定要上传的文件类型" class="headerlink" title="指定要上传的文件类型"></a>指定要上传的文件类型</h3>你可以使用accept属性在input标签中指定允许用户上传的文件类型。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">accept</span>=<span class="string">&quot;.jpeg,.png&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="阻止浏览器翻译"><a href="#阻止浏览器翻译" class="headerlink" title="阻止浏览器翻译"></a>阻止浏览器翻译</h3>将translate属性设置为no会阻止浏览器翻译该内容。如果你不想翻译某个短语或单词，例如logo、公司或品牌名称，那就可以应用这个属性。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">translate</span>=<span class="string">&quot;no&quot;</span>&gt;</span>Brand name<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在input标签中输入多个项目"><a href="#在input标签中输入多个项目" class="headerlink" title="在input标签中输入多个项目"></a>在input标签中输入多个项目</h3>这可以通过multiple属性来完成。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="为视频创建海报（缩略图）"><a href="#为视频创建海报（缩略图）" class="headerlink" title="为视频创建海报（缩略图）"></a>为视频创建海报（缩略图）</h3>使用poster属性，我们可以在视频加载时，或者在用户点击播放按钮之前，显示指定的缩略图。</li></ul><p>如果不指定图片，则默认使用视频的第一帧作为缩略图。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">poster</span>=<span class="string">&quot;picture.png&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="点击链接自动下载）"><a href="#点击链接自动下载）" class="headerlink" title="点击链接自动下载）"></a>点击链接自动下载）</h3><p>如果你希望在单击目标资源的链接时下载特定资源，那就添加download属性。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;image.png&quot;</span> <span class="attr">download</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 ajax javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 数组方法</title>
      <link href="/2022/10/15/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2022/10/15/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>JavaScript中的Array对象与其他编程语言中的数组一样，可以将多个项目的集合存储在单个变量名下，并具有用于执行常见数组操作的成员。<br>声明数组<br>有两种不同的方式可以声明数组。</p><h3 id="使用new-Array"><a href="#使用new-Array" class="headerlink" title="使用new Array"></a>使用new Array</h3><p>通过new Array，我们可以指定希望存在于数组中的元素，如下所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits.<span class="property">length</span>);</span><br></pre></td></tr></table></figure><h4 id="数组字面量表示法"><a href="#数组字面量表示法" class="headerlink" title="数组字面量表示法"></a>数组字面量表示法</h4><p>使用数组字面量声明，我们可以指定数组将具有的值。如果我们不声明任何值，则数组将为空。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过数组字面量创建一个有2个元素的&#x27;fruits&#x27;数组.</span></span><br><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits.<span class="property">length</span>);</span><br></pre></td></tr></table></figure><h4 id="1-forEach"><a href="#1-forEach" class="headerlink" title="1. forEach"></a>1. forEach</h4><p>forEach()方法将为每个数组元素执行一次指定的函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">array1.<span class="title function_">forEach</span>(<span class="function"><span class="params">element</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(element));</span><br><span class="line"></span><br><span class="line"><span class="comment">// expected output: &quot;a&quot;</span></span><br><span class="line"><span class="comment">// expected output: &quot;b&quot;</span></span><br><span class="line"><span class="comment">// expected output: &quot;c&quot;</span></span><br></pre></td></tr></table></figure><p>forEach()为数组中的每个元素按索引升序调用提供的callbackFn函数一次。它不会为已删除或未初始化的索引属性调用。</p><h4 id="2-map"><a href="#2-map" class="headerlink" title="2. map"></a>2. map</h4><p>Array.map()方法允许你遍历数组并使用回调函数修改其元素。然后将在数组的每个元素上执行回调函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">map</span>(callback[, thisObject]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> modifiedArr = arr.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> element *<span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(modifiedArr); <span class="comment">// [9, 12, 15, 18]</span></span><br></pre></td></tr></table></figure><p>Array.map()方法通常用于对元素应用一些更改，无论是像在上面代码中那样乘以特定数字，还是执行应用程序可能需要的任何其他操作。</p><h4 id="3-concat"><a href="#3-concat" class="headerlink" title="3. concat"></a>3. concat</h4><p>JavaScript中的concat()方法是一个字符串方法，用于将字符串连接在一起。concat()方法将一个或多个字符串值附加到调用字符串，然后将连接的结果作为新字符串返回。因为concat()方法是String对象的方法，所以必须通过String类的特定实例来调用它。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">concat</span>(value1, value2, ..., valueN);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> array2 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> array3 = array1.<span class="title function_">concat</span>(array2);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array3);</span><br><span class="line"><span class="comment">// expected output: Array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="4-push"><a href="#4-push" class="headerlink" title="4. push"></a>4. push</h4><p>Javascript数组中的push()方法将给定元素附加到数组最后并返回新数组的长度。</p><p>如果你想在数组末尾添加一个元素，请使用push()。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">push</span>(element1, ..., elementN);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> countries = [<span class="string">&quot;Nigeria&quot;</span>, <span class="string">&quot;Ghana&quot;</span>, <span class="string">&quot;Rwanda&quot;</span>];</span><br><span class="line"></span><br><span class="line">countries.<span class="title function_">push</span>(<span class="string">&quot;Kenya&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(countries); <span class="comment">// [&quot;Nigeria&quot;,&quot;Ghana&quot;,&quot;Rwanda&quot;,&quot;Kenya&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="5-pop"><a href="#5-pop" class="headerlink" title="5. pop"></a>5. pop</h4><p>pop()方法将删除数组的最后一个元素并将该值返回给调用者。如果你在空数组上调用pop()，则返回undefined。</p><p>Array.prototype.shift()与pop()具有相似的行为，但应用于数组中的第一个元素。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">pop</span>();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> plants = [<span class="string">&#x27;broccoli&#x27;</span>, <span class="string">&#x27;cauliflower&#x27;</span>, <span class="string">&#x27;cabbage&#x27;</span>, <span class="string">&#x27;kale&#x27;</span>, <span class="string">&#x27;tomato&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(plants.<span class="title function_">pop</span>());</span><br><span class="line"><span class="comment">// expected output: &quot;tomato&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(plants);</span><br><span class="line"><span class="comment">// expected output: Array [&quot;broccoli&quot;, &quot;cauliflower&quot;, &quot;cabbage&quot;, &quot;kale&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="6-splice"><a href="#6-splice" class="headerlink" title="6. splice"></a>6. splice</h4><p>splice()方法是一种通用方法，用于在数组的指定位置通过删除、替换或添加元素来更改数组的内容。本节将介绍如何使用此方法将元素添加到特定位置。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">splice</span>(index, howMany, [element1][, ..., elementN]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span>];</span><br><span class="line"></span><br><span class="line">fruits.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&quot;Lemon&quot;</span>, <span class="string">&quot;Kiwi&quot;</span>); <span class="comment">//Banana,Orange,Lemon,Kiwi,Apple,Mango</span></span><br></pre></td></tr></table></figure><h4 id="7-slice"><a href="#7-slice" class="headerlink" title="7. slice"></a>7. slice</h4><p>slice()方法将一部分数组的浅表副本返回到从开始到结束（不包括结束）选择的新数组对象中，其中开始和结束表示该数组中项目的索引。该方法不会修改原始数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">slice</span>( begin [,end] );</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> animals = [<span class="string">&#x27;ant&#x27;</span>, <span class="string">&#x27;bison&#x27;</span>, <span class="string">&#x27;camel&#x27;</span>, <span class="string">&#x27;duck&#x27;</span>, <span class="string">&#x27;elephant&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(animals.<span class="title function_">slice</span>(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// expected output: Array [&quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(animals.<span class="title function_">slice</span>(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// expected output: Array [&quot;camel&quot;, &quot;duck&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="8-shift"><a href="#8-shift" class="headerlink" title="8. shift"></a>8. shift</h4><p>shift()是内置的JavaScript函数，用于从数组中删除第一个元素。shift()函数直接修改正在使用的数组。同时shift()返回数组中删除的项目。</p><p>shift()函数删除索引位置0的项目，并将索引号的值依次向下移动1。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">shift</span>();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> firstElement = array1.<span class="title function_">shift</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array1);</span><br><span class="line"><span class="comment">// expected output: Array [2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstElement);</span><br><span class="line"><span class="comment">// expected output: 1</span></span><br></pre></td></tr></table></figure><h4 id="9-unshift"><a href="#9-unshift" class="headerlink" title="9. unshift"></a>9. unshift</h4><p>unshift()方法将插入给定值到类数组对象的开头。</p><p>Array.prototype.push()与unshift()具有相似的行为，但应用于数组的末尾。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">unshift</span>( element1, ..., elementN );</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array1.<span class="title function_">unshift</span>(<span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line"><span class="comment">// expected output: 5</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array1);</span><br><span class="line"><span class="comment">// expected output: Array [4, 5, 1, 2, 3]</span></span><br></pre></td></tr></table></figure><h4 id="10-join"><a href="#10-join" class="headerlink" title="10. join"></a>10. join</h4><p>JavaScript数组中的join()方法是一个内置方法，通过连接数组的所有元素来创建并返回新字符串。join()方法将连接数组的项到字符串并返回该字符串。指定的分隔符用于分隔元素数组。默认分隔符是逗号(,)。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">join</span>(separator);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> elements = [<span class="string">&#x27;Fire&#x27;</span>, <span class="string">&#x27;Air&#x27;</span>, <span class="string">&#x27;Water&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(elements.<span class="title function_">join</span>());</span><br><span class="line"><span class="comment">// expected output: &quot;Fire,Air,Water&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(elements.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line"><span class="comment">// expected output: &quot;FireAirWater&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(elements.<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>));</span><br><span class="line"><span class="comment">// expected output: &quot;Fire-Air-Water&quot;</span></span><br></pre></td></tr></table></figure><h4 id="11-every"><a href="#11-every" class="headerlink" title="11. every"></a>11. every</h4><p>every()方法测试数组中的所有元素是否都满足指定的条件。返回的是布尔值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">every</span>(callback[, thisObject]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isBelowThreshold</span> = (<span class="params">currentValue</span>) =&gt; currentValue &lt; <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">30</span>, <span class="number">39</span>, <span class="number">29</span>, <span class="number">10</span>, <span class="number">13</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array1.<span class="title function_">every</span>(isBelowThreshold));</span><br><span class="line"><span class="comment">// expected output: true</span></span><br></pre></td></tr></table></figure><h4 id="12-filter"><a href="#12-filter" class="headerlink" title="12. filter"></a>12. filter</h4><p>filter()方法创建部分给定数组的浅表副本，向下过滤到给定数组中的元素，且元素通过所提供函数实现的条件测试。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">filter</span>(callback[, thisObject]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> words = [<span class="string">&#x27;spray&#x27;</span>, <span class="string">&#x27;limit&#x27;</span>, <span class="string">&#x27;elite&#x27;</span>, <span class="string">&#x27;exuberant&#x27;</span>, <span class="string">&#x27;destruction&#x27;</span>, <span class="string">&#x27;present&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = words.<span class="title function_">filter</span>(<span class="function"><span class="params">word</span> =&gt;</span> word.<span class="property">length</span> &gt; <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"><span class="comment">// expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="13-indexOf"><a href="#13-indexOf" class="headerlink" title="13. indexOf"></a>13. indexOf</h4><p>indexOf()方法返回可以在数组中找到给定元素的第一个索引，如果不存在则返回-1。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">indexOf</span>(searchElement[, fromIndex]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> beasts = [<span class="string">&#x27;ant&#x27;</span>, <span class="string">&#x27;bison&#x27;</span>, <span class="string">&#x27;camel&#x27;</span>, <span class="string">&#x27;duck&#x27;</span>, <span class="string">&#x27;bison&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(beasts.<span class="title function_">indexOf</span>(<span class="string">&#x27;bison&#x27;</span>));</span><br><span class="line"><span class="comment">// expected output: 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// start from index 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(beasts.<span class="title function_">indexOf</span>(<span class="string">&#x27;bison&#x27;</span>, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// expected output: 4</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(beasts.<span class="title function_">indexOf</span>(<span class="string">&#x27;giraffe&#x27;</span>));</span><br><span class="line"><span class="comment">// expected output: -1</span></span><br></pre></td></tr></table></figure><h4 id="14-reduce"><a href="#14-reduce" class="headerlink" title="14. reduce"></a>14. reduce</h4><p>reduce()方法按顺序对数组的每个元素执行用户提供的reducer回调函数，传入前一个元素的计算返回值。在数组的所有元素上运行reducer的最终结果是单个值。。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">reduce</span>(callback[, initialValue]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 + 1 + 2 + 3 + 4</span></span><br><span class="line"><span class="keyword">const</span> initialValue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> sumWithInitial = array1.<span class="title function_">reduce</span>(</span><br><span class="line">  <span class="function">(<span class="params">previousValue, currentValue</span>) =&gt;</span> previousValue + currentValue,</span><br><span class="line">  initialValue</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sumWithInitial)</span><br></pre></td></tr></table></figure><h4 id="15-reverse"><a href="#15-reverse" class="headerlink" title="15. reverse"></a>15. reverse</h4><p>reverse()方法将反转数组并返回对相同数组的引用，第一个数组元素成为最后一个，最后一个数组元素成为第一个。换句话说，数组中的元素顺序将转向与之前相反的方向。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">reverse</span>();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;array1:&#x27;</span>, array1);</span><br><span class="line"><span class="comment">// expected output: &quot;array1:&quot; Array [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reversed = array1.<span class="title function_">reverse</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reversed:&#x27;</span>, reversed);</span><br><span class="line"><span class="comment">// expected output: &quot;reversed:&quot; Array [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Careful: reverse is destructive -- it changes the original array.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;array1:&#x27;</span>, array1);</span><br><span class="line"><span class="comment">// expected output: &quot;array1:&quot; Array [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="16-sort"><a href="#16-sort" class="headerlink" title="16. sort"></a>16. sort</h4><p>sort()方法对数组的元素进行就地排序，并返回对同一个数组的引用，而此时数组已排序。默认排序顺序是升序，将元素转换为字符串，然后比较它们的UTF-16代码单元值序列。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">sort</span>( compareFunction );</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> months = [<span class="string">&#x27;March&#x27;</span>, <span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>];</span><br><span class="line">months.<span class="title function_">sort</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(months);</span><br><span class="line"><span class="comment">// expected output: Array [&quot;Dec&quot;, &quot;Feb&quot;, &quot;Jan&quot;, &quot;March&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">30</span>, <span class="number">4</span>, <span class="number">21</span>, <span class="number">100000</span>];</span><br><span class="line">array1.<span class="title function_">sort</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array1);</span><br><span class="line"><span class="comment">// expected output: Array [1, 100000, 21, 30, 4]</span></span><br></pre></td></tr></table></figure><h4 id="17-toString"><a href="#17-toString" class="headerlink" title="17. toString"></a>17. toString</h4><p>toString()方法返回表示对象的字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">toString</span>();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog1 = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Gabby&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span> <span class="title function_">dogToString</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog1.<span class="title function_">toString</span>());</span><br><span class="line"><span class="comment">// expected output: &quot;Gabby&quot;</span></span><br></pre></td></tr></table></figure><h4 id="18-at"><a href="#18-at" class="headerlink" title="18. at"></a>18. at</h4><p>at()方法接受整数值并返回at索引的项目，正整数和负整数皆可。负整数从数组中的最后一项开始倒数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">at</span>(index)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Using an index of <span class="subst">$&#123;index&#125;</span> the item returned is <span class="subst">$&#123;array1.at(index)&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// expected output: &quot;Using an index of 2 the item returned is 8&quot;</span></span><br><span class="line"></span><br><span class="line">index = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Using an index of <span class="subst">$&#123;index&#125;</span> item returned is <span class="subst">$&#123;array1.at(index)&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// expected output: &quot;Using an index of -2 item returned is 130&quot;</span></span><br></pre></td></tr></table></figure><h4 id="19-find"><a href="#19-find" class="headerlink" title="19. find"></a>19. find</h4><p>find()方法返回数组中满足条件测试函数的第一个元素。如果没有值满足提供的测试函数，则返回undefined。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">find</span>(<span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>),thisValue)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> found = array1.<span class="title function_">find</span>(<span class="function"><span class="params">element</span> =&gt;</span> element &gt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(found);</span><br><span class="line"><span class="comment">// expected output: 12</span></span><br></pre></td></tr></table></figure><h4 id="20-some"><a href="#20-some" class="headerlink" title="20. some"></a>20. some</h4><p>some()方法测试数组中是不是至少有一个元素通过了函数实现的条件测试。如果在数组中找到这样的元素就返回true；否则返回false。该方法不修改原数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">some</span>(callback[, thisObject]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// checks whether an element is even</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">even</span> = (<span class="params">element</span>) =&gt; element % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array.<span class="title function_">some</span>(even));</span><br><span class="line"><span class="comment">// expected output: true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12个实用的JS函数</title>
      <link href="/2022/10/07/12%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84JS%E5%87%BD%E6%95%B0/"/>
      <url>/2022/10/07/12%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84JS%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文收集了 12 个在日常开发中非常常用的函数，有些可能很复杂，有些可能很简单，但我相信或多或少会对大家都会有所帮助。</p><h3 id="生成随机颜色"><a href="#生成随机颜色" class="headerlink" title="生成随机颜色"></a>生成随机颜色</h3><p>你的网站是否需要生成随机颜色？下面一行代码就可以实现。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">generateRandomHexColor</span> = (<span class="params"></span>) =&gt; <span class="string">`#<span class="subst">$&#123;<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">0xffffff</span>).toString(<span class="number">16</span>)&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generateRandomHexColor</span>())</span><br></pre></td></tr></table></figure><h3 id="数组重排序"><a href="#数组重排序" class="headerlink" title="数组重排序"></a>数组重排序</h3><p>对数组的元素进行重新排序是一项非常重要的技巧，但是原生 Array 中并没有这项功能。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">shuffle</span> = (<span class="params">arr</span>) =&gt; arr.<span class="title function_">sort</span>(<span class="function">() =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">shuffle</span>(arr))</span><br></pre></td></tr></table></figure><h3 id="复制到剪切板"><a href="#复制到剪切板" class="headerlink" title="复制到剪切板"></a>复制到剪切板</h3><p>复制到剪切板是一项非常实用且能够提高用户便利性的功能。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">copyToClipboard</span> = (<span class="params">text</span>) =&gt; navigator.<span class="property">clipboard</span> &amp;&amp; navigator.<span class="property">clipboard</span>.<span class="property">writeText</span> &amp;&amp; navigator.<span class="property">clipboard</span>.<span class="title function_">writeText</span>(text)</span><br><span class="line"></span><br><span class="line"><span class="title function_">copyToClipboard</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="检测暗色主题"><a href="#检测暗色主题" class="headerlink" title="检测暗色主题"></a>检测暗色主题</h3><p>暗色主题日益普及，很多用的都会在设备中启用案模式，我们将应用程序切换到暗色主题可以提高用户体验度。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isDarkMode</span> = (<span class="params"></span>) =&gt; <span class="variable language_">window</span>.<span class="property">matchMedia</span> &amp;&amp; <span class="variable language_">window</span>.<span class="title function_">matchMedia</span>(<span class="string">&quot;(prefers-color-scheme: dark)&quot;</span>).<span class="property">matches</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isDarkMode</span>())</span><br></pre></td></tr></table></figure><h3 id="滚动到顶部"><a href="#滚动到顶部" class="headerlink" title="滚动到顶部"></a>滚动到顶部</h3><p>将元素滚动到顶部最简单的方法是使用scrollIntoView。设置block为start可以滚动到顶部；设置behavior为smooth可以开启平滑滚动。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">与滚动到顶部一样，滚动到底部只需要设置block为end即可。</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">scrollToBottom</span> = (<span class="params">element</span>) =&gt; </span><br><span class="line">  element.<span class="title function_">scrollIntoView</span>(&#123; <span class="attr">behavior</span>: <span class="string">&quot;smooth&quot;</span>, <span class="attr">block</span>: <span class="string">&quot;end&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><h3 id="检测元素是否在屏幕中"><a href="#检测元素是否在屏幕中" class="headerlink" title="检测元素是否在屏幕中"></a>检测元素是否在屏幕中</h3><p>检查元素是否在窗口中最好的方法是使用IntersectionObserver。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">callback</span> = (<span class="params">entries</span>) =&gt; &#123;</span><br><span class="line">  entries.<span class="title function_">forEach</span>(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">      <span class="comment">// `entry.target` is the dom element</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;entry.target.id&#125;</span> is visible`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="attr">threshold</span>: <span class="number">1.0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(callback, options);</span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> bottomBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;bottom-btn&quot;</span>);</span><br><span class="line">observer.<span class="title function_">observe</span>(btn);</span><br><span class="line">observer.<span class="title function_">observe</span>(bottomBtn);</span><br></pre></td></tr></table></figure><h3 id="检测设备"><a href="#检测设备" class="headerlink" title="检测设备"></a>检测设备</h3><p>使用navigator.userAgent来检测网站运行在哪种平台设备上。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">detectDeviceType</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">  <span class="regexp">/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i</span>.<span class="title function_">test</span>(</span><br><span class="line">    navigator.<span class="property">userAgent</span></span><br><span class="line">  ) ? <span class="string">&quot;Mobile&quot;</span> : <span class="string">&quot;Desktop&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">detectDeviceType</span>());</span><br></pre></td></tr></table></figure><h3 id="隐藏元素"><a href="#隐藏元素" class="headerlink" title="隐藏元素"></a>隐藏元素</h3><p>我们可以将元素的style.visibility设置为hidden，隐藏元素的可见性，但元素的空间仍然会被占用。如果设置元素的style.display为none，会将元素从渲染流中删除。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">hideElement</span> = (<span class="params">el, removeFromFlow = <span class="literal">false</span></span>) =&gt; &#123;</span><br><span class="line">  removeFromFlow ? (el.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">  : (el.<span class="property">style</span>.<span class="property">visibility</span> = <span class="string">&#x27;hidden&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从-URL-中获取参数"><a href="#从-URL-中获取参数" class="headerlink" title="从 URL 中获取参数"></a>从 URL 中获取参数</h3><p>JavaScript 中有一个 URL 对象，通过它可以非常方便的获取 URL 中的参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getParamByUrl</span> = (<span class="params">key</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(location.<span class="property">href</span>)</span><br><span class="line">  <span class="keyword">return</span> url.<span class="property">searchParams</span>.<span class="title function_">get</span>(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深拷贝对象"><a href="#深拷贝对象" class="headerlink" title="深拷贝对象"></a>深拷贝对象</h3><p>深拷贝对象非常简单，先将对象转换为字符串，再转换成对象即可。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">deepCopy</span> = obj =&gt; <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br></pre></td></tr></table></figure><p>除了利用 JSON 的 API，还有更新的深拷贝对象的 structuredClone API，但并不是在所有的浏览器中都支持。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">structuredClone</span>(obj)</span><br></pre></td></tr></table></figure><h3 id="等待函数"><a href="#等待函数" class="headerlink" title="等待函数"></a>等待函数</h3><p>JavaScript 提供了setTimeout函数，但是它并不返回 Promise 对象，所以我们没办法使用 async 作用在这个函数上，但是我们可以封装等待函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">wait</span> = (<span class="params">ms</span>) =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">asyncFn</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">wait</span>(<span class="number">1000</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;等待异步函数执行结束&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncFn</span>()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的深度与广度优先遍历</title>
      <link href="/2022/09/24/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%B8%8E%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
      <url>/2022/09/24/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%B8%8E%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="深度优先遍历算法口诀"><a href="#深度优先遍历算法口诀" class="headerlink" title="深度优先遍历算法口诀"></a>深度优先遍历算法口诀</h2><ul><li>访问根节点</li><li>对根节点的没访问过相邻节点挨个进行深度优先遍历<br>code<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> graph=&#123;</span><br><span class="line">    <span class="number">0</span>:[<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">    <span class="number">1</span>:[<span class="number">2</span>],</span><br><span class="line">    <span class="number">2</span>:[<span class="number">0</span>,<span class="number">3</span>],</span><br><span class="line">    <span class="number">3</span>:[<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">dfs</span>=(<span class="params">n</span>)=&gt;&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n);<span class="comment">//访问根节点</span></span><br><span class="line">    visted.<span class="title function_">add</span>(n);<span class="comment">//访问过的做一个记录</span></span><br><span class="line">    graph[n].<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visted.<span class="title function_">has</span>(item))&#123;</span><br><span class="line">            <span class="title function_">dfs</span>(item);<span class="comment">//递归调用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">dfs</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//结果为   2  0  1  3</span></span><br></pre></td></tr></table></figure><h2 id="广度优先遍历算法口诀"><a href="#广度优先遍历算法口诀" class="headerlink" title="广度优先遍历算法口诀"></a>广度优先遍历算法口诀</h2></li><li>新建一个队列，把根节点入队</li><li>把队头出队并访问</li><li>把队头的没访问过的相邻节点入队</li><li>重复第二三步，直到队列为空<br>code<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> visited=<span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="keyword">const</span> q=[<span class="number">2</span>];<span class="comment">//根节点入队</span></span><br><span class="line">visited.<span class="title function_">add</span>(<span class="number">2</span>);<span class="comment">//添加到访问记录</span></span><br><span class="line"><span class="keyword">while</span>(q.<span class="property">length</span>)&#123;<span class="comment">//循环</span></span><br><span class="line">    <span class="keyword">const</span> n=q.<span class="title function_">shift</span>();<span class="comment">//队头出队并访问</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">    graph[n].<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;<span class="comment">//把队头没访问过的相邻节点入队</span></span><br><span class="line">        <span class="keyword">if</span>(!visited.<span class="title function_">has</span>(item))&#123;</span><br><span class="line">            q.<span class="title function_">push</span>(item);</span><br><span class="line">            visited.<span class="title function_">add</span>(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>执行结果<br><img src="https://s2.loli.net/2022/09/18/bnU753C1qlmox6L.png" alt="QQ截图20220918154348.png"></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>图是网络结构的抽象模型，是一组由边连接的节点</li><li>图可以表示任何二次元关系，比如道路，航班</li><li>JS中没有图，但是可以用，Object和Array构件图</li><li>图的表示法：邻接矩阵,邻接表</li><li>图的常用操作: 深度/广度优先遍历</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列,链表,集合,字典，树</title>
      <link href="/2022/09/17/%E9%98%9F%E5%88%97/"/>
      <url>/2022/09/17/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="用JS数组方法模拟队列"><a href="#用JS数组方法模拟队列" class="headerlink" title="用JS数组方法模拟队列"></a>用JS数组方法模拟队列</h2><p>队列实例演示视频，可以看出是先进先出</p><iframe height=419 width=745 src='https://player.youku.com/embed/XNTkwMjUzNjY2OA==' frameborder=0 allowfullscreen="true"></iframe><h2 id="JS异步中的任务队列"><a href="#JS异步中的任务队列" class="headerlink" title="JS异步中的任务队列"></a>JS异步中的任务队列</h2><ul><li>JS是单线程的，无法同时处理异步中的并发任务</li><li>使用任务队列先后处理异步任务</li></ul><h2 id="链表模拟"><a href="#链表模拟" class="headerlink" title="链表模拟"></a>链表模拟</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表  模拟</span></span><br><span class="line"><span class="keyword">const</span> a=&#123;<span class="attr">val</span>:<span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> b=&#123;<span class="attr">val</span>:<span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> c=&#123;<span class="attr">val</span>:<span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> d=&#123;<span class="attr">val</span>:<span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line">a.<span class="property">next</span>=b;</span><br><span class="line">b.<span class="property">next</span>=c;</span><br><span class="line">c.<span class="property">next</span>=d;</span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="keyword">let</span> p=a;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">val</span>);</span><br><span class="line">    p=p.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入 改变next指向</span></span><br><span class="line"><span class="keyword">const</span> e=&#123;<span class="attr">val</span>:<span class="string">&quot;e&quot;</span>&#125;;</span><br><span class="line">c.<span class="property">next</span>=e;</span><br><span class="line">e.<span class="property">next</span>=d;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">val</span>);</span><br><span class="line">    p=p.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除e</span></span><br><span class="line">c.<span class="property">next</span>=d;</span><br></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//去重</span></span><br><span class="line"><span class="keyword">const</span> arr=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr2=[...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];<span class="comment">//得到一个集合</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2);</span><br><span class="line"><span class="comment">//判断元素是否在集合中</span></span><br><span class="line"><span class="keyword">const</span> set=<span class="keyword">new</span> <span class="title class_">Set</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">has</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//求交集</span></span><br><span class="line"><span class="keyword">const</span> set2=<span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> set3=<span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> set2.<span class="title function_">has</span>(item);</span><br><span class="line">&#125;))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...set3]);</span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><ul><li>与集合类似，字典也是一种储存为一只的数据结构，但他是以键值对的形式来储存<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ES6总有字典，名为Map</span></span><br><span class="line"><span class="keyword">const</span> m=<span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line"><span class="comment">//删除字典</span></span><br><span class="line">m.<span class="title function_">delete</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">m.<span class="title function_">clear</span>(); </span><br><span class="line"><span class="comment">//改</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;awdawd&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2></li><li>一种分层数据抽象模型</li><li>前端工作中常见的树包括，DOM数，级联选择,树形控件<br>js 中没有树，但是可以用Object和Array构建数</li><li>树的常用操作，深度/广度操作<ul><li>深度优先遍历<br>   1.访问根节点<br>   2.对根节点的chidren挨个进行深度优先遍历<br>就是递归的使用<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tree=&#123;</span><br><span class="line">    <span class="attr">val</span>:<span class="string">&quot;根节点&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>:[&#123;</span><br><span class="line">        <span class="attr">val</span>:<span class="string">&quot;二级节点1&quot;</span>,</span><br><span class="line">        <span class="attr">children</span>:[&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="string">&quot;三级节点1&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>:[]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="string">&quot;三级节点2&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>:[]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        <span class="attr">val</span>:<span class="string">&quot;二级节点2&quot;</span>,</span><br><span class="line">        <span class="attr">children</span>:[&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="string">&quot;三级节点3&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>:[]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="string">&quot;三级节点4&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>:[]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        <span class="attr">val</span>:<span class="string">&quot;二级节点3&quot;</span>,</span><br><span class="line">        <span class="attr">children</span>:[&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="string">&quot;三级节点5&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>:[]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="string">&quot;三级节点6&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>:[]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">dfs</span>=(<span class="params">root</span>)=&gt;&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>);</span><br><span class="line">    root.<span class="property">children</span>.<span class="title function_">forEach</span>(dfs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">dfs</span>(tree);</span><br></pre></td></tr></table></figure>执行结果<br><img src="https://s2.loli.net/2022/09/17/minX4Qz2MsVFBlJ.png" alt="执行结果"></li></ul></li><li>广度优先遍历<ul><li>新建一个队列，把根节点入队</li><li>把队头出队，并访问</li><li>把对头的children挨个入队</li><li>重读第二，三步直到队列为空<br>接续用上述的tree使用广度优先遍历实现<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bfs=<span class="keyword">function</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="comment">//拿到队头</span></span><br><span class="line">    <span class="keyword">let</span> queue=[root];</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> n=queue.<span class="title function_">shift</span>();<span class="comment">//出队并访问</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">        <span class="comment">//把队头的children挨个入队</span></span><br><span class="line">        n.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">            queue.<span class="title function_">push</span>(item);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的前中后序遍历"><a href="#二叉树的前中后序遍历" class="headerlink" title="二叉树的前中后序遍历"></a>二叉树的前中后序遍历</h1></li></ul></li></ul><h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><ul><li>先序遍历算法口诀<ul><li>访问根节点</li><li>对根节点的左子树进行先序遍历</li><li>对根节点的右子树进行先序遍历</li></ul></li></ul><p>如下二叉树</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bt=&#123;</span><br><span class="line">    <span class="attr">val</span>:<span class="number">1</span>,</span><br><span class="line">   <span class="attr">left</span>:&#123;</span><br><span class="line">        <span class="attr">val</span>:<span class="number">2</span>,</span><br><span class="line">        <span class="attr">left</span>:&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="number">3</span>,</span><br><span class="line">            <span class="attr">left</span>:<span class="literal">null</span>,</span><br><span class="line">            <span class="attr">right</span>:<span class="literal">null</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">right</span>:&#123;</span><br><span class="line">            <span class="attr">val</span>:<span class="number">4</span>,</span><br><span class="line">            <span class="attr">left</span>:<span class="literal">null</span>,</span><br><span class="line">            <span class="attr">right</span>:<span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">right</span>:&#123;</span><br><span class="line">    <span class="attr">val</span>:<span class="number">5</span>,</span><br><span class="line">    <span class="attr">left</span>:&#123;</span><br><span class="line">        <span class="attr">val</span>:<span class="number">6</span>,</span><br><span class="line">        <span class="attr">left</span>:<span class="literal">null</span>,</span><br><span class="line">        <span class="attr">right</span>:<span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">right</span>:&#123;</span><br><span class="line">        <span class="attr">val</span>:<span class="number">7</span>,</span><br><span class="line">        <span class="attr">left</span>:<span class="literal">null</span>,</span><br><span class="line">        <span class="attr">right</span>:<span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=bt;</span><br></pre></td></tr></table></figure><p>根据算法口诀先序遍历</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> perorder=<span class="keyword">function</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment">//当子树不存在时退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>)<span class="comment">//访问根节点</span></span><br><span class="line">    <span class="title function_">perorder</span>(root.<span class="property">left</span>)<span class="comment">//对根节点的左子树进行遍历</span></span><br><span class="line">    <span class="title function_">perorder</span>(root.<span class="property">right</span>)<span class="comment">//对根节点的右子树进行遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/18/dVHLJOCIUrQKbGN.png" alt="QQ截图20220918085919.png">;<br>按照这个顺序进行遍历<br>得到<br><img src="https://s2.loli.net/2022/09/18/Ord5Uhp2lgqvTKW.png" alt="QQ截图20220918090811.png"></p><h2 id="中序遍历算法口诀"><a href="#中序遍历算法口诀" class="headerlink" title="中序遍历算法口诀"></a>中序遍历算法口诀</h2><ol><li>对根节点的左子树进行中序遍历</li><li>访问根节点</li><li>对根节点的右子树进行中序遍历<br>code实现<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> inorder=<span class="keyword">function</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">//判断</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">inorder</span>(root.<span class="property">left</span>)<span class="comment">//先访问左子树</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>)<span class="comment">//访问根节点</span></span><br><span class="line">    <span class="title function_">inorder</span>(root.<span class="property">right</span>)<span class="comment">//访问右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>遍历顺序图<br><img src="https://s2.loli.net/2022/09/18/UGCem8DWR7atn6o.png" alt="QQ截图20220918091819.png"><br>结果图<br><img src="https://s2.loli.net/2022/09/18/DfS3ZzAEIidNbn9.png" alt="QQ截图20220918091844.png"></li></ol><h2 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h2><ol><li>对根节点中的左子树进行遍历</li><li>对根节点的右子树进行遍历</li><li>访问根节点<br>code<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> backorder=<span class="keyword">function</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backorder</span>(root.<span class="property">left</span>);</span><br><span class="line">    <span class="title function_">backorder</span>(root.<span class="property">right</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>遍历顺序<br><img src="https://s2.loli.net/2022/09/18/pdosLHDP3RBNVuS.png" alt="QQ截图20220918092612.png"><br>结果；<br><img src="https://s2.loli.net/2022/09/18/5ayDoIKxzgvPcmO.png" alt="QQ截图20220918092620.png"><br>结果如图<br><img src="https://s2.loli.net/2022/09/17/xjUY4a9K2bX3uMT.png" alt="结果"></li></ol><h3 id="解压小视频"><a href="#解压小视频" class="headerlink" title="解压小视频"></a>解压小视频</h3><iframe height=419 width=745 src='https://player.youku.com/embed/XMzMxMjE0MjY4NA==' frameborder=0 allowfullscreen="true"></iframe>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈结构+一道算法</title>
      <link href="/2022/09/15/%E6%A0%88%E7%BB%93%E6%9E%84+%E7%AE%97%E6%B3%95/"/>
      <url>/2022/09/15/%E6%A0%88%E7%BB%93%E6%9E%84+%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-栈（stack）"><a href="#1-栈（stack）" class="headerlink" title="1.栈（stack）"></a>1.栈（stack）</h2><p><img src="https://s2.loli.net/2022/09/16/PSWIgxmMZ4RKpF9.png" alt="QQ截图20220916150957.png"></p><ol><li>它是一种受限制的线性表，后见先出</li></ol><ul><li>其限制是仅允许在表的一端进行插入和删除操作，这一段被称为<code>栈顶</code>相对地把另一端称为<code>栈底</code></li><li>LIFO表示就是后进入的元素，带一个弹出栈空间，类似于自动餐托盘最后放上托盘，往往先拿出去使用</li><li>向一个栈插入新元素又称作<code>进栈</code>，<code>入栈</code>，或者<code>压栈</code>，他是把新元素放到栈顶元素的上面，使之成为新的栈顶元素</li><li>从一个栈删除元素又称作<code>出栈</code>，或者<code>退栈</code>，他是把栈顶元素删掉，使其相邻的元素成为新的栈顶元素。<h2 id="2-栈结构的实现-例一"><a href="#2-栈结构的实现-例一" class="headerlink" title="2.栈结构的实现  例一"></a>2.栈结构的实现  例一</h2><img src="https://s2.loli.net/2022/09/16/TYaosZUxe2y8bIv.png" alt="QQ截图20220916173538.png"><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestValidParentheses = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxLen = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    stack.<span class="title function_">push</span>(-<span class="number">1</span>) <span class="comment">// 初始化一个参照物</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// ( 入栈   )出栈</span></span><br><span class="line">            stack.<span class="title function_">push</span>(i)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// )的情况 出栈</span></span><br><span class="line">            stack.<span class="title function_">pop</span>()</span><br><span class="line">            <span class="keyword">if</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="comment">// 每次出栈 计算下当前有效连续长度</span></span><br><span class="line">                <span class="comment">// 如何计算连续长度 当前位置 - 栈顶下标  并取值最大的有效长度</span></span><br><span class="line">                maxLen = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLen, i - stack[stack.<span class="property">length</span> - <span class="number">1</span>])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.<span class="title function_">push</span>(i) <span class="comment">//栈为空时 放入右括号参照物 表示从这个下标开始 需要重新计算长度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>利用栈结构解题<h3 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h3><img src="https://s2.loli.net/2022/09/19/rV46HcgxIdEjk5M.png" alt="QQ截图20220919102019.png"></li></ul><p>code</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>%<span class="number">2</span>===<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>  <span class="comment">//如果为奇数  不可能匹配</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> stack=[];<span class="comment">//创建一个空栈</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.<span class="property">length</span>;i++)&#123;<span class="comment">//遍历</span></span><br><span class="line">         <span class="keyword">const</span> c=s[i];<span class="comment">//取得字符</span></span><br><span class="line">         <span class="keyword">if</span>(c===<span class="string">&#x27;[&#x27;</span>||c===<span class="string">&#x27;&#123;&#x27;</span>||c===<span class="string">&#x27;(&#x27;</span>)&#123;<span class="comment">//将右括号入栈，碰到对应的左括号出战</span></span><br><span class="line">             stack.<span class="title function_">push</span>(c);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">const</span> top=stack[stack.<span class="property">length</span>-<span class="number">1</span>];<span class="comment">//取出栈顶元素</span></span><br><span class="line">            <span class="keyword">if</span>((top===<span class="string">&quot;&#123;&quot;</span>&amp;&amp;c==<span class="string">&#x27;&#125;&#x27;</span>)||(top===<span class="string">&quot;(&quot;</span>&amp;&amp;c==<span class="string">&#x27;)&#x27;</span>)||(top===<span class="string">&quot;[&quot;</span>&amp;&amp;c===<span class="string">&#x27;]&#x27;</span>))&#123;    <span class="comment">//如果栈顶元素与之匹配，则出栈</span></span><br><span class="line">                stack.<span class="title function_">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//不匹配直接退出</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//最后判断以下栈中是否有匹配剩下的  有则匹配失败   无则匹配成功</span></span><br><span class="line">     <span class="keyword">return</span> stack.<span class="property">length</span>===<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="JS中的函数调用堆栈"><a href="#JS中的函数调用堆栈" class="headerlink" title="JS中的函数调用堆栈"></a>JS中的函数调用堆栈</h3><p><strong>演示视频</strong></p><iframe height=419 width=745 src='https://player.youku.com/embed/XNTkwNDc3NTQ2MA==' frameborder=0 allowfullscreen='true'></iframe>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS语言基础（一）</title>
      <link href="/2022/09/15/JS%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/09/15/JS%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-严格模式"><a href="#1-严格模式" class="headerlink" title="1.严格模式"></a>1.严格模式</h2><p>严格模式是一种不同的javascript解析和执行的模型，如果要对整个脚本开启严格模式在脚本开头加上<code>use strict</code>虽然看起来没有复制给任何变量的字符串吗，但它其实是一个预处理指令，任何支持JavaScript的引擎看到就会切换到严格模式，</p><h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h2><ul><li>var关键字</li><li>let关键字</li><li>const关键字<h2 id="3-暂时性死区"><a href="#3-暂时性死区" class="headerlink" title="3.暂时性死区"></a>3.暂时性死区</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//name会被提升</span><br><span class="line">console.log(name);//undefined</span><br><span class="line">var name=&quot;小明&quot;;</span><br><span class="line">//name不会提升</span><br><span class="line">console.log(name)//报错</span><br><span class="line">let name=&quot;小明&quot;;</span><br></pre></td></tr></table></figure>在let声明之前的执行瞬间被称为。暂时性死区，在此阶段引用任何后面声明的变量都会抛出<code>ReferenceError</code><h2 id="4-全局声明"><a href="#4-全局声明" class="headerlink" title="4.全局声明"></a>4.全局声明</h2>与var关键字不同，使用let在全局作用域中声明的变量不会成为window对象的属性（var声明的变量则会）;<h2 id="声明风格及最佳实践"><a href="#声明风格及最佳实践" class="headerlink" title="声明风格及最佳实践"></a>声明风格及最佳实践</h2></li><li>不使用var </li><li>const优先 ，let次之</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS基础复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript, </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺时针打印矩阵JS版</title>
      <link href="/2022/09/15/%E5%89%91%E6%8C%87%20Offer%2029.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5(JS%E7%89%88)/"/>
      <url>/2022/09/15/%E5%89%91%E6%8C%87%20Offer%2029.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5(JS%E7%89%88)/</url>
      
        <content type="html"><![CDATA[<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">matrix</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> spiralOrder = <span class="keyword">function</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.<span class="property">length</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(matrix[<span class="number">0</span>].<span class="property">length</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向右  获取长和宽 </span></span><br><span class="line">    <span class="keyword">let</span> height=matrix.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> width=matrix[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> result=[];</span><br><span class="line">    <span class="comment">//向右打印</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;width;i++)&#123;</span><br><span class="line">       result.<span class="title function_">push</span>(matrix[<span class="number">0</span>][i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果有向下的，则向下 不能则返回结果</span></span><br><span class="line">   <span class="keyword">if</span>(height&gt;<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> k=<span class="number">1</span>;k&lt;height;k++)&#123;</span><br><span class="line">           result.<span class="title function_">push</span>(matrix[k][width-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果能向左就向左 不能则返回结果</span></span><br><span class="line">   <span class="keyword">if</span>(width&gt;<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> i=width-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">           result.<span class="title function_">push</span>(matrix[height-<span class="number">1</span>][i]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果能向上 则向上，不能则返回结果</span></span><br><span class="line">   <span class="keyword">if</span>(height&gt;<span class="number">2</span>)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> i=height-<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">           result.<span class="title function_">push</span>(matrix[i][<span class="number">0</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//剥除里面的矩阵  (循环一次减掉两层高度)</span></span><br><span class="line">    <span class="keyword">let</span> inner=<span class="keyword">new</span> <span class="title class_">Array</span>(height-<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;height-<span class="number">2</span>;i++)&#123;</span><br><span class="line">        inner[i]=matrix[i+<span class="number">1</span>].<span class="title function_">slice</span>(<span class="number">1</span>,width-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    result=result.<span class="title function_">concat</span>(<span class="title function_">spiralOrder</span>(inner));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS基础</title>
      <link href="/2022/09/15/JS%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/09/15/JS%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="script元素"><a href="#script元素" class="headerlink" title="script元素"></a>script元素</h1><ol><li>async:可选，表示应该立即开始下载脚本，但是不能阻止其他页面动作，比如下载资源挥着等待其他脚本加载，只对外部脚本有效，</li><li>charset：可选，使用src指定的代码字符集，这个属性很少使用，大多数浏览器不在乎它的值。</li><li>corssorigin:可选，配置相关请求的cors（跨源资源共享）设置，默认不使用CORS,     crossorigin=”use-credentials”设置凭据标志，意味着出站请求会包含凭据，</li><li>defer:可选。表示在问达能解析和显示完成后，再执行脚本是没有有问题的。只对外部脚本有效，</li><li>integrity:可选允许比对接收到的资源和指定的加密协议以验证子资源的完整性，如果接受到的资源的签名，与这个属性指定的签名不匹配则页面报错,脚本不会执行，这个属性可以用与确保内容分发网络不会提供恶意内容</li><li>src:可选。表示要执行的代码的外部文件</li><li>type:可选，用于指定代码块中的语言类型，按照管理，这个始终都是“text/JavaScript”。如果这个值时“module”则代码会被当成ES6模块，<br>包含在script标签里的内容，会从上至下解释，在&lt;\script&gt;元素中的代码被执行完毕之前，页面的其余内容不会被加载，也不会被显示，就形成了阻塞<br>在使用行内&lt;\script&gt;代码时，注意代码中崩出现字符串&lt;\script&gt;。比如以下代码，<br>会导致浏览器报错，浏览器解析行内脚本会将其当乘结束的&lt;\script&gt;的&lt;\script&gt;标签，想避免这个问题，只需要转义字符\即可<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span>  <span class="title function_">msg</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&quot;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>这样修改之后就可以被浏览器完全解释，不会导致任何错误，</li><li>在解释外还不JavaScript文件时页面也会阻塞，（阻塞时间包括文件的下载时间，）在XHTML可以忽略结束标签，</li><li>另外使用了src属性的&lt;\script&gt;的元素不应该在其内部写入代码，如果两种方式都使用的话，则浏览器只会下载执行脚本，而忽略内部代码，</li><li>&lt;\script&gt;最为强大，同时也备受争议的特性时，它可以包含来自外部域的JavaScript代码，与img的src很像<br>“&lt;\script src=’<a href="http://www.baidu.com&/#39;&gt;">www.baidu.com&#39;&gt;</a>&lt;\script&gt;”</li></ol><p>浏览器在计息这个资源时，会向SRC指定的地址发送一个get请求，以取得相应资源，这个初始的请求不受浏览器同源策略限制，但返回被执行的JS代码则受限制，当然请求仍然收父页面HTTP/HTTPS协议的限制</p><p>这就可能收到恶意的攻击，如果引用了别人服务器上的JS文件，就要格外小心，因为恶意的程序员，随时可能替换这个文件，在百翰外部与的JS文件时，要确保该域是自己所有的，或者该域是一个可靠的来源，&lt;\script&gt;时防范这种问题的一个武器，但是不是所有的浏览器都支持，这个属性，</p><p>不管包含的是什么代码，浏览器都会按照&lt;\script&gt;在页面中出现的顺序依次去解析他们，前提是他们没有使用defer和async属性，第二个&lt;\script&gt;代码会在第一个&lt;\script&gt;执行完毕之后进行，第三个会在第二个执行完毕之后进行，依次类推。</p><h1 id="标签位置"><a href="#标签位置" class="headerlink" title="标签位置"></a>标签位置</h1><ol><li>过去所有的&lt;\script&gt;元素都放在head标签内部，如下面的例子，<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">   <span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">HTML</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">title</span>&gt;</span>案例1<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">               这是页面内容</span><br><span class="line">            <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">HTML</span>&gt;</span></span><br><span class="line">```   </span><br><span class="line">这种做法的主要目的，就是把外部的CSS和JavaScript文件都集中到一起，不过把所有JavaScript文件都放在头部，也就意味着必须把所有的JavaScript文件都加载完毕才会开始渲染页面，对于需要很多JavaScript文件的页面这回导致，渲染时间明显变长，在此期间页面窗口完全空白，为解决这个问题，现代web应用程序将所有的Javascript引用放到了&lt;\body&gt;元素中的页面内容之后，如下</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">   <span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">HTML</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">title</span>&gt;</span>案例1<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">               这是页面内容</span><br><span class="line">            <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">HTML</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>推迟执行脚本<br>defer属性，这个属性表示这个脚本在执行的时候不会改变页面结构，完全可以等到整个页面解析完成以后，再运行，这个属性会告诉浏览器，应该立即下载，但执行会延迟，会等待html标签执行完毕之后，再执行</li><li>异步执行脚本<br>async   async与defer相似，都只是用与外部脚本，都会告诉浏览器立即开始下载，不过与defer不同的是，async并不能保证能按照出现的顺序执行，<br>给脚本添加async的目的是告诉浏览器 ，不必等待脚本下载和执行完毕再加载页面，同样也不必等待脚本下载执行完毕。再去执行其他脚本，正因为如此异步脚本不应该在加载期间修改DOM</li></ol><p>4.动态加载脚本</p><p>这个方式不推荐，很影响性能，而且会造成混乱。</p><p>5.行内代码，与外部文件</p><p>这两种方式，比较推荐外部文件，有以下优点</p><p>一.可维护性</p><p>二.缓存，如果两个html文件用到相同的JS文件，浏览器会根据缓存机制，只加载一次。意味着网页的加载速度更快</p><p>三.适应未来，</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>websocket基础</title>
      <link href="/2022/09/10/websocket%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/09/10/websocket%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1-传统的是HTTP模式，"><a href="#1-传统的是HTTP模式，" class="headerlink" title="1.传统的是HTTP模式，"></a>1.传统的是HTTP模式，</h1><p>因为 HTTP 协议有一个缺陷：通信只能由客户端发起 一个request对应一个respond<br>通信是单向的，请求==响应<br>没有请求就没有响应，举个例子：就比如我需要查询天气，只能是从客户端发送请求，接受查询结果。HTTP做不到主动向客户端推送信息，这种单向的请求的特点，注定如果服务器有连续的状态变化，客户端想要及时了解就很不方便，只能通过轮询的方式实现，这样是非常浪费资源的因为需要不停的连接,所以发明了websocket </p><h1 id="2-websocket"><a href="#2-websocket" class="headerlink" title="2.websocket"></a>2.websocket</h1><p>websocket 是一种网络传输协议，可在单个TCP连接进行全双工通信，位于OSI模型的应用层<br>最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话<br>特点：</p><ol><li>TCP连接，与HTTP协议兼容</li><li>双向通信，主动推送（服务端向客户端）</li><li>无同源限制，协议标识符是WS（加密wss）</li></ol><p>应用场景：</p><ul><li><input checked="" disabled="" type="checkbox"> 聊天，消息，点赞，</li><li><input checked="" disabled="" type="checkbox"> 直播弹幕</li><li><input checked="" disabled="" type="checkbox"> 游戏，协同编辑，基于位置的应用</li></ul><h1 id="原生websocket-的简单使用案例"><a href="#原生websocket-的简单使用案例" class="headerlink" title="原生websocket 的简单使用案例"></a>原生websocket 的简单使用案例</h1><p>我使用的node.js平台做的一个服务端，开启websocket服务<br>在sever.js文件中 ,建立服务先安装ws模块<br><code>npm i ws</code><br>在sever.js中</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">WebSocket</span>=<span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);<span class="comment">//引入模块</span></span><br><span class="line"><span class="keyword">const</span> wss=<span class="keyword">new</span> <span class="title class_">WebSocket</span>.<span class="title class_">Server</span>(&#123;<span class="attr">port</span>:<span class="number">3000</span>&#125;);<span class="comment">//监听本地3000端口</span></span><br><span class="line">wss.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>,<span class="function">(<span class="params">ws</span>)=&gt;</span>&#123;<span class="comment">//对连接进行监听</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;监听到服务&quot;</span>);</span><br><span class="line">    ws.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>,<span class="function">(<span class="params">msg</span>)=&gt;</span>&#123;<span class="comment">//同时接受客户端发送的信息</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">    &#125;)</span><br><span class="line">    ws.<span class="title function_">send</span>(<span class="string">&#x27;我是服务端&#x27;</span>);<span class="comment">//向客户端发送的信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>服务端建立好之后接下载，看客户端<br>新建一个HTML文件</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// WebSocket通信测试网址</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> ws=<span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;http://127.0.0.1:3000&#x27;</span>);<span class="comment">//连接本地测试地址</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//实例对象的onopen属性，用于指定连接成功后的回调函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//如果要指定多个回调函数，可以使用addEventListener方法。</span></span></span><br><span class="line"><span class="language-javascript">        ws.<span class="property">onopen</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">lgo</span>(<span class="string">&quot;连接建立成功！&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//建立成功之后 可以使用这个连接对象进行通信发送消息</span></span></span><br><span class="line"><span class="language-javascript">           ws.<span class="title function_">send</span>(<span class="string">&#x27;我是客户端&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        ws.<span class="property">onmessage</span>=<span class="keyword">function</span>(<span class="params">msg</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(msg.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来在控制台输入<code>node sever.js</code>来启动服务<br>在浏览器控制台可以看到<br><img src="https://img-blog.csdnimg.cn/bf21920e35cb4b79ab4f4d5275dd9698.png#pic_center" alt="客户端结果"><br>连接成功，并接收到服务端发来的消息<br>websocket有很多API </p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器(iterator)原理</title>
      <link href="/2022/09/03/%E8%BF%AD%E4%BB%A3%E5%99%A8(iterator)%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/03/%E8%BF%AD%E4%BB%A3%E5%99%A8(iterator)%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><strong>目录</strong></p><p><a href="#1.iterator%E4%BB%8B%E7%BB%8D%C2%A0%20%C2%A0">1.iterator介绍   </a></p><p><a href="#2.itertor%E4%BD%9C%E7%94%A8%C2%A0%20%C2%A0%20%C2%A0%C2%A0">2.itertor作用      </a></p><p><a href="#3.iterator%E7%9A%84%E9%81%8D%E5%8E%86%E5%8E%9F%E7%90%86">3.iterator的遍历原理</a></p><hr><h2 id="1-iterator介绍"><a href="#1-iterator介绍" class="headerlink" title="1.iterator介绍"></a>1.iterator介绍</h2><p>iterator是一种接口，为各种不同数据结构提供一种统一的访问机制，任何数据只要部署iterator接口，就可以完成遍历操作，</p><h2 id="2-itertor作用"><a href="#2-itertor作用" class="headerlink" title="2.itertor作用"></a><strong>2.itertor作用</strong></h2><p> iterator的作用有三个：一是为各种数据结构，提供一个统一的，简便的访问接口；二是使得数据结构的成员能够按照某种次序排列，三是ES6创造了一种新的遍历命令for···of循环，iterator接口主要供for···of消费</p><h2 id="3-iterator的遍历原理"><a href="#3-iterator的遍历原理" class="headerlink" title="3.iterator的遍历原理"></a>3.iterator的遍历原理</h2><p>(1) 创建一个指针对象，指向当前数据结构的起始位置，也就是说，遍历器本质上是一个指针对象</p><p>(2) 第一次调用指针对象的next 方法   可以将指针指向数据结构的第一个成员</p><p>(3) 第二次调用指针对象的next方法   指针对象将指向数据结构的第二个成员</p><p>(4) 不断调用指针对象的next方法， 直到它指向数据结构的结束位置，每一次调用next方法，都会返回数据结构的当前成员信息，具体来说就是返回一个包含value和done  两个属性的对象其中value是当前成员的值，done属性是一个布尔值  ，表示遍历是否结束</p><p><strong>模拟例子</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> it = <span class="title function_">makeIterator</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]);</span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;a&quot;, done: false &#125;</span></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;b&quot;, done: false &#125;</span></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeIterator</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.<span class="property">length</span> ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">        &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>makeIterator是一个迭代器生成函数，作用就是返回一个遍历器对象，对数组[‘a’,’b’]  执行这个函数</p><p>返回该数组的迭代器对象（即指针对象）</p><p> 2021字节跳动web工程师笔试题</p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><blockquote><p>[<br>{num: 12, city: ‘beijing’},<br>{num: 56, city: ‘shanghai’},<br>{num: 167, city: ‘guangzhou’},<br>{num: 23, city: ‘shenzhen’},<br>{num: 45, city: ‘caoxian’}<br>]<br>写一个方法实现把上面的数组转换成下面这种格式：<br>{beijing: 12, shanghai: 56,…}</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = [</span><br><span class="line">           &#123;<span class="attr">num</span>: <span class="number">12</span>, <span class="attr">city</span>: <span class="string">&#x27;beijing&#x27;</span>&#125;,</span><br><span class="line">           &#123;<span class="attr">num</span>: <span class="number">56</span>, <span class="attr">city</span>: <span class="string">&#x27;shanghai&#x27;</span>&#125;,</span><br><span class="line">           &#123;<span class="attr">num</span>: <span class="number">167</span>, <span class="attr">city</span>: <span class="string">&#x27;guangzhou&#x27;</span>&#125;,</span><br><span class="line">           &#123;<span class="attr">num</span>: <span class="number">23</span>, <span class="attr">city</span>: <span class="string">&#x27;shenzhen&#x27;</span>&#125;,</span><br><span class="line">           &#123;<span class="attr">num</span>: <span class="number">45</span>, <span class="attr">city</span>: <span class="string">&#x27;caoxian&#x27;</span>&#125;</span><br><span class="line">               ]</span><br><span class="line">           <span class="keyword">let</span> res=&#123;&#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;obj.<span class="property">length</span>;i++)&#123;</span><br><span class="line">               res[obj[i].<span class="property">city</span>]=obj[i].<span class="property">num</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure><p>遍历数组添加到对象就行了</p><p>        本周主要进行了复习，对JS基础  JS高级  ES6进行了回顾  剩余时间在学习Vue  加油！</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回顾express</title>
      <link href="/2022/08/14/%E5%9B%9E%E9%A1%BEexpress/"/>
      <url>/2022/08/14/%E5%9B%9E%E9%A1%BEexpress/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="1-express-是什么"><a href="#1-express-是什么" class="headerlink" title="1.express 是什么"></a>1.express 是什么</h2><p>Express 是一个基于 <a href="https://so.csdn.net/so/search?q=Node&spm=1001.2101.3001.7020" title="Node">Node</a>平台的Web应用开发框架，它提供了一系列的强大特性，帮助你创建各种Web应用。</p><h2 id="2-Express-框架特性"><a href="#2-Express-框架特性" class="headerlink" title="2 .Express 框架特性"></a>2 .Express 框架特性</h2><ul><li>提供了<strong>简洁的路由定义</strong>方式</li><li>对获取 http <strong>请求参数</strong>进行了<strong>简化处理</strong></li><li>对<strong>模板引擎支持程度高</strong>，方便渲染动态HTML页面</li><li>拥有<strong>中间件</strong>机制有效<strong>控制 HTTP 请求</strong></li><li>拥有大量第三方中间件对功能进行扩展</li></ul><h2 id="3-原生-node-js-与-Express-框架对比"><a href="#3-原生-node-js-与-Express-框架对比" class="headerlink" title="3 .原生 node.js 与 Express 框架对比"></a>3 .原生 node.js 与 Express 框架对比</h2><p><img src="https://img-blog.csdnimg.cn/422f6da8b6d34336ae69e70859163419.png" alt="422f6da8b6d34336ae69e70859163419.png"></p><p><img src="https://img-blog.csdnimg.cn/e9c435389c0542b5b5da8e592be66431.png" alt="e9c435389c0542b5b5da8e592be66431.png"> </p><h2 id="4-中间件"><a href="#4-中间件" class="headerlink" title="4.中间件"></a>4.中间件</h2><p> </p><p><img src="https://img-blog.csdnimg.cn/55bd7475882742339b921dc03a8d95e8.png" alt="55bd7475882742339b921dc03a8d95e8.png"></p><p><img src="https://img-blog.csdnimg.cn/647096f6d82246239deb7a99732285b2.png" alt="647096f6d82246239deb7a99732285b2.png"> </p><p><img src="https://img-blog.csdnimg.cn/27cf49b6412f40669e23658c0d81748b.png" alt="27cf49b6412f40669e23658c0d81748b.png"> </p><h2 id="5-中间件应用"><a href="#5-中间件应用" class="headerlink" title="5  中间件应用"></a>5  中间件应用</h2><h3 id="路由保护："><a href="#路由保护：" class="headerlink" title="路由保护："></a>路由保护：</h3><p>客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。</p><p>错误处理中间件</p><p>  本周还是对项目的完善，使之更加严谨可用，</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓展运算符是深拷贝还是浅拷贝</title>
      <link href="/2022/08/07/%E6%8B%93%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%BF%98%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2022/08/07/%E6%8B%93%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%BF%98%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>对于拓展运算符是深拷贝还是浅拷贝网上怎么说的都有，我就说一下我的理解。</p><p><strong>什么是深拷贝？什么是浅拷贝？</strong></p><p>假如B复制了A，修改A的时候，看B是否发生变化：</p><p>如果B也跟着<strong>变</strong>了，说明是浅拷贝，拿别人手段！</p><p>如果B<strong>没有改变</strong>，说明是深拷贝，自食其力！</p><p><strong>怎么判断拓展运算符是什么拷贝呢？</strong></p><p>看一下下面的例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"> <span class="keyword">let</span> b = [...a];</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//[1,2,3]</span></span><br><span class="line"> a[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//[1,4,3]</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure><p>结合浅拷贝和深拷贝的概念，那拓展运算符是不是深拷贝？别急看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> peoples = [&#123;<span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">sex</span>:<span class="string">&quot;男&quot;</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&#x27;ls&#x27;</span>,<span class="attr">age</span>:<span class="number">16</span>,<span class="attr">sex</span>:<span class="string">&quot;女&quot;</span>&#125;];</span><br><span class="line">  <span class="keyword">let</span> peoplesTwo = [...peoples];</span><br><span class="line">  peoples[<span class="number">0</span>].<span class="property">age</span> = <span class="number">22</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(peoples);<span class="comment">//[&#123;name:&#x27;zs&#x27;,age:22,sex:&quot;男&quot;&#125;,&#123;name:&#x27;ls&#x27;,age:16,sex:&quot;女&quot;&#125;]</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(peoplesTwo);<span class="comment">//[&#123;name:&#x27;zs&#x27;,age:22,sex:&quot;男&quot;&#125;,&#123;name:&#x27;ls&#x27;,age:16,sex:&quot;女&quot;&#125;]</span></span><br></pre></td></tr></table></figure><p>结合浅拷贝和深拷贝的概念，那拓展运算符是不是浅拷贝？</p><p>所以结合上面两个例子得出一个结论，拓展运算符是深拷贝还是浅拷贝是看具体拷贝内容的，当拷贝的内容只有一层时是深拷贝，层数很多时时浅拷贝，如果还是不太理解可以先看深拷贝和浅拷贝的定义然后自己手敲一下代码，</p><p>        加油</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript vue.js 开发语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目总结篇</title>
      <link href="/2022/07/31/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E7%AF%87/"/>
      <url>/2022/07/31/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>        从开始项目到现在也快40天了，在这个过程中不得不说，交流真的很重要，要是交流多一点，项目估计早就完成了，找bug也找的差不多了，项目现在还有些功能不太完善，学分认证系统功能应该朝着实用性，和安全性出发，这是最重要的，还有交互体验很重要，能够简单明了的一眼看出网站的使用规则，而不是功能隐藏起来，轻松上手，快速使用。</p><p>        项目bug正在修复，代码嵌入，功能失效·······啥的，正在改,还有交互体验上，各种信息的提示需要做出来，给用户足够的反馈信息。明白咋回事，</p><p>        学习方面，主要还是项目经验吧，还有各种第三方工具的使用，接下来继续努力，加油</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 java html 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS通过文件URL路径下载文件</title>
      <link href="/2022/07/24/JS%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6URL%E8%B7%AF%E5%BE%84%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/"/>
      <url>/2022/07/24/JS%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6URL%E8%B7%AF%E5%BE%84%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">exportFile</span> <span class="operator">=</span> (data, fileName, _this)=&gt;&#123;</span><br><span class="line">　<span class="comment">// 地址不存在时，禁止操作</span></span><br><span class="line">  <span class="keyword">if</span>(!data)<span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 下载文件并保存到本地</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">callback</span> <span class="operator">=</span> (data)=&gt;&#123;</span><br><span class="line">　　 <span class="comment">// 创建a标签，使用 html5 download 属性下载，</span></span><br><span class="line">    <span class="type">const</span> <span class="variable">link</span> <span class="operator">=</span> document.createElement(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">　　 <span class="comment">// 创建url对象</span></span><br><span class="line">    <span class="type">const</span> <span class="variable">objectUrl</span> <span class="operator">=</span> window.URL.createObjectURL(<span class="keyword">new</span> <span class="title class_">Blob</span>([data]));</span><br><span class="line">    link.style.display=<span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    link.href=objectUrl;</span><br><span class="line">　　 <span class="comment">// 自定义文件名称， fileName</span></span><br><span class="line">　　 link.download = fileName; </span><br><span class="line">　　 document.body.appendChild(link); </span><br><span class="line">　　 link.click();</span><br><span class="line">　　 <span class="comment">// 适当释放url</span></span><br><span class="line">    window.URL.revokeObjectURL(objectUrl);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 把接口返回的url地址转换为 blob</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">xhr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.open(<span class="string">&#x27;get&#x27;</span>, data, <span class="literal">true</span>);</span><br><span class="line">  xhr.responseType = <span class="string">&#x27;blob&#x27;</span>;</span><br><span class="line">  xhr.onload = ()=&gt; &#123;</span><br><span class="line">　　 <span class="comment">// 返回文件流，进行下载处理</span></span><br><span class="line">    callback(xhr.response);</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.send(); <span class="comment">// 不要忘记发送</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ie和浏览器兼容模式会有问题，可以用下面代码调试。</span></span><br><span class="line">　<span class="keyword">try</span>&#123;</span><br><span class="line">    exportFile(); <span class="comment">// 调用方式</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="comment">// 兼容模式下，IE</span></span><br><span class="line">    <span class="type">const</span> <span class="variable">exportBlob</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Blob</span>([data]);</span><br><span class="line">    <span class="keyword">if</span> (navigator.userAgent.indexOf(<span class="string">&#x27;Trident&#x27;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      window.navigator.msSaveBlob(data, fileName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      exportFile(); <span class="comment">// 调用方式</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>调用方式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">exportFile</span>(<span class="string">&#x27;https://reading.oss.iyougu.com/uploads/mp/opus/1c5a8b6a391742cf93595d0a506b2d43.mp3&#x27;</span>, <span class="string">&#x27;测试.mp3&#x27;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript 前端 开发语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="/2022/07/17/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/17/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><strong>一、基本命令</strong><br>1.1 关机和重启<br>关机<br>    shutdown -h now        立刻关机<br>    shutdown -h 5        5分钟后关机<br>    poweroff            立刻关机<br>重启<br>    shutdown -r now        立刻重启<br>    shutdown -r 5        5分钟后重启<br>    reboot                立刻重启</p><h2 id="1-2-帮助命令"><a href="#1-2-帮助命令" class="headerlink" title="1.2 帮助命令"></a>1.2 帮助命令</h2><p>--help命令<br>  shutdown --help：<br>  ifconfig  --help：查看网卡信息<br> <br>man命令（命令说明书） <br>  man shutdown<br>  注意：man shutdown打开命令说明书之后，使用按键q退出</p><p><strong>二、目录操作命令</strong><br>2.1 目录切换 cd<br>命令：cd 目录</p><p>cd /        切换到根目录<br>cd /usr        切换到根目录下的usr目录<br>cd ../        切换到上一级目录 或者  cd ..<br>cd ~        切换到home目录<br>cd -        切换到上次访问的目录</p><p><strong>2.2 目录查看 ls [-al]</strong><br>命令：ls [-al]</p><p>ls                查看当前目录下的所有目录和文件<br>ls -a            查看当前目录下的所有目录和文件（包括隐藏的文件）<br>ls -l 或 ll       列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）<br>ls /dir            查看指定目录下的所有目录和文件   如：ls /usr</p><p><strong>2.3 目录操作【增，删，改，查】</strong><br>2.3.1 创建目录【增】 mkdir<br>命令：mkdir 目录</p><p>mkdir    aaa            在当前目录下创建一个名为aaa的目录<br>mkdir    /usr/aaa    在指定目录下创建一个名为aaa的目录</p><p><strong>2.3.2 删除目录或文件【删】rm</strong><br>命令：rm [-rf] 目录</p><p>删除文件：<br>rm 文件        删除当前目录下的文件<br>rm -f 文件    删除当前目录的的文件（不询问）</p><p>删除目录：<br>rm -r aaa    递归删除当前目录下的aaa目录<br>rm -rf aaa    递归删除当前目录下的aaa目录（不询问）</p><p>全部删除：<br>rm -rf *    将当前目录下的所有目录和文件全部删除<br>rm -rf /*    【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除</p><p>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录/文件/压缩包   </p><p>正在学习，，，</p><p>本周呢，还是以项目为主又完成了一些功能，马上就能做完了，加油</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本周学习总结</title>
      <link href="/2022/07/03/%E6%9C%AC%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/03/%E6%9C%AC%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>        </p><h2 id="1使用-Bootstrap-构建快速、响应式布局的网站"><a href="#1使用-Bootstrap-构建快速、响应式布局的网站" class="headerlink" title="1使用 Bootstrap 构建快速、响应式布局的网站"></a><strong>1使用 Bootstrap 构建快速、响应式布局的网站</strong></h2><p><a href="https://so.csdn.net/so/search?q=Bootstrap&spm=1001.2101.3001.7020" title="Bootstrap">Bootstrap</a> 是全球最流行的前端开源工具包，它支持 Sass 变量和 mixins、响应式网格系统、大量的预建组件和强大的 JavaScript 插件，助你快速设计和自定义响应式、移动设备优先的站点。</p><h2 id="2-布局容器"><a href="#2-布局容器" class="headerlink" title="** 2.布局容器**"></a>** 2.布局容器**</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span><br><span class="line">.<span class="property">container</span>-<span class="attr">fluid</span>:横跨视口的全宽度的容器。</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    .container：有最大固定宽度的容器。最大固定宽度依据于视口（viewport）的断点（breakpoints）而不同。</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="3-网格系统"><a href="#3-网格系统" class="headerlink" title="3.网格系统"></a>3.网格系统</h2><p>Bootstrap 4 网格系统有以下 5 个类:</p><p>.col- 针对所有设备<br>.col-sm- 平板 - 屏幕宽度等于或大于 576px<br>.col-md- 桌面显示器 - 屏幕宽度等于或大于 768px)<br>.col-lg- 大桌面显示器 - 屏幕宽度等于或大于 992px)<br>.col-xl- 超大桌面显示器 - 屏幕宽度等于或大于 1200px)<br>        这周主要就是学习使用了<strong>Bootstrap5</strong> 写网页，学习了使用axios 对第三方接口进行请求，统一配置请求头，请求拦截器，响应拦截器，对错误代码同意管理，接下来就是尽量熟练的使用axios,完成交互任务，��数据做点什么<br>    return response;<br>  }, function (error) {<br>    // 对响应错误做点什么<br>    return Promise.reject(error);<br>  });<br>```</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本周学习笔记</title>
      <link href="/2022/06/26/%E6%9C%AC%E5%91%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/06/26/%E6%9C%AC%E5%91%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>一、node.js简介</p><p> </p><p>1.Node.js是一个能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境。</p><p>2.Node采用Google开发的V8引擎运行js代码，使用事件驱动、非阻塞和异步I/O模型等技术来提高性能，可优化应用程序的传输量和规模。</p><p>3.Node大部分基本模块都用JavaScript编写。在Node出现之前，JS通常作为客户端程序设计语言使用，以JS写出的程序常在用户的浏览器上运行。</p><p>3.目前，Node已被IBM、Microsoft、Yahoo!、Walmart、Groupon、SAP、 LinkedIn、Rakuten、PayPal、Voxer和GoDaddy等企业采用</p><p>4.Node主要用于编写像Web服务器一样的网络应用，这和PHP和Python是类似的。</p><p>但是Node与其他语言最大的不同之处在于，PHP等语言是阻塞的而Node是非阻塞的。</p><p>Node是事件驱动的。开发者可以在不使用线程的情况下开发出一个能够承载高并发的服务器。其他服务器端语言难以开发高并发应用，而且即使开发出来，性能也不尽人意。</p><p>Node正是在这个前提下被创造出来。</p><p>Node把JS的易学易用和Unix网络编程的强大结合到了一起。</p><p>5.Node.js允许通过JS和一系列模块来编写服务器端应用和网络相关的应用。</p><p>6.核心模块包括文件系统I/O、网络（HTTP、TCP、UDP、DNS、TLS/SSL等）、二进制数据流、加密算法、数据流等等。Node模块的API形式简单，降低了编程的复杂度。</p><p>7.使用框架可以加速开发。常用的框架有Express.js、Socket.IO和Connect等。Node.js的程序可以在Microsoft Windows、Linux、Unix、Mac OS X等服务器上运行。</p><p>8.Node.js也可以使用CoffeeScript、TypeScript、Dart语言，以及其他能够编译成JavaScript的语言编程。</p><p>二.Node.Js用途</p><p> </p><p>1.Web服务API，比如REST</p><p>实时多人游戏</p><p>2.后端的Web服务，例如跨域、服务器端的请求</p><p>3.基于Web的应用</p><p>多客户端的通信，如即时通信</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 javascript node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一周学习总结</title>
      <link href="/2022/06/19/%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2022/06/19/%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>这一周，按照学习计划学习了node.js及相关的内容，学习了一个简单的数据库，我感觉真的要是精通node.js那真的是非常厉害，几乎是想做什么就做什么，接下来我将会进行实践练习，加深理解，更加熟练的运用，该与对于项目结构的规范都要进行实践练习，</p><p>        这段时间的学习，感觉到挺充实的，相比整天在家玩耍好得多，每天按时规律起床,晚上出去跑个步，其余时间用来敲代码我感觉还是很好的，我的许多同学都外出打工了，确实能挣到很多钱，但是他们的能力在原地踏步，不羡慕他们，加油提升自己更重要</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PS学习总结</title>
      <link href="/2022/06/11/PS%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2022/06/11/PS%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>        这周对PS进行了基础的学习，简单的操作，抠图，蒙版的使用，调色，各种工具的使用都应经学会了，其实PS大有可学，因为我不是专业的，仅仅学习了PS的一点皮毛，这些皮毛就已经够我用的了，这是用来找新做东西用的，希望我能够为招新做点什么，让宣传海报更加具有吸引力，</p><p>        这周呢，在家学习感到是时间很是充足，想学什么都有时间，下一阶段要学习node.js这是一个用js做后端的一个基于V8的一个运行环境，感觉学完这个就能够自己做一整个项目了，既有前端，又有后端，我会更加努力的，这个的学习是对JS的基础的考验，平时会多看看红宝书，加强自己的基础知识，巩固一下，学好node.js,就想做什么就做什么了，自己一个人就能完成前后端的工作,加油，不过最近要把考试课复习一下，还有一场考试加油！</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目继续进行</title>
      <link href="/2022/05/15/%E9%A1%B9%E7%9B%AE%E7%BB%A7%E7%BB%AD%E8%BF%9B%E8%A1%8C/"/>
      <url>/2022/05/15/%E9%A1%B9%E7%9B%AE%E7%BB%A7%E7%BB%AD%E8%BF%9B%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>  这次的考核内容的完善项目，我准备把项目进行进一步的完善，改一改bug，这次新加的内容全部使用原生JS，除了ajax 用JQ其他的都使用原生的，本次后端使用了spring boot 这就要求我们要使用th前几天我对th进行了学习，现在项目到了后期阶段，想要全换成th是不太可能的，再写的内容尽量使用th，我会吸取上次的教训，把学长们提出的问题进行修复，使得页面看起来更加合理，各种内容的分页处理，增删改查，美食网站，我尽量让它看起来像美食网站，</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美食项目考核总结</title>
      <link href="/2022/05/08/%E7%BE%8E%E9%A3%9F%E9%A1%B9%E7%9B%AE%E8%80%83%E6%A0%B8%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/08/%E7%BE%8E%E9%A3%9F%E9%A1%B9%E7%9B%AE%E8%80%83%E6%A0%B8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>从项目开始到结束，经过了差不多一个月，项目功能基本实现，考核中，才知道自己原来还有很多问题没有考虑周到，这次之后我会格外注意，各种漏洞，要尽可能去想用户会怎么操作做这个页面，应对多种情况，防止一些操作直接使得网页崩溃，这次考核中出现的很多问题，例如用户界面的关注，收藏什么的没有做成分页的形式，导致内容很多的时候浏览器压力很大，导致崩溃，项目后续会进行完善，增加功能，同时修改原先的bug,增加更加人性化的操作，还有在css动画效果上，我会尽量使用原生的js,css去写动画效果，JQ只用一个ajax就够了，锻炼自己的能力，项目上我负责的是网站前台部分。整个部分的结构不复杂，应用的技术不是不是很难，这次主要锻炼一下使用promise的能力。才知道，promise的状态只能改变一次，要不就重新返回一个new promise</p><p>我们项目组三个人，两个前端，一个后端，合作起来还算可以，进度基本能够相互配合，这次考核学到很多东西，有了做项目的经验，团队合作，分工好，才能更高效的完成任务，前后端交流好,互相说明一下需求，交互起来更加容易，得心应手。这次的评论我做的不好，评论的回复，子评论的回复后显示，直接刷新整个评论，这样确实更简单了，但是确实多流量的浪费，如果评论有很多那么就会非常浪费资源，接下来我会尽量改进这个评论功能；</p><p>        考核中没有使用thymeleaf,这是应该会的，但是我不太会用，所以从一开始就没有用，到了中期再用也比较麻烦。下次有机会一定会用的，这个方法,thymeleaf的话，是在服务器渲染页面，而直接ajax是再客户端渲染页面，</p><p>        下一阶段，我计划加强自己的代码规范，尽量原生JS写所有的内容，加油</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 css3 html 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目最后总结</title>
      <link href="/2022/04/30/%E9%A1%B9%E7%9B%AE%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93/"/>
      <url>/2022/04/30/%E9%A1%B9%E7%9B%AE%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>        这次项目就快要结束了，项目希望这几天能够做完，做好，保质保量， 最后会进行bug测试，尽量使得项目能够像一个正常的网站能够正常使用，在这一周的的过程中，发现项目还是有点不够人性化，希望让用户用着舒服，不追求功能多么厉害，但是要好用，评论还差点，希望我能够顺利完成，之后会进行拓展功能的实现，后台希望能够尽快与网页主体实现正常功能。</p><p>其他也没什么说的</p><p>把我项目的工具库函数发出来吧</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getStyle</span>(<span class="params">obj, name</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">getComputedStyle</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">getComputedStyle</span>(obj, <span class="literal">null</span>)[name];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> obj.<span class="property">currentStyle</span>[name];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">imgup</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> file = obj.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line"><span class="keyword">let</span> name1 = obj.<span class="property">parentNode</span>.<span class="property">children</span>[<span class="number">0</span>];</span><br><span class="line">reader.<span class="title function_">readAsDataURL</span>(file);</span><br><span class="line">reader.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span><br><span class="line"><span class="comment">/*  $(name).attr(&quot;src&quot;, ev.target.result); */</span></span><br><span class="line">name1.<span class="title function_">setAttribute</span>(<span class="string">&quot;src&quot;</span>, ev.<span class="property">target</span>.<span class="property">result</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outdifficulty</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> text = obj.<span class="property">innerText</span>;</span><br><span class="line">$(<span class="string">&quot;.pr-inner-xz:eq(0)&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;value&quot;</span>, text);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outdifficulty2</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> text = obj.<span class="property">innerText</span>;</span><br><span class="line">$(<span class="string">&quot;.pr-inner-xz:eq(1)&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;value&quot;</span>, text);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除功能</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">del</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> a = obj.<span class="property">parentNode</span>;</span><br><span class="line">a.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">del1</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> a = obj.<span class="property">parentNode</span>.<span class="property">parentNode</span>;</span><br><span class="line">a.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">userkouweitext</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> text = obj.<span class="property">innerText</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span><br><span class="line">$(<span class="string">&quot;.kouweiinput&quot;</span>).<span class="title function_">val</span>(text);</span><br><span class="line">$(<span class="string">&quot;.kouweilist&quot;</span>).<span class="title function_">fadeOut</span>(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pushcode</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line"><span class="attr">async</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="attr">dataType</span>:<span class="string">&quot;json&quot;</span>,</span><br><span class="line"><span class="attr">type</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line"><span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/user/getSession&quot;</span>,</span><br><span class="line"><span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">date</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (date.<span class="property">data</span> == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">obj.<span class="property">src</span> = <span class="string">&quot;http://localhost:8080/recipe/getCode?id=&quot;</span> +date.<span class="property">data</span>.<span class="property">id</span>+ <span class="string">&quot;&amp;&quot;</span> + <span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pushcode2</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line"><span class="attr">async</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="attr">dataType</span>:<span class="string">&quot;json&quot;</span>,</span><br><span class="line"><span class="attr">type</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line"><span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/user/getSession&quot;</span>,</span><br><span class="line"><span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">date</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (date.<span class="property">data</span> == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">obj.<span class="property">src</span> = <span class="string">&quot;http://localhost:8080/menu/getCode?id=&quot;</span> +date.<span class="property">data</span>.<span class="property">id</span>+ <span class="string">&quot;&amp;&quot;</span> + <span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outlogin</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> userimgtab = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;userimgmodel&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> longin = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;longin&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">userimgtab.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">longin.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">$.<span class="title function_">get</span>(<span class="string">&quot;http://localhost:8080/user/exist&quot;</span>,</span><br><span class="line">&#123;&#125;,</span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">assign</span>(<span class="string">&#x27;./home-page.html&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logintest</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> userimgtab = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;userimgmodel&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> admin=<span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;userimgtab&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> longin = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;longin&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line"><span class="attr">async</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="attr">dataType</span>:<span class="string">&quot;json&quot;</span>,</span><br><span class="line"><span class="attr">type</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line"><span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/user/getSession&quot;</span>,</span><br><span class="line"><span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">date</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (date.<span class="property">data</span> == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">userimgtab.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">longin.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">userimgtab.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">longin.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(date.<span class="property">data</span>.<span class="property">sign</span>==<span class="number">1</span>)&#123;</span><br><span class="line">$(admin.<span class="property">children</span>[<span class="number">0</span>]).<span class="title function_">append</span>(<span class="string">`&lt;li&gt;&lt;a href=&quot;./back-html/background.html&quot;&gt;进入后台&lt;/a&gt;&lt;/li&gt;`</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;普通用户&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">upmsg</span>(<span class="params">param</span>) &#123;</span><br><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line"><span class="attr">async</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="attr">dataType</span>:<span class="string">&quot;json&quot;</span>,</span><br><span class="line"><span class="attr">type</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line"><span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/user/getSession&quot;</span>,</span><br><span class="line"><span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">date</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (date.<span class="property">data</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">$.<span class="title function_">get</span>(<span class="string">&quot;http://localhost:8080/user/getUser&quot;</span>,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;id&quot;</span>: date.<span class="property">data</span>.<span class="property">id</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">function</span> (<span class="params">date</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> userimgmodel = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;userimgmodel&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">$(userimgmodel.<span class="property">children</span>[<span class="number">0</span>].<span class="property">children</span>[<span class="number">0</span>]).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>, date.<span class="property">data</span>.<span class="property">userInfo</span>.<span class="property">photo</span>);</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取URL传递的参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getQueryVariable</span>(<span class="params">variable</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> query = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>.<span class="title function_">substring</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> vars = query.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vars.<span class="property">length</span>; i++) &#123;</span><br><span class="line"><span class="keyword">var</span> pair = vars[i].<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pair[<span class="number">0</span>] == variable) &#123; <span class="keyword">return</span> pair[<span class="number">1</span>]; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getQueryVariable2</span>(<span class="params">variable, url</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> query = url.<span class="title function_">substring</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> vars = query.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vars.<span class="property">length</span>; i++) &#123;</span><br><span class="line"><span class="keyword">var</span> pair = vars[i].<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pair[<span class="number">0</span>] == variable) &#123; <span class="keyword">return</span> pair[<span class="number">1</span>]; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasclass</span>(<span class="params">obj, join</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;\\b&quot;</span> + join + <span class="string">&quot;\\b&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> reg.<span class="title function_">test</span>(obj.<span class="property">className</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addClass</span>(<span class="params">obj, join</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_">hasclass</span>(obj, join)) &#123;</span><br><span class="line">obj.<span class="property">className</span> += <span class="string">&quot; &quot;</span> + join;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deleteclass</span>(<span class="params">obj, join</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;\\b&quot;</span> + join + <span class="string">&quot;\\b&quot;</span>);</span><br><span class="line">obj.<span class="property">className</span> = obj.<span class="property">className</span>.<span class="title function_">replace</span>(reg, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">statuswitch</span>(<span class="params">i</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> type1 = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;type-head&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="title function_">deleteclass</span>(type1.<span class="property">children</span>[i], <span class="string">&quot;active&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;.state:eq(&quot;</span> + (i + <span class="number">2</span>) + <span class="string">&quot;)&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;#020202&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">$(<span class="string">&quot;.state:eq(&quot;</span> + (i + <span class="number">2</span>) + <span class="string">&quot;)&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;rgb(255,197,82)&quot;</span>);</span><br><span class="line"><span class="title function_">addClass</span>(type1.<span class="property">children</span>[i], <span class="string">&quot;active&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;.content2&quot;</span>).<span class="title function_">empty</span>();</span><br><span class="line"><span class="comment">//清空后用根据选择的项目进行ajax请求获取对应数据</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------</span></span><br><span class="line"><span class="comment">//收藏内部的加载</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">$(<span class="string">&quot;.recipe-head&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;display&quot;</span>, <span class="string">&quot;block&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;.content2&quot;</span>).<span class="title function_">empty</span>();</span><br><span class="line"><span class="comment">//ajax请求收藏菜谱的数据！！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">$(<span class="string">&quot;.recipe-head&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;display&quot;</span>, <span class="string">&quot;none&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">search</span>(<span class="params">param</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> tabsearchcontent = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;tabsearchcontent&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tabsearchcontent.<span class="property">value</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">assign</span>(<span class="string">`searchpage.html?name=<span class="subst">$&#123;tabsearchcontent.value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>  <span class="title function_">zuiresousuo</span>(<span class="params">obj</span>) &#123; </span><br><span class="line"><span class="keyword">let</span> url=<span class="built_in">encodeURI</span>(<span class="string">`searchpage.html?name=<span class="subst">$&#123;obj.children[<span class="number">0</span>].innerText&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">assign</span>(url);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">search1</span>(<span class="params">param</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> tabsearchcontent = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;tabsearchcontent&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tabsearchcontent.<span class="property">value</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">assign</span>(<span class="string">`../searchpage.html?name=<span class="subst">$&#123;tabsearchcontent.value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fenlei</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> url=<span class="built_in">encodeURI</span>(<span class="string">`../searchpage.html?name=<span class="subst">$&#123;obj.innerText&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">assign</span>(url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fenlei1</span>(<span class="params">obj</span>) &#123;  </span><br><span class="line"><span class="keyword">let</span> url=<span class="built_in">encodeURI</span>(<span class="string">`./searchpage.html?name=<span class="subst">$&#123;obj.innerText&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">assign</span>(url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">textnums</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">value</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">200</span>-obj.<span class="property">value</span>.<span class="property">lenght</span>&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">obj.<span class="property">value</span>.<span class="property">lenght</span>=<span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"> $(<span class="string">&quot;.talknums&quot;</span>).<span class="title function_">text</span>(<span class="string">`还可以输入<span class="subst">$&#123;<span class="number">200</span>-obj.value.length&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">zitinums</span>(<span class="params">obj</span>)&#123;</span><br><span class="line"><span class="keyword">let</span> obj1=obj.<span class="property">parentNode</span>;</span><br><span class="line"><span class="keyword">let</span> kuang=obj1.<span class="property">children</span>[<span class="number">1</span>].<span class="property">children</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="number">200</span>-obj.<span class="property">value</span>.<span class="property">lenght</span>&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">obj.<span class="property">value</span>.<span class="property">lenght</span>=<span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">$(kuang).<span class="title function_">text</span>(<span class="string">`还可以输入<span class="subst">$&#123;<span class="number">200</span>-obj.value.length&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有注释，因为也就我一个人看😎</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本周项目总结</title>
      <link href="/2022/04/23/%E6%9C%AC%E5%91%A8%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2022/04/23/%E6%9C%AC%E5%91%A8%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>这周我们组后端接口提供的差不多了，压力来到了我们前端，这周完成了主页面的热门菜谱显示，菜单的上传，用户界面的中，菜谱菜单的显示，及菜谱的删除功能，菜谱详情页的展示，关注和收藏，对登录注册页面的重写，美化了用户界面，判断更加严谨，</p><p>在交互中遇到了很多问题，不过都是些小问题，只要交流好都不是问题，这周的交互中，主要是对以前不合理的地方进行修改，代码更加具有普适性，可以搬运，减少重复性劳动，JS中还是要注意规范，不然一个小错误，可能会浪费大量的时间,很难发现</p><p>下周，我计划把网站主体所有功能全部实现，当然评论功能不在其中，因为想要实现一个好的评论功能，可能需要大量的时间，等把主要功能做的差不多了，再去做评论，还有就是上传数据的前端判断，下周把上传相关的判断给完善一下，防止错误数据和空数据的上传，还有界面的美化，感觉还是主要在我们前端，各种交互，需要总结一下经验，如果还有时间，会继续增加功能，</p><p>最后分享一个正则表达式</p><p>是用来检测邮箱的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^[0-9a-zA-Z_.-]+[@][0-9a-zA-Z_.-]+([.][a-zA-Z]+)&#123;1,2&#125;$/</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周总结关于项目</title>
      <link href="/2022/04/16/%E5%91%A8%E6%80%BB%E7%BB%93%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE/"/>
      <url>/2022/04/16/%E5%91%A8%E6%80%BB%E7%BB%93%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>这周静态页面基本已经完工，没剩几个页面了，</p><p>在交互方面实现了，用户的登录注册，账户信息的修改，菜谱步骤的上传（实现了一半），这周的交互我发现前后端传收数据，需要确定好发送的格式，需要与后端讨论好如何去存储一些信息，此次的图片上传中，学会了使用JS原生的FormData来传输文件，传输文件时要使用$.ajax而不能直接使用$.post因为需要调整一些参数的类型，</p><p>如下是一个例子</p><p>我使用$.ajax传输一个图片文件</p><p>其中把</p><p>contentType设置成了false</p><p>processData设置成了false</p><p>就时不对我所发送的数据做处理；直接发送</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">userimg2</span>(<span class="params">param</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> file=param.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">let</span> senddata = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">   senddata.<span class="title function_">append</span>(<span class="string">&quot;file&quot;</span>,file);</span><br><span class="line">   senddata.<span class="title function_">append</span>(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">let</span> ready = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">   $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&quot;http://10.102.241.171:8080/user/insertUserPhoto&quot;</span>,</span><br><span class="line">      <span class="attr">data</span>: senddata,</span><br><span class="line">      <span class="attr">contentType</span>:<span class="literal">false</span>,</span><br><span class="line">      <span class="attr">processData</span>:<span class="literal">false</span>,</span><br><span class="line">      <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span>(response.<span class="property">msg</span>==<span class="string">&quot;插入成功！&quot;</span>)&#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">msg</span>);</span><br><span class="line">            <span class="keyword">let</span> name1 = param.<span class="property">parentNode</span>.<span class="property">parentNode</span>.<span class="property">children</span>[<span class="number">0</span>];</span><br><span class="line">            ready.<span class="title function_">readAsDataURL</span>(file);</span><br><span class="line">            ready.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span><br><span class="line">               name1.<span class="title function_">setAttribute</span>(<span class="string">&quot;src&quot;</span>,ev.<span class="property">target</span>.<span class="property">result</span>);</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">error</span>:<span class="keyword">function</span> (<span class="params">param</span>) &#123;</span><br><span class="line">         <span class="title function_">alert</span>(<span class="string">&quot;失败了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有就是，插入图片的直接显示</p><p>如下传入一个类型为file的input </p><p>通过readAsDataUrl把文件转为base64格式直接赋给img的src属性就能显示了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">imgup</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> file=obj.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> reader = <span class="keyword">new</span>  <span class="title class_">FileReader</span>();</span><br><span class="line"><span class="keyword">let</span> name1=obj.<span class="property">parentNode</span>.<span class="property">children</span>[<span class="number">0</span>];</span><br><span class="line">     reader.<span class="title function_">readAsDataURL</span>(file);</span><br><span class="line">     reader.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span><br><span class="line">        <span class="comment">/*  $(name).attr(&quot;src&quot;, ev.target.result); */</span></span><br><span class="line"> name1.<span class="title function_">setAttribute</span>(<span class="string">&quot;src&quot;</span>,ev.<span class="property">target</span>.<span class="property">result</span>)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thymeleaf</title>
      <link href="/2022/04/10/Thymeleaf/"/>
      <url>/2022/04/10/Thymeleaf/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p> 1. Thymeleaf概述</p><p>Thymeleaf是一个Java模板引擎，支持html、xml、text、javascript、css、raw这几种模型。 </p><p>使用Thymeleaf首先需要引入命名空间</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html  <span class="attr">xmlns</span>:th=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>2. 基本使用方法</p><p>1⃣️引用web静态资源 </p><p>Thymeleaf通过”@{}”来引用web静态资源，例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script <span class="attr">th</span>:src=<span class="string">&quot;@&#123;bootstrap/js/boostrap.min.js&#125;&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>2⃣️访问model模型中的数据，例如访问一个user对象的name属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;span <span class="attr">th</span>:text=<span class="string">&quot;$&#123;user.name&#125;&quot;</span>&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>3⃣️在Javascript中访问model模型数据</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script <span class="attr">th</span>:inline=<span class="string">&quot;javascript&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> user = [[$&#123;user&#125;]]</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span> + <span class="string">&quot;\t&quot;</span> + user.<span class="property">age</span>);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>  这一段时间，感觉自己学习的还是太少，不会的很多，学无止境，各种模版都需要学习，现在开始了前后端交互，怎么合作，怎么合作好是现在我面临的问题，第一次交互，我觉得能后收获很多东西，希望能够顺利完成这次的任务。</p><p>之后会继续写静态页面，等后端接口能用了，在进行下一步</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS引擎的执行机制</title>
      <link href="/2022/04/02/JS%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/04/02/JS%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><em><strong>1.首先JS是单线程的</strong></em></p><p><strong><em>2.JS的Event Loop是JS的执行机制。深入了解JS的执行,就等于深入了解JS里的event loop</em></strong></p><p>Event loop事件循环</p><p>先看一个例子如下:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个例子的执行输出顺序是1 3 2；</p><p>也就是说,setTimeout里的函数并没有立即执行,而是延迟了一段时间,满足一定条件后,才去执行的,这类代码,我们叫异步代码。</p><p>JS中有两类任务，一类是同步任务，一类是异步任务</p><p>按照这种分类方式:JS的执行机制是</p><blockquote><p><strong>Event Table</strong> 就是个注册站：调用栈让Event Table注册一个函数，该函数会在达到条件后被调用。当指定的事情发生时，Event Table会将这个函数移到Event Queue。<strong>Event Queue</strong>其实就是个缓冲区域，这里的函数等着被调用并移到调用栈。</p></blockquote><ul><li>首先判断JS是同步还是异步,同步就进入主线程,异步就进入event table</li><li>异步任务在event table中注册函数,当满足触发条件后,被推入event queue</li><li>同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主线程中</li></ul><p>以上三步循环执行,这就是event loop；</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">​</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)<span class="comment">//同步任务进入主线程；直接输出</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="comment">/*异步任务进入event table(注册站)等待0秒后被放入event queue(缓冲区)中；待主线程行完成后在去缓冲区中看看有没有任务，再执行*/</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)<span class="comment">//同步任务进入主线程直接输出；</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>还有一种情况，假如在一个程序中，有许多个异步任务，那么先执行哪一个呢？；在异步任务中并不是按照进入事件队列的先后顺序去执行的；而是另有规定；</p><p>再举一个例子：如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定时器开始啦&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;马上执行for循环啦&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">        i == <span class="number">99</span> &amp;&amp; <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行then函数啦&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;代码执行结束&#x27;</span>);</span><br><span class="line">   </span><br></pre></td></tr></table></figure><blockquote><p> 这段代码中；第一个定时器是异步任务会被放到event  table中；</p><p>new Promise 是同步任务，会被放到主线程中直l接执行打印</p><p>.then里的函数是异步任务，被放到event table</p><p>console.log(‘代码执行结束’)；是同步代码被放到主线程中；直接执行；</p></blockquote><p> 结果是：      马上执行for循环啦 -– 代码执行结束 -– 执行then函数啦 -– 定时器开始啦</p><p><strong>如果仅仅按照异步同步去判断执行流程是不足够的，不够准确,</strong></p><p>像上面的这个代码.then   和   setTimeout都是异步的，但是执行结果并没有按照进入事件队列的顺序执行的，</p><p>而准确的划分方式是按照<strong>宏任务</strong>和<strong>微任务</strong>划分的</p><p>macro-task(宏任务)：包括整体代码script，setTimeout,setInterval</p><p>micro-task(微任务)：promise，process,nextTick;</p><p><img src="https://img-blog.csdnimg.cn/b93c9dddfb2246af9f5960c0edf540bd.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rqQ5YiD,size_20,color_FFFFFF,t_70,g_se,x_16"></p><blockquote><p>首先执行script下的宏任务,遇到setTimeout,将其放到宏任务的【队列】里（这个在下一个事件循环的宏任务里添加，不是在当前宏任务中添加的）</p><p>遇到 new Promise直接执行,打印”马上执行for循环啦”</p><p>遇到then方法,是微任务,将其放到微任务的【队列里】</p><p>打印 “代码执行结束”</p><p>本轮宏任务执行完毕,查看本轮的微任务,发现有一个then方法里的函数, 打印”执行then函数啦”</p><p>到此,本轮的event loop 全部完成。</p></blockquote><p>下一轮的循环里,先执行一个宏任务,发现宏任务的【队列】里有一个 setTimeout里的函数,执行打印”定时器开始啦了；</p><p><a href="https://segmentfault.com/a/1190000012806637" title="原内容地址，感谢博主的精心讲解！">原内容地址，感谢博主的精心讲解！</a></p><p>周总结：</p><p>这周在学习js高级的内容；内容可以说很多，可以学习的知识很深，我现在只是浅浅的明白一些内容；红宝书的内容很多；这周学习总体上理论上的东西比较多；接下来我会进行实践，实际操作一下更深层次的理解；闭包，对象创建模式；继承都没有进行实践操作过；也不太清楚什么时候会用</p><p>希望能够尽快进行前后端交互;让我多一些实战经验；实际操作可比看书能学到的多的多；这周感觉挺累的，需要稍稍调整一下，马上就要有新成员进来了；我们的压力大了一些，可不能让他们超越了已经学了几个月的我们，要不然就感觉我们学习效率很低；</p><p>加油继续努力（卷）；</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS对象创建模式</title>
      <link href="/2022/03/27/JS%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/03/27/JS%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>对象创建模式有以下几种：</p><p><strong>1.工厂模式</strong></p><p><strong>2.构造函数模式</strong></p><p><strong>3.原型模式</strong></p><p><strong>4.组合使用构造函数模式和原型模式</strong></p><p><strong>5.动态原型模式</strong></p><p><strong>6.寄生构造函数模式</strong></p><p><strong>7.稳妥构造函数模式</strong></p><p>1.<strong>工厂模式</strong> 一种函数用函数来封装以特定接口创建对象的细节</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line"> <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line"> o.<span class="property">name</span> = name; </span><br><span class="line"> o.<span class="property">age</span> = age; </span><br><span class="line"> o.<span class="property">job</span> = job; </span><br><span class="line"> o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="keyword">return</span> o; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="title function_">createPerson</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="title function_">createPerson</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure><p>函数 createPerson()能够根据接受的参数来构建一个包含所有必要信息的 Person 对象。可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建 多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。随着 JavaScript 的发展，又一个新模式出现了。</p><p>2.<strong>构造函数模式</strong></p><p>构造函数可以用来创建特定类型的对象，像object 和Array这样的原生构造函数，可以自定义构造函数，从而定义对象的类型的属性和方法；还是上面的例子用构造函数重写如下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">job</span> = job; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125;; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样对象的类型就能够知道对象的类型</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(person1.<span class="property">constructor</span> == <span class="title class_">Person</span>); <span class="comment">//true </span></span><br><span class="line"><span class="title function_">alert</span>(person2.<span class="property">constructor</span> == <span class="title class_">Person</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>对象的 constructor 属性最初是用来标识对象类型的。但是，提到检测对象类型，还是 instanceof 操作符要更可靠一些。我们在这个例子中创建的所有对象既是 Object 的实例，同时也是 Person 的实例，这一点通过 instanceof 操作符可以得到验证。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">//true </span></span><br><span class="line"><span class="title function_">alert</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">//true </span></span><br><span class="line"><span class="title function_">alert</span>(person2 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">//true </span></span><br><span class="line"><span class="title function_">alert</span>(person2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式 胜过工厂模式的地方</p><p>3.<strong>原型模式</strong></p><p>我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象， 而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那 么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以 让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是 可以将这些信息直接添加到原型对象中，如下面的例子所示。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">//&quot;Nicholas&quot; </span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">//&quot;Nicholas&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">sayName</span> == person2.<span class="property">sayName</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>原型的内容在上一篇博客种已经说过；</p><p>4.<strong>组合使用构造函数模式和原型模式</strong></p><p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实 例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本， 但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参 数；可谓是集两种模式之长。下面的代码重写了前面的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">job</span> = job; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123; </span><br><span class="line"> constructor : <span class="title class_">Person</span>, </span><br><span class="line"> sayName : <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); </span><br><span class="line">person1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Van&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">friends</span>); <span class="comment">//&quot;Shelby,Count,Van&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(person2.<span class="property">friends</span>); <span class="comment">//&quot;Shelby,Count&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">friends</span> === person2.<span class="property">friends</span>); <span class="comment">//false </span></span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">sayName</span> === person2.<span class="property">sayName</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性 constructor 和方 法 sayName()则是在原型中定义的。而修改了 person1.friends（向其中添加一个新字符串），并不 会影响到 person2.friends，因为它们分别引用了不同的数组</p><p>5.<strong>动态原型模式</strong></p><p>可以通过 检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line"> <span class="comment">//属性</span></span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">job</span> = job; </span><br><span class="line"> <span class="comment">//方法</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span>.<span class="property">sayName</span> != <span class="string">&quot;function&quot;</span>)&#123; </span><br><span class="line"> <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125;; </span><br><span class="line"> </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line">friend.<span class="title function_">sayName</span>(); </span><br></pre></td></tr></table></figure><p><strong>使用动态原型模式时，不能使用对象字面量重写原型，如果 在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。</strong></p><p>6.<strong>寄生构造函数模式</strong></p><p>这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊 数组。由于不能直接修改 Array 构造函数，因此可以使用这个模式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SpecialArray</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="comment">//创建数组</span></span><br><span class="line"> <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="title class_">Array</span>(); </span><br><span class="line"> <span class="comment">//添加值</span></span><br><span class="line"> values.<span class="property">push</span>.<span class="title function_">apply</span>(values, <span class="variable language_">arguments</span>); </span><br><span class="line"> <span class="comment">//添加方法</span></span><br><span class="line"> values.<span class="property">toPipedString</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">join</span>(<span class="string">&quot;|&quot;</span>); </span><br><span class="line"> &#125;; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//返回数组</span></span><br><span class="line"> <span class="keyword">return</span> values; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="title class_">SpecialArray</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">toPipedString</span>()); <span class="comment">//&quot;red|blue|green&quot; </span></span><br></pre></td></tr></table></figure><p>关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属 性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此， 不能依赖 instanceof 操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情 况下，不要使用这种模式。</p><p>6.<strong>稳妥构造函数模式</strong></p><p>道格拉斯·克罗克福德（Douglas Crockford）发明了 JavaScript 中的稳妥对象（durable objects）这 个概念。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。稳妥对象最适合在 一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其他应用程序（如 Mashup 程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的 实例方法不引用 this；二是不使用 new 操作符调用构造函数。按照稳妥构造函数的要求，可以将前面 的 Person 构造函数重写如下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line"> <span class="comment">//创建要返回的对象</span></span><br><span class="line"> <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line"> <span class="comment">//可以在这里定义私有变量和函数</span></span><br><span class="line"> <span class="comment">//添加方法</span></span><br><span class="line"> o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="title function_">alert</span>(name); </span><br><span class="line"> &#125;; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//返回对象</span></span><br><span class="line"> <span class="keyword">return</span> o; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也 没有什么关系，因此 instanceof 操作符对这种对象也没有意义。</p><blockquote><p>《Javascript高级程序设计》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型链prototype和__proto__</title>
      <link href="/2022/03/19/%E5%8E%9F%E5%9E%8B%E9%93%BEprototype%E5%92%8C__proto__/"/>
      <url>/2022/03/19/%E5%8E%9F%E5%9E%8B%E9%93%BEprototype%E5%92%8C__proto__/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>所有的 JavaScript 对象都会从一个 prototype（原型对象）中继承属性和方法。</p><p>显示原型和隐式原型；构造函数的显示原型用来存放函数对象，而实例对象的隐式原型等同于构函数的显示原型。所有对象的原型最终都指向object对象，object是原型链的顶端；</p><p><img src="https://img-blog.csdnimg.cn/e4eb068bd2ff4832b6263231b504ec99.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rqQ5YiD,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p><p>function的构造函数也是function，隐式原型指向function的原型对象；</p><p>而function的隐式原型指向object对象的显示原型，object没有隐式原型。object就是最顶层的对象；</p><p>当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它的’_ _ proto_ _‘属性(也就是它的构造函数的’prototype’属性)中去寻找，如果他的构造函数的prototype中没有这个属性就会去object中去寻找。再找不到就没有了；</p><p>首先，fn的构造函数是Foo()。所以：<br>fn._ _ proto _ _=== Foo.prototype<br>又因为Foo.prototype是一个普通的对象，它的构造函数是Object，所以：<br>Foo.prototype._ _ proto _ _=== Object.prototype<br>通过上面的代码，我们知道这个toString()方法是在Object.prototype里面的，当调用这个对象的本身并不存在的方法时，它会一层一层地往上去找，一直到null为止。   </p><p><img src="https://img-blog.csdnimg.cn/cd57f2c5e51949c49e12a3fc957a9ec1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rqQ5YiD,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>暂时的理解，后续会改</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 prototype </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise解决回调函数嵌套</title>
      <link href="/2022/03/13/promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97/"/>
      <url>/2022/03/13/promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件，这就解决了，我上次写的ajax的异步造成的问题，还要在回调函数中去绑定事件，有了promise这些都不是事，有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p><p>promise对象代表一个异步操作，有三种状态pending(进行中)，fulfilled(已成功)，rejected(“已失败”)，异步操作的结果决定这个对象的状态，</p><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p><p>基本用法</p><p>创建一个promise对象，</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行了promise&quot;</span>)</span><br><span class="line">           <span class="title function_">reject</span>(<span class="string">&quot;执行成功返回的数据像接口数据啥的&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       ,<span class="number">1000</span>)</span><br><span class="line">     &#125;)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/f003286678cc48fd81dfb73761b53b1a.png"></p><p> 这我只是创建了一个对promise对象但是却执行了，Promise 新建后就会立即执行。</p><p>所以应该把promise对象放在函数了，比如单击事件函数，单机之后才会新建promise对象然后执行，</p><p>其中两个参数，resolve   reject是两个函数，是由js引擎提供的，不需要自己写</p><p>resolve函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定resolved状态和<code>Promise</code>状态的回调函数。</p><p>promise对象的then方法，可以将两个回调函数作为参数，第一个会回调函数就是当promise的状态为resolve的时候调用的并且可以接受传来的数据。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">       <span class="comment">//成功之后</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/e76bc85121e2457a96cb4dc58ba1de38.png"></p><p> 状态变为resolve之后就会执行then方法的第一个回调函数，并且把数据也传了过来，在进行操作就行了，类似于这样在Ajax中请求成功就把返回数据用resolve函数传递，就会执行then方法的第一个回调函数，在回调函数中也可以再return  promise对象，进行回调函数的执行，形成链式，如果不用promise，在Ajax的回调函数中写就会形成多层嵌套，代码一直往右延申，不利于观察，用promise链式，可以代码让代码看起来更有条理，</p><p>这就我现在的理解，可能有错误，后续会改</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 javascript 前端 react.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AJAX相关问题的解决</title>
      <link href="/2022/03/06/AJAX%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
      <url>/2022/03/06/AJAX%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>AJAX是一默认是异步的程序，AJAX执行的时候是没有顺序性的，就在第一个接口还没有把返回的数据传入dom时，就已经执行其他代码了，如果在这完成之前去用js去获取用ajax加入dom的元素，是获取不到的，但是在一些小型的请求可通过把ajax中的async=flase，设置成同步，就能够在ajax完全执行完成之后，在进行之后的代码，就能够用js获取到动态添加的内容了。</p><p>但是这不是一个好方法，只能满足小型请求是不行的 ，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止，也可以在开启异步时，在ajax的回调函数中去对动态添加的元素进行获取；绑定事件。这是一个挺好用的方法，</p><p>        还有一个方法，这不是一个好方法，但是我觉得还挺有意思，在js中设置一个定时器，把对动态添加的内容执行的函数放到里面，这样无论什么时候ajax加载完成，定时器在反复的寻找需要绑定函数的内容，找到了，就绑定；（感觉有bug，可能和网速有关系。尽量不用）</p><p>        之后继续学习es6的规则；应用到代码中，再深入了解了解ajax，还有jq工具库。</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 ajax javascript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于git</title>
      <link href="/2022/02/27/%E5%85%B3%E4%BA%8Egit/"/>
      <url>/2022/02/27/%E5%85%B3%E4%BA%8Egit/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>git是一种版本控制器，git的安装非常简单，下一步就行了。</p><p>git的基本操作；</p><p>在需要记录版本的文件夹中用，git init创建本地库</p><p>首次使用需要配置一下个人的用户名和电子邮件地址，输入一下两行代码</p><p>$ git config --global user.name “用户名”</p><p>$git config --global user.email 邮箱</p><p>可以输入一下代码查看是否配置成功</p><p>$git config --list</p><p>git有三个部分，工作区，暂存区，本地库，也可以上传至远程库</p><p>git的基本操作；</p><p>git init 初始化操作</p><p>git add 添加文件到暂存区</p><p>git commit 将暂存区的内容添加到本地仓库中；</p><p>git status 查看仓库当前状态</p><p>git diff 比较暂存区和工作区的差异</p><p>git reset 版本号 回退版本；</p><p>git rm 删除工作区文件</p><p>git mv 移动或重命名工作区文件。</p><p>git log 查看历史提交记录</p><p>git blame&lt;file&gt;以列表形式查看指定文件的历史修改记录</p><p>git remote 远程仓库操作</p><p>git fetch 从远程库获取代码库</p><p>git pull 下载远程代码并合并</p><p>git push 上传远程代码并合并</p><p>其中git pull git fetch git cloned的区别</p><p>git pull相当于是从远程获取最新版本并merge（合并）到本地 git pull = git fetch + git merge</p><p><strong>git fetch</strong> 命令用于从远程获取代码库，该命令执行完后需要执行 git merge 远程分支到你所在的分支。</p><p>git clone 拷贝一个git仓库到本地，本地无需初始化仓库也能拷贝，这是完全拷贝，连历代记录都进行了拷贝，历代版本信息也有，</p><p>2.分支管理</p><p>git branch -v 可以查看分支</p><p>git branch 分支名      可以创建分支，</p><p>git checkout 分支名       可以切换分支</p><p>git merge 分支名      可以合并分支到当前分支；</p><p>git其实还可以用来保存游戏存档的历代版本，当打游戏材料消耗完了，这个时候只需要回退版本，就能恢复存档。</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习记录2</title>
      <link href="/2022/01/23/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/"/>
      <url>/2022/01/23/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>        做考核页面也有三四天了，进展很慢，前一部分的内容很细，有好多小地方需要处理；今天我做到了那个轮播图左边的功能栏的地方了，自我感觉这个地方是最不好做的，希望明天之前能够完成，后面的就好做了。这个地方中，当鼠标放上时，一整排图标上移并且弹出内容栏，肯定要用到动画，也能用JS来写，我尽量能用CSS就不用JS，虽然JS很好用，可以操作基本所有东西，但是还是尽量用基本的写，我的思路就是，先给图标开启定位，当鼠标放上时，让其上移，还有一个同步触发的事件，让该弹出的内容由高度为零变成预定高度，这个过程加一个过渡动画，内容区再用JS去写页面左右切换；现在只是这样想，希望能够实现。希望不要花费太多时间，</p><p>        还有7天就要过年了，希望能够在过年之前写好页面，好好过年，最近学习写页面总感觉时间过的很快，还没有写多少就一天过去了，希望能够提升效率，注意力集中，上午去写一些逻辑性的东西，晚上把文字内容填一填。规划好时间，加油，上班不摸鱼。希望和同学们一起进步，争取突破一下。成为肝帝！！</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 html 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回顾CSS内容</title>
      <link href="/2022/01/16/%E5%9B%9E%E9%A1%BECSS%E5%86%85%E5%AE%B9/"/>
      <url>/2022/01/16/%E5%9B%9E%E9%A1%BECSS%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><strong>目录</strong></p><p><a href="#1.%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90">1.弹性盒子</a></p><p><a href="#2.%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE">2.文本标签</a></p><p><a href="#3.%E5%AE%9A%E4%BD%8D">3.定位</a></p><hr><h2 id="1-弹性盒子"><a href="#1-弹性盒子" class="headerlink" title="1.弹性盒子"></a>1.弹性盒子</h2><p>flex</p><p>flex-direction 指定容器中弹性元素的排列方式；</p><p>主轴由flex的设置的方向决定；</p><p>flex-grow指定弹性元素伸展的系数默认值是零；</p><p>当父元素有多余的空间时子元素如何伸展，0就是不伸展，</p><p>要是把flex-grow写入子元素，则子元素按照flex-grow的比值被分配剩余空白部分</p><p>flex-shrink表示收缩系数。当父元素不足以容纳子元素时对子元素进行收缩</p><p>当值为零的时候就是不收缩，当外面的框小的时候内容会溢出</p><p>这时使用flex-wrap：wrap；多出的部分会沿着辅轴方向排列</p><p>flex-flow是简写属性</p><p>justify-content</p><p>如何分配空白区域</p><p>flex-start 元素沿着主轴起边排列</p><p>flex-end 元素沿着主轴终边排列</p><p>center 元素居中排列</p><p>sparce-between 空白均匀分布到元素间</p><p>spare-around 空白分布到元素两侧。</p><p>在纵向上align-item</p><p>中stretch属性把元素的长度设置为相同的值；</p><p>指的是行与行之间的高度</p><p>flex-start：元素不会拉伸，沿着辅轴起边方向对齐</p><p>flex-end：沿着辅轴终边对齐</p><p>flex-baseline：沿着基线对齐就是文字底边的基线。</p><p>在纵轴上分配空白空间</p><p>用align-conent：</p><p>和横着的一样。</p><p>设置弹性元素的属性</p><p>flex-basic:可以设置弹性元素的基础长度；</p><p>如果主轴是纵向的则设置的是高度；</p><h2 id="2-文本标签"><a href="#2-文本标签" class="headerlink" title="2.文本标签"></a>2.文本标签</h2><p>html格式化标签粗体表示重要性（内容的重要性）或者斜体表示着重点（语气上的强调）表示你要呈现的文章时重要的所以要突出显示 一个粗体，一个斜体</p><p>与是定义粗体或斜体文本与上面的那两个是不一样的</p><p>cite标签：网站中所有加书名号的内容都可以使用cite标签</p><p>《XXX》</p><p>短引用标签的内容浏览器会默认给他加上一个“”</p><p>blockquote长引用（块级引用不能放在中）</p><p>独占一行</p><p>sup标签用来表示一个上标；</p><p>sub标签用来表示一个下标；</p><p>del标签用来表示一个删除的内容画一个横线</p><p>ins表示插入一个内容插入的内容有下划线</p><p>pre标签时预格式标签保留了格式；</p><p>code专门用来表示代码的标签</p><h2 id="3-定位"><a href="#3-定位" class="headerlink" title="3.定位"></a>3.定位</h2><p>通过position属性</p><p>relative是相对定位</p><p>当开启元素相对定位时，而不设置偏移量。和没有设置一样</p><p>2：开启后可以通过，left right top bottom 四个属性设置元素的偏移量。</p><p>是相对与原来位置移动的。</p><p>3：相对定位的元素不会脱离文档流。原来的位置虽然是空的但还占位置。</p><p>4：相对定位会使元素提升一个层级。会覆盖其他元素。</p><p>通常偏移量使用两个就可以对一个元素进行定位。</p><p>相对定位，不会该改变元素的性质，块还是块，内联还是内联</p><p>绝对定位absolute</p><p>开启绝对定位后脱离文档流</p><p>开启绝对定位后</p><p>而且是相对于浏览器窗口定位的</p><p>3：绝对定位是相对于离他最近的的开启了定位的祖先元素定位的</p><p>（一般情况开启子元素的绝对定位，也会开启祖先元素的绝对定位。）</p><p>4：如果所有的祖先元素都未开启定位，则会相对于浏览器窗口定位。</p><p>5：绝对定位会使元素提升一个层级</p><p>6：定位会改变元素的性质</p><p>内联元素变成块元素，块元素的宽度和高度默认被内容撑开</p><p>固定定位fixed</p><p>position也是一种绝对定位</p><p>它的大部分特点都和绝对定位一样</p><p>不同的是：</p><p>固定定位永远会相对于浏览器窗口进行定位</p><p>固定定位会固定在浏览器窗口的某个位置，不会随滚顶条滚动</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 css 前端 html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近期学习随笔</title>
      <link href="/2021/12/29/%E8%BF%91%E6%9C%9F%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/"/>
      <url>/2021/12/29/%E8%BF%91%E6%9C%9F%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>前些天闭组了，虽然闭组了，但是我还是每天坚持来小组学习，开始认真学习专业课程，闭组第一天我早上睡到了九点多，睡了个懒觉，起来之后神清气爽，非常有精神，带上书包就去小组学习了，小组的人很少，没有了往日的热闹和紧张的氛围，但是在这的人还是非常认真的在学习，坐到这里才有学习的动力，在寝室老是想玩游戏，不能很好的学习效率很低，所以我每天还是来小组学习，养成一个好习惯，闭组这段时间我每天晚上都是十点回去，没有像往常一样十点四十回去，毕竟还是想放轻松一下，现在是大一觉得不应该那么卷，还是想轻松一点，适度学习，适度躺平。</p><p>  马上就要放假了，回家每天学习点JS，我觉得应该能够把那个一百多集的视频看完，并学会。希望小组的任务能够轻松一些，每天肝个几个小时就能完成的那种。我们家那边疫情比较严重，只能在家，任务应该都能完成。希望寒假不会延期开学，希望明年疫情消退，让我们大一的出去玩玩吧。寒假我也出不去，我们周口疫情挺严重的，家周围都封闭了，回去还要隔离七天，只有电脑陪我了。期末加油！</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端考核感想</title>
      <link href="/2021/12/13/%E5%89%8D%E7%AB%AF%E8%80%83%E6%A0%B8%E6%84%9F%E6%83%B3/"/>
      <url>/2021/12/13/%E5%89%8D%E7%AB%AF%E8%80%83%E6%A0%B8%E6%84%9F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>        这次前端考核时间很充裕但是我并没有好好利用做的时候有点莽，刚开始先写的整体框架内容填完之后，而且动画还有特效都做好了，才发现一缩小布局是乱的，虽然下边没有出现滚动条，但是我的内容全部都被压缩了，我的内容区的盒子宽度是按照百分比写的，而且使用的是绝对定位，没有响应式布局，直到了最后一天，我才进行改动把所有内容区的宽度改成了固定像素值，并且设置了媒体查询，缩小的页面进行布局。把本来变形的布局改了回来，当然这也不能改变大框架的弄错带来的问题，以后再写就明白怎么去写了，先想明白再去动手不然之后再去修改会很麻烦，总体来说前端做出来的效果事可以看到的，成就感比较强，自己脑海中所想的能够做出来，</p><p>        这一阶段结束之后就要分前后端学习了，两个方向都不容易，都挺好，所以现在我以我的兴趣为导向进行选择，我打算选择前端，我觉得前端我有学下去的动力，我想象力很好，我觉得对前端的学习有所帮助。这马上就要期末考试了，要注意课程的学习，不能挂科，尽量安排好自己的时间，小组学习和正常课程，都要弄好，</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 html asp.net </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高度塌陷问题的解决办法</title>
      <link href="/2021/12/05/%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2021/12/05/%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>在HTML文档中元素默认是在文档流中的，在文档流中块级元素会独占一行从上至下排列，而内联元素，所谓的行内元素，指的是只占自身大小的元素，不会占用一行</p><p>行内元素有：a b span img input select strong（强调的语气）<br>块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p </p><p><strong>首先什么是高度坍塌？</strong></p><p>在文档流中，父元素的高度默认是被子元素撑开的。</p><p>也就是子元素多高，父元素多高。</p><p>但是当子元素设置浮动时，子元素会脱离文档流</p><p>此时将会导致子元素无法撑起父元素的高度造成父元素塌陷，则父元素下的所有元素都会上移这样导致页面布局混乱。</p><p>解决办法有好几种，但是某些办法有局限性。在不同浏览器中也会出现不兼容的问题</p><p>**一.**把浮动元素所在盒子的高度定死，设置一个不可变的高度。这样容易出现内容溢出的问题。造成布局混乱</p><p><strong>二</strong>、开启BFC属性<br>根据W3C的标准，在我们的页面中元素都有一个隐含的属性叫做“Block Formatting Context”，简称BFC，该属性可以设置打开或者关闭，默认是关闭的。当我们开启元素的BFC以后，元素会具有以下特性：<br>1.父元素的垂直外边距不会和子元素重叠<br>2.开启BFC的元素不会被浮动元素覆盖<br>3.开启BFC的元素可以包含浮动的子元素<br>如何开启元素的BFC：<br>1.设置元素的浮动： 这种方式开启虽然可以撑开父元素，但是会导致父元素的宽度丢失，而且这种方式也会导致下边的元素上移，不能解决问题。<br>2.设置元素的绝对定位  </p><p>3.将我们元素的overflow设置为hidden是副作用最小的开启BFC的方式。  </p><p><strong>三</strong>、可以直接在高度塌陷的父元素的最后，添加一个空白的div<br>由于添加的div并没有浮动，所以他是可以撑开父元素的高度的，再对其进行清除浮动，可以通过空白的div来撑开父元素的高度，基本没有副作用。使用这种方式，虽然可以解决问题，但是会在页面中添加多余的结构  </p><p><strong>四、</strong>通过after伪类来选中父元素的后面<br>可以通过after伪类向元素的的最后添加一个空白的块元素，然后对其清除浮动，这样做和添加div的原理一样，可以达到相同的效果，而且不会再页面中添加多余的div，最为推荐使用的方式，几乎没有副作用</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 css3 html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔记录学习</title>
      <link href="/2021/11/27/%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/11/27/%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>  今天早上没想到竟然又睡过了，我下次一定多订几个闹钟，以免过了时间。近期在学习前端知识，感觉前端的内容还挺有意思的，做出来的东西都时可见的。可以按照自己的想要的设计去设计网页，我觉得前端知识比较零散，各种各样的标签需要了解。</p><p>  学习前端有四天了，感觉没有算法要求，可能后期就有更加深的内容了吧，我看视频上介绍的前端学习的javaScript也能编写类似煜后端的内容，编写数据库；前端处于一个中间位置，既要与页面设计师协调好，也要与后端工程师协调好，所以前端工程师两边都要了解一些知识，需要学习的东西更多，</p><p>  在小组的学习感觉很好，休息时间感觉还挺多，比高中好多了高中是被迫学习自己不感兴趣的东西，整天埋头在哪里学习，十分无聊，唯一感兴趣的计算机，三年就上了3节课！！。真的是麻了，在大学刚开始的时候，感觉十分的轻松没有什么课，自己能在寝室待上一整天和心目中的大学生活不一样，大学生活应该是很丰富的，很有趣的。能够学习自己感兴趣的东西，希望在以后的时间里能够学习学习到一门手艺，编程手艺。信手拈来，想写啥就写啥。ps我也十分想学我想p我的室友哈哈。</p><h1 id="皇子yyds"><a href="#皇子yyds" class="headerlink" title="皇子yyds"></a><img src="https://img-blog.csdnimg.cn/04aafe67e48e43938f0de042d6c74295.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rqQ5YiD,size_14,color_FFFFFF,t_70,g_se,x_16"><strong>皇子yyds</strong></h1>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
